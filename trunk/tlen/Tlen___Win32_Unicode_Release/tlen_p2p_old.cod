	TITLE	E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\tlen_p2p_old.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BG@FJFA@Miranda?1System?1GetMMI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@DNA@Miranda?1System?1GetLI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@FHMP@Miranda?1System?1GetUTFI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@DCOH@Miranda?1Thread?1Fork?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@IENN@Miranda?1Thread?1ForkEx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FGIN@Miranda?1SysTerm?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@LIGC@Utils?1AddToWindowList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@PEAI@Utils?1RemoveFromWindowList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@GMNB@Utils?1FindWindowInList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@NOMI@Utils?1BroadcastToWindowList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@CFCA@Utils?1BroadcastToWindowListAsync@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@MDKL@Utils?1SaveWindowPos?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@GALP@Utils?1RestoreWindowPos?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@CHLF@Miranda?1System?1GetMD5I?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@FOPF@Miranda?1System?1GetSHA1I?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@EFDJ@Netlib?1Send?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@GFGB@Netlib?1Recv?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@CMGK@Netlib?1Log?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@GDOO@Netlib?1InitSecurityProvider?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@JINJ@Netlib?1DestroySecurityProvider?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@CBFG@Netlib?1NtlmCreateResponse?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@COCL@Proto?1EnumAccounts?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CCNI@Proto?1GetAccount?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@IFFL@Proto?1BroadcastAck?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@MGBG@DB?1Event?1GetText?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@BEPM@DB?1Contact?1GetSettingStr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@FLKM@C?3?2MirandaDev?2miranda_svn2?2inclu@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@IGCO@DB?1Contact?1DeleteSetting?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@PLGC@DB?1Contact?1WriteSetting?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@GNEH@LangPack?1TranslateDialog?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@GFNK@Skin?1Icons?1Load?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@BLFF@Skin?1Icons?1LoadProto?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@CNOA@Skin?1Sounds?1AddNew?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@LENC@Skin?1Sounds?1Play?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@PNGM@PopUp?1AddPopUp?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@OBDC@PopUp?1AddPopUpEx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@CGKI@PopUp?1AddPopUpW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@HIHP@PopUp?1GetContact?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@CCHD@PopUp?1GetPluginData?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@HKEA@PopUp?1IsSecondLineShown?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@KGOE@PopUp?1Changetext?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LAPD@PopUp?1ChangetextW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@KOPP@PopUp?1Change?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@BGJ@PopUp?1ShowMessage?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@NFFE@PopUp?1ShowMessageW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@MAHO@PopUp?1AddPopupClass?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@KCOG@Establishing?5outgoing?5connection@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NBNM@?$CF08X?$CFs?$CFd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02MECO@?$CFd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CN@MAFD@Closing?5connection?5for?5this?5file@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@JEKK@Netlib?1OpenConnection?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CF@FAEI@Connection?5failed?5?$CI?$CFd?$CJ?0?5thread?5e@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@FOKB@Send?5failed?5?$CI?$CFd?$CJ?0?5thread?5ended?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@NJPE@SOCKS5?5negotiation?5failed?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@JHMG@SOCKS5?5sub?9negotiation?5failed?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FF@HADI@E?3?2Documents?5and?5Settings?2piotr?2@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@BODO@UseFileProxy?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@GFGJ@FileProxyHost?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@MHC@FileProxyPort?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@EJJI@FileProxyAuth?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@CBEM@FileProxyUsername?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@EIFA@FileProxyPassword?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@PHIF@DB?1Crypt?1DecodeString?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@HKJF@FileProxyType?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@FHBN@Calling?5MS_NETLIB_BINDPORT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@GLLO@Netlib?1BindPort?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JJCP@listening?5on?5?$CFd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _Netlib_CloseHandle
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Netlib_Send
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Netlib_Recv
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ProtoBroadcastAck
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBGetContactSettingByte_Helper
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBGetContactSettingWord_Helper
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBGetContactSettingDword_Helper
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBGetContactSetting_Helper
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBGetContactSettingString_Helper
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBFreeVariant
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PFreeFileTransfer
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PPacketCreate
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PPacketFree
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PPacketSetType
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PPacketSetLen
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PPacketPackDword
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PPacketPackBuffer
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PInit
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PUninit
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PPacketSend
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PPacketReceive
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PEstablishOutgoingConnection
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PEstablishIncomingConnection
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenFileBindSocks4Thread
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenFileBindSocks5Thread
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PBindSocks4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PBindSocks5
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PListen
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenP2PStopListening
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_TlenP2PFreeFileTransfer
EXTRN	_mmi:BYTE
;	COMDAT _TlenP2PFreeFileTransfer
_TEXT	SEGMENT
_ft$ = 8
_TlenP2PFreeFileTransfer PROC NEAR			; COMDAT

; 31   : {

  00000	56		 push	 esi

; 32   : 	int i;
; 33   : 
; 34   : 	if (ft->jid) mir_free(ft->jid);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _ft$[esp]
  00005	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00008	85 c0		 test	 eax, eax
  0000a	74 08		 je	 SHORT $L83190
  0000c	50		 push	 eax
  0000d	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00013	59		 pop	 ecx
$L83190:

; 35   : 	if (ft->iqId) mir_free(ft->iqId);

  00014	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00017	85 c0		 test	 eax, eax
  00019	74 08		 je	 SHORT $L83191
  0001b	50		 push	 eax
  0001c	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00022	59		 pop	 ecx
$L83191:

; 36   : 	if (ft->id2) mir_free(ft->id2);

  00023	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  00026	85 c0		 test	 eax, eax
  00028	74 08		 je	 SHORT $L83192
  0002a	50		 push	 eax
  0002b	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00031	59		 pop	 ecx
$L83192:

; 37   : 	if (ft->hostName) mir_free(ft->hostName);

  00032	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00035	85 c0		 test	 eax, eax
  00037	74 08		 je	 SHORT $L83193
  00039	50		 push	 eax
  0003a	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00040	59		 pop	 ecx
$L83193:

; 38   : 	if (ft->localName) mir_free(ft->localName);

  00041	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00044	85 c0		 test	 eax, eax
  00046	74 08		 je	 SHORT $L83194
  00048	50		 push	 eax
  00049	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  0004f	59		 pop	 ecx
$L83194:

; 39   : 	if (ft->szSavePath) mir_free(ft->szSavePath);

  00050	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $L83195
  00057	50		 push	 eax
  00058	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  0005e	59		 pop	 ecx
$L83195:

; 40   : 	if (ft->szDescription) mir_free(ft->szDescription);

  0005f	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00062	85 c0		 test	 eax, eax
  00064	74 08		 je	 SHORT $L83196
  00066	50		 push	 eax
  00067	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  0006d	59		 pop	 ecx
$L83196:

; 41   : 	if (ft->filesSize) mir_free(ft->filesSize);

  0006e	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00071	85 c0		 test	 eax, eax
  00073	74 08		 je	 SHORT $L83197
  00075	50		 push	 eax
  00076	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  0007c	59		 pop	 ecx
$L83197:

; 42   : 	if (ft->files) {

  0007d	83 7e 44 00	 cmp	 DWORD PTR [esi+68], 0
  00081	74 2b		 je	 SHORT $L83198
  00083	57		 push	 edi

; 43   : 		for (i=0; i<ft->fileCount; i++) {

  00084	33 ff		 xor	 edi, edi
  00086	39 7e 40	 cmp	 DWORD PTR [esi+64], edi
  00089	7e 18		 jle	 SHORT $L83201
$L83199:

; 44   : 			if (ft->files[i]) mir_free(ft->files[i]);

  0008b	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  0008e	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00091	85 c0		 test	 eax, eax
  00093	74 08		 je	 SHORT $L83200
  00095	50		 push	 eax
  00096	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  0009c	59		 pop	 ecx
$L83200:
  0009d	47		 inc	 edi
  0009e	3b 7e 40	 cmp	 edi, DWORD PTR [esi+64]
  000a1	7c e8		 jl	 SHORT $L83199
$L83201:

; 45   : 		}
; 46   : 		mir_free(ft->files);

  000a3	ff 76 44	 push	 DWORD PTR [esi+68]
  000a6	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  000ac	59		 pop	 ecx
  000ad	5f		 pop	 edi
$L83198:

; 47   : 	}
; 48   : 	mir_free(ft);

  000ae	56		 push	 esi
  000af	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  000b5	59		 pop	 ecx
  000b6	5e		 pop	 esi

; 49   : }

  000b7	c3		 ret	 0
_TlenP2PFreeFileTransfer ENDP
_TEXT	ENDS
PUBLIC	_TlenP2PPacketCreate
;	COMDAT _TlenP2PPacketCreate
_TEXT	SEGMENT
_datalen$ = 8
_TlenP2PPacketCreate PROC NEAR				; COMDAT

; 52   : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 53   : 	TLEN_FILE_PACKET *packet;
; 54   : 
; 55   : 	if ((packet=(TLEN_FILE_PACKET *) mir_alloc(sizeof(TLEN_FILE_PACKET))) == NULL)

  00002	6a 10		 push	 16			; 00000010H
  00004	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  0000a	8b f0		 mov	 esi, eax
  0000c	59		 pop	 ecx
  0000d	85 f6		 test	 esi, esi

; 56   : 		return NULL;

  0000f	74 23		 je	 SHORT $L83669

; 57   :     packet->packet = NULL;
; 58   :     if (datalen > 0) {

  00011	8b 7c 24 0c	 mov	 edi, DWORD PTR _datalen$[esp+4]
  00015	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00019	85 ff		 test	 edi, edi
  0001b	7e 1b		 jle	 SHORT $L83216

; 59   :         if ((packet->packet=(char *) mir_alloc(datalen)) == NULL) {

  0001d	57		 push	 edi
  0001e	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  00024	85 c0		 test	 eax, eax
  00026	59		 pop	 ecx
  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002a	75 0c		 jne	 SHORT $L83216

; 60   :             mir_free(packet);

  0002c	56		 push	 esi
  0002d	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00033	59		 pop	 ecx
$L83669:

; 61   :             return NULL;

  00034	33 c0		 xor	 eax, eax
  00036	eb 0c		 jmp	 SHORT $L83205
$L83216:

; 62   :         }
; 63   :     }
; 64   : 	packet->maxDataLen = datalen;
; 65   : 	packet->type=0;

  00038	83 66 08 00	 and	 DWORD PTR [esi+8], 0

; 66   : 	packet->len=0;

  0003c	83 66 0c 00	 and	 DWORD PTR [esi+12], 0
  00040	89 3e		 mov	 DWORD PTR [esi], edi

; 67   : 	return packet;

  00042	8b c6		 mov	 eax, esi
$L83205:
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 68   : }

  00046	c3		 ret	 0
_TlenP2PPacketCreate ENDP
_TEXT	ENDS
PUBLIC	_TlenP2PPacketFree
;	COMDAT _TlenP2PPacketFree
_TEXT	SEGMENT
_packet$ = 8
_TlenP2PPacketFree PROC NEAR				; COMDAT

; 71   : {

  00000	56		 push	 esi

; 72   : 	if (packet != NULL) {

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _packet$[esp]
  00005	85 f6		 test	 esi, esi
  00007	74 17		 je	 SHORT $L83222

; 73   : 		if (packet->packet != NULL)

  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	85 c0		 test	 eax, eax
  0000e	74 08		 je	 SHORT $L83224

; 74   : 			mir_free(packet->packet);

  00010	50		 push	 eax
  00011	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00017	59		 pop	 ecx
$L83224:

; 75   : 		mir_free(packet);

  00018	56		 push	 esi
  00019	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  0001f	59		 pop	 ecx
$L83222:
  00020	5e		 pop	 esi

; 76   : 	}
; 77   : }

  00021	c3		 ret	 0
_TlenP2PPacketFree ENDP
_TEXT	ENDS
PUBLIC	_TlenP2PPacketSetType
;	COMDAT _TlenP2PPacketSetType
_TEXT	SEGMENT
_packet$ = 8
_type$ = 12
_TlenP2PPacketSetType PROC NEAR				; COMDAT

; 81   : 	if (packet!=NULL) {

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _packet$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 07		 je	 SHORT $L83231

; 82   : 		packet->type = type;

  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR _type$[esp-4]
  0000c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L83231:

; 83   : 	}
; 84   : }

  0000f	c3		 ret	 0
_TlenP2PPacketSetType ENDP
_TEXT	ENDS
PUBLIC	_TlenP2PPacketSetLen
;	COMDAT _TlenP2PPacketSetLen
_TEXT	SEGMENT
_packet$ = 8
_len$ = 12
_TlenP2PPacketSetLen PROC NEAR				; COMDAT

; 88   : 	if (packet!=NULL) {

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _packet$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 07		 je	 SHORT $L83238

; 89   : 		packet->len = len;

  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR _len$[esp-4]
  0000c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$L83238:

; 90   : 	}
; 91   : }

  0000f	c3		 ret	 0
_TlenP2PPacketSetLen ENDP
_TEXT	ENDS
PUBLIC	_TlenP2PPacketPackDword
;	COMDAT _TlenP2PPacketPackDword
_TEXT	SEGMENT
_packet$ = 8
_data$ = 12
_TlenP2PPacketPackDword PROC NEAR			; COMDAT

; 95   : 	if (packet!=NULL && packet->packet!=NULL) {

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _packet$[esp-4]
  00004	56		 push	 esi
  00005	85 c0		 test	 eax, eax
  00007	74 1c		 je	 SHORT $L83248
  00009	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0000c	85 d2		 test	 edx, edx
  0000e	74 15		 je	 SHORT $L83248

; 96   : 		if (packet->len + sizeof(DWORD) <= packet->maxDataLen) {

  00010	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00013	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00016	3b 30		 cmp	 esi, DWORD PTR [eax]
  00018	77 0b		 ja	 SHORT $L83248

; 97   : 			(*((DWORD*)((packet->packet)+(packet->len)))) = data;

  0001a	8b 74 24 0c	 mov	 esi, DWORD PTR _data$[esp]
  0001e	89 34 11	 mov	 DWORD PTR [ecx+edx], esi

; 98   : 			packet->len += sizeof(DWORD);

  00021	83 40 0c 04	 add	 DWORD PTR [eax+12], 4
$L83248:
  00025	5e		 pop	 esi

; 99   : 		}
; 100  : 	}
; 101  : }

  00026	c3		 ret	 0
_TlenP2PPacketPackDword ENDP
_TEXT	ENDS
PUBLIC	_TlenP2PPacketPackBuffer
EXTRN	_memcpy:NEAR
;	COMDAT _TlenP2PPacketPackBuffer
_TEXT	SEGMENT
_packet$ = 8
_buffer$ = 12
_len$ = 16
_TlenP2PPacketPackBuffer PROC NEAR			; COMDAT

; 104  : {

  00000	56		 push	 esi

; 105  : 	if (packet!=NULL && packet->packet!=NULL) {

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _packet$[esp]
  00005	85 f6		 test	 esi, esi
  00007	57		 push	 edi
  00008	74 28		 je	 SHORT $L83261
  0000a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 21		 je	 SHORT $L83261

; 106  : 		if (packet->len + len <= packet->maxDataLen) {

  00011	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00014	8b 7c 24 14	 mov	 edi, DWORD PTR _len$[esp+4]
  00018	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]
  0001b	3b 16		 cmp	 edx, DWORD PTR [esi]
  0001d	77 13		 ja	 SHORT $L83261

; 107  : 			memcpy((packet->packet)+(packet->len), buffer, len);

  0001f	57		 push	 edi
  00020	03 c1		 add	 eax, ecx
  00022	ff 74 24 14	 push	 DWORD PTR _buffer$[esp+8]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _memcpy
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 108  : 			packet->len += len;

  0002f	01 7e 0c	 add	 DWORD PTR [esi+12], edi
$L83261:
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi

; 109  : 		}
; 110  : 	}
; 111  : }

  00034	c3		 ret	 0
_TlenP2PPacketPackBuffer ENDP
_TEXT	ENDS
PUBLIC	_TlenP2PInit
;	COMDAT _TlenP2PInit
_TEXT	SEGMENT
_TlenP2PInit PROC NEAR					; COMDAT

; 114  : }

  00000	c3		 ret	 0
_TlenP2PInit ENDP
_TEXT	ENDS
PUBLIC	_TlenP2PUninit
;	COMDAT _TlenP2PUninit
_TEXT	SEGMENT
_TlenP2PUninit PROC NEAR				; COMDAT

; 117  : }

  00000	c3		 ret	 0
_TlenP2PUninit ENDP
_TEXT	ENDS
PUBLIC	_TlenP2PPacketSend
PUBLIC	??_C@_0M@EFDJ@Netlib?1Send?$AA@			; `string'
EXTRN	_pluginLink:DWORD
;	COMDAT ??_C@_0M@EFDJ@Netlib?1Send?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_netlib.h
_DATA	SEGMENT
??_C@_0M@EFDJ@Netlib?1Send?$AA@ DB 'Netlib/Send', 00H	; `string'
_DATA	ENDS
;	COMDAT _TlenP2PPacketSend
_TEXT	SEGMENT
_s$ = 8
_packet$ = 12
_nlb$83688 = -12
_nlb$83692 = -12
_nlb$83696 = -12
_TlenP2PPacketSend PROC NEAR				; COMDAT

; 120  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	57		 push	 edi

; 121  : 	DWORD sendResult;
; 122  : 	if (packet!=NULL && packet->packet!=NULL) {

  00008	8b 7d 0c	 mov	 edi, DWORD PTR _packet$[ebp]
  0000b	85 ff		 test	 edi, edi
  0000d	0f 84 8b 00 00
	00		 je	 $L83277
  00013	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00017	0f 84 81 00 00
	00		 je	 $L83277

; 123  : 		Netlib_Send(s, (char *)&packet->type, 4, MSG_NODUMP);

  0001d	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00020	56		 push	 esi
  00021	89 45 f4	 mov	 DWORD PTR _nlb$83688[ebp], eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR _nlb$83688[ebp]
  00027	50		 push	 eax
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0002d	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00030	be 00 00 00 00	 mov	 esi, OFFSET FLAT:??_C@_0M@EFDJ@Netlib?1Send?$AA@ ; `string'
  00035	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _nlb$83688[ebp+4], 4
  0003c	c7 45 fc 00 00
	02 00		 mov	 DWORD PTR _nlb$83688[ebp+8], 131072 ; 00020000H
  00043	56		 push	 esi
  00044	ff 50 24	 call	 DWORD PTR [eax+36]

; 124  : 		Netlib_Send(s, (char *)&packet->len, 4, MSG_NODUMP);

  00047	8d 45 f4	 lea	 eax, DWORD PTR _nlb$83692[ebp]
  0004a	8d 5f 0c	 lea	 ebx, DWORD PTR [edi+12]
  0004d	50		 push	 eax
  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00053	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00056	89 5d f4	 mov	 DWORD PTR _nlb$83692[ebp], ebx
  00059	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _nlb$83692[ebp+4], 4
  00060	c7 45 fc 00 00
	02 00		 mov	 DWORD PTR _nlb$83692[ebp+8], 131072 ; 00020000H
  00067	56		 push	 esi
  00068	ff 50 24	 call	 DWORD PTR [eax+36]

; 125  : 		sendResult=Netlib_Send(s, packet->packet, packet->len, MSG_NODUMP);

  0006b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0006e	c7 45 fc 00 00
	02 00		 mov	 DWORD PTR _nlb$83696[ebp+8], 131072 ; 00020000H
  00075	89 45 f4	 mov	 DWORD PTR _nlb$83696[ebp], eax
  00078	8b 03		 mov	 eax, DWORD PTR [ebx]
  0007a	89 45 f8	 mov	 DWORD PTR _nlb$83696[ebp+4], eax
  0007d	8d 45 f4	 lea	 eax, DWORD PTR _nlb$83696[ebp]
  00080	50		 push	 eax
  00081	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00086	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00089	56		 push	 esi
  0008a	ff 50 24	 call	 DWORD PTR [eax+36]
  0008d	83 c4 24	 add	 esp, 36			; 00000024H

; 126  : 		if (sendResult==SOCKET_ERROR || sendResult!=packet->len) return 0;

  00090	83 f8 ff	 cmp	 eax, -1
  00093	5e		 pop	 esi
  00094	74 04		 je	 SHORT $L83278
  00096	3b 03		 cmp	 eax, DWORD PTR [ebx]
  00098	74 04		 je	 SHORT $L83277
$L83278:
  0009a	33 c0		 xor	 eax, eax
  0009c	eb 03		 jmp	 SHORT $L83270
$L83277:

; 127  : 	}
; 128  : 	return 1;

  0009e	6a 01		 push	 1
  000a0	58		 pop	 eax
$L83270:
  000a1	5f		 pop	 edi
  000a2	5b		 pop	 ebx

; 129  : }

  000a3	c9		 leave
  000a4	c3		 ret	 0
_TlenP2PPacketSend ENDP
_TEXT	ENDS
PUBLIC	_TlenP2PPacketReceive
PUBLIC	??_C@_0M@GFGB@Netlib?1Recv?$AA@			; `string'
;	COMDAT ??_C@_0M@GFGB@Netlib?1Recv?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_netlib.h
_DATA	SEGMENT
??_C@_0M@GFGB@Netlib?1Recv?$AA@ DB 'Netlib/Recv', 00H	; `string'
_DATA	ENDS
;	COMDAT _TlenP2PPacketReceive
_TEXT	SEGMENT
_s$ = 8
_type$ = -12
_len$ = -4
_pos$ = -8
_nlb$83704 = -24
_nlb$83709 = -24
_nlb$83714 = -24
_TlenP2PPacketReceive PROC NEAR				; COMDAT

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 133  : 	TLEN_FILE_PACKET *packet;
; 134  : 	DWORD recvResult;
; 135  : 	DWORD type, len, pos;
; 136  : 	recvResult = Netlib_Recv(s, (char *)&type, 4, MSG_NODUMP);

  00009	8d 45 f4	 lea	 eax, DWORD PTR _type$[ebp]
  0000c	6a 04		 push	 4
  0000e	89 45 e8	 mov	 DWORD PTR _nlb$83704[ebp], eax
  00011	5b		 pop	 ebx
  00012	8d 45 e8	 lea	 eax, DWORD PTR _nlb$83704[ebp]
  00015	50		 push	 eax
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0001b	ff 75 08	 push	 DWORD PTR _s$[ebp]
  0001e	be 00 00 00 00	 mov	 esi, OFFSET FLAT:??_C@_0M@GFGB@Netlib?1Recv?$AA@ ; `string'
  00023	bf 00 00 02 00	 mov	 edi, 131072		; 00020000H
  00028	89 5d ec	 mov	 DWORD PTR _nlb$83704[ebp+4], ebx
  0002b	56		 push	 esi
  0002c	89 7d f0	 mov	 DWORD PTR _nlb$83704[ebp+8], edi
  0002f	ff 50 24	 call	 DWORD PTR [eax+36]
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 137  : 	if (recvResult==0 || recvResult==SOCKET_ERROR) return NULL;

  00035	85 c0		 test	 eax, eax
  00037	0f 84 97 00 00
	00		 je	 $L83293
  0003d	83 f8 ff	 cmp	 eax, -1
  00040	0f 84 8e 00 00
	00		 je	 $L83293

; 138  : 	recvResult = Netlib_Recv(s, (char *)&len, 4, MSG_NODUMP);

  00046	8d 45 fc	 lea	 eax, DWORD PTR _len$[ebp]
  00049	89 5d ec	 mov	 DWORD PTR _nlb$83709[ebp+4], ebx
  0004c	89 45 e8	 mov	 DWORD PTR _nlb$83709[ebp], eax
  0004f	8d 45 e8	 lea	 eax, DWORD PTR _nlb$83709[ebp]
  00052	50		 push	 eax
  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00058	ff 75 08	 push	 DWORD PTR _s$[ebp]
  0005b	89 7d f0	 mov	 DWORD PTR _nlb$83709[ebp+8], edi
  0005e	56		 push	 esi
  0005f	ff 50 24	 call	 DWORD PTR [eax+36]
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH

; 139  : 	if (recvResult==0 || recvResult==SOCKET_ERROR) return NULL;

  00065	85 c0		 test	 eax, eax
  00067	74 6b		 je	 SHORT $L83293
  00069	83 f8 ff	 cmp	 eax, -1
  0006c	74 66		 je	 SHORT $L83293

; 140  : 	packet = TlenP2PPacketCreate(len);

  0006e	ff 75 fc	 push	 DWORD PTR _len$[ebp]
  00071	e8 00 00 00 00	 call	 _TlenP2PPacketCreate

; 141  : 	TlenP2PPacketSetType(packet, type);

  00076	ff 75 f4	 push	 DWORD PTR _type$[ebp]
  00079	8b d8		 mov	 ebx, eax
  0007b	53		 push	 ebx
  0007c	e8 00 00 00 00	 call	 _TlenP2PPacketSetType

; 142  : 	TlenP2PPacketSetLen(packet, len);

  00081	ff 75 fc	 push	 DWORD PTR _len$[ebp]
  00084	53		 push	 ebx
  00085	e8 00 00 00 00	 call	 _TlenP2PPacketSetLen
  0008a	83 c4 14	 add	 esp, 20			; 00000014H

; 143  : 	pos = 0;

  0008d	83 65 f8 00	 and	 DWORD PTR _pos$[ebp], 0
$L83723:

; 144  : 	while (len > 0) {

  00091	83 7d fc 00	 cmp	 DWORD PTR _len$[ebp], 0
  00095	76 44		 jbe	 SHORT $L83297

; 145  : 		recvResult = Netlib_Recv(s, packet->packet+pos, len, MSG_NODUMP);

  00097	8b 45 f8	 mov	 eax, DWORD PTR _pos$[ebp]
  0009a	89 7d f0	 mov	 DWORD PTR _nlb$83714[ebp+8], edi
  0009d	03 43 04	 add	 eax, DWORD PTR [ebx+4]
  000a0	89 45 e8	 mov	 DWORD PTR _nlb$83714[ebp], eax
  000a3	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  000a6	89 45 ec	 mov	 DWORD PTR _nlb$83714[ebp+4], eax
  000a9	8d 45 e8	 lea	 eax, DWORD PTR _nlb$83714[ebp]
  000ac	50		 push	 eax
  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  000b2	ff 75 08	 push	 DWORD PTR _s$[ebp]
  000b5	56		 push	 esi
  000b6	ff 50 24	 call	 DWORD PTR [eax+36]
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 146  : 		if (recvResult==0 || recvResult==SOCKET_ERROR) {

  000bc	85 c0		 test	 eax, eax
  000be	74 0d		 je	 SHORT $L83720
  000c0	83 f8 ff	 cmp	 eax, -1
  000c3	74 08		 je	 SHORT $L83720

; 148  : 			return NULL;
; 149  : 		}
; 150  : 		len -= recvResult;

  000c5	29 45 fc	 sub	 DWORD PTR _len$[ebp], eax

; 151  : 		pos += recvResult;

  000c8	01 45 f8	 add	 DWORD PTR _pos$[ebp], eax
  000cb	eb c4		 jmp	 SHORT $L83723
$L83720:

; 147  : 			TlenP2PPacketFree(packet);

  000cd	53		 push	 ebx
  000ce	e8 00 00 00 00	 call	 _TlenP2PPacketFree
  000d3	59		 pop	 ecx
$L83293:

; 137  : 	if (recvResult==0 || recvResult==SOCKET_ERROR) return NULL;

  000d4	33 c0		 xor	 eax, eax
$L83281:
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx

; 154  : }

  000d9	c9		 leave
  000da	c3		 ret	 0
$L83297:

; 152  : 	}
; 153  : 	return packet;

  000db	8b c3		 mov	 eax, ebx
  000dd	eb f7		 jmp	 SHORT $L83281
_TlenP2PPacketReceive ENDP
_TEXT	ENDS
PUBLIC	_TlenP2PEstablishOutgoingConnection
PUBLIC	??_C@_0CC@KCOG@Establishing?5outgoing?5connection@ ; `string'
PUBLIC	??_C@_08NBNM@?$CF08X?$CFs?$CFd?$AA@		; `string'
PUBLIC	??_C@_0BD@IFFL@Proto?1BroadcastAck?$AA@		; `string'
EXTRN	__imp__atoi:NEAR
EXTRN	_strlen:NEAR
EXTRN	__imp___snprintf:NEAR
EXTRN	_JabberLog:NEAR
EXTRN	_TlenSha1:NEAR
;	COMDAT ??_C@_0BD@IFFL@Proto?1BroadcastAck?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_protomod.h
_DATA	SEGMENT
??_C@_0BD@IFFL@Proto?1BroadcastAck?$AA@ DB 'Proto/BroadcastAck', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CC@KCOG@Establishing?5outgoing?5connection@
_DATA	SEGMENT
??_C@_0CC@KCOG@Establishing?5outgoing?5connection@ DB 'Establishing outgo'
	DB	'ing connection.', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08NBNM@?$CF08X?$CFs?$CFd?$AA@
_DATA	SEGMENT
??_C@_08NBNM@?$CF08X?$CFs?$CFd?$AA@ DB '%08X%s%d', 00H	; `string'
_DATA	ENDS
;	COMDAT _TlenP2PEstablishOutgoingConnection
_TEXT	SEGMENT
_ft$ = 8
_sendAck$ = 12
_hash$ = -4
_str$ = -332
_proto$ = 8
_ack$83728 = -32
_TlenP2PEstablishOutgoingConnection PROC NEAR		; COMDAT

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 158  : 	char *hash;
; 159  : 	char str[300];
; 160  : 	TLEN_FILE_PACKET *packet;
; 161  : 	TlenProtocol *proto = ft->proto;

  0000b	8b 75 08	 mov	 esi, DWORD PTR _ft$[ebp]
  0000e	57		 push	 edi

; 162  : 
; 163  : 	JabberLog(proto, "Establishing outgoing connection.");

  0000f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CC@KCOG@Establishing?5outgoing?5connection@ ; `string'
  00014	8b 86 7c 02 00
	00		 mov	 eax, DWORD PTR [esi+636]
  0001a	50		 push	 eax
  0001b	89 45 08	 mov	 DWORD PTR _proto$[ebp], eax
  0001e	e8 00 00 00 00	 call	 _JabberLog

; 164  : 	ft->state = FT_ERROR;
; 165  : 	if ((packet = TlenP2PPacketCreate(2*sizeof(DWORD) + 20))!=NULL) {

  00023	6a 1c		 push	 28			; 0000001cH
  00025	c7 46 0c 04 00
	00 00		 mov	 DWORD PTR [esi+12], 4
  0002c	e8 00 00 00 00	 call	 _TlenP2PPacketCreate
  00031	8b d8		 mov	 ebx, eax
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	85 db		 test	 ebx, ebx
  00038	0f 84 11 01 00
	00		 je	 $L83317

; 166  : 		TlenP2PPacketSetType(packet, TLEN_FILE_PACKET_CONNECTION_REQUEST);

  0003e	6a 01		 push	 1
  00040	53		 push	 ebx
  00041	e8 00 00 00 00	 call	 _TlenP2PPacketSetType

; 167  : 		TlenP2PPacketPackDword(packet, 1);

  00046	6a 01		 push	 1
  00048	53		 push	 ebx
  00049	e8 00 00 00 00	 call	 _TlenP2PPacketPackDword

; 168  : 		TlenP2PPacketPackDword(packet, (DWORD) atoi(ft->iqId));

  0004e	ff 76 18	 push	 DWORD PTR [esi+24]
  00051	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__atoi
  00057	ff d7		 call	 edi
  00059	50		 push	 eax
  0005a	53		 push	 ebx
  0005b	e8 00 00 00 00	 call	 _TlenP2PPacketPackDword

; 169  : 		_snprintf(str, sizeof(str), "%08X%s%d", atoi(ft->iqId), proto->threadData->username, atoi(ft->iqId));

  00060	ff 76 18	 push	 DWORD PTR [esi+24]
  00063	ff d7		 call	 edi
  00065	83 c4 20	 add	 esp, 32			; 00000020H
  00068	50		 push	 eax
  00069	8b 45 08	 mov	 eax, DWORD PTR _proto$[ebp]
  0006c	8b 80 e0 00 00
	00		 mov	 eax, DWORD PTR [eax+224]
  00072	83 c0 08	 add	 eax, 8
  00075	50		 push	 eax
  00076	ff 76 18	 push	 DWORD PTR [esi+24]
  00079	ff d7		 call	 edi
  0007b	59		 pop	 ecx
  0007c	50		 push	 eax
  0007d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08NBNM@?$CF08X?$CFs?$CFd?$AA@ ; `string'
  00082	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00088	68 2c 01 00 00	 push	 300			; 0000012cH
  0008d	50		 push	 eax
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf

; 170  : 		hash = TlenSha1(str, strlen(str));

  00094	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _strlen
  000a0	50		 push	 eax
  000a1	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _TlenSha1

; 171  : 		TlenP2PPacketPackBuffer(packet, hash, 20);

  000ad	6a 14		 push	 20			; 00000014H
  000af	50		 push	 eax
  000b0	53		 push	 ebx
  000b1	89 45 fc	 mov	 DWORD PTR _hash$[ebp], eax
  000b4	e8 00 00 00 00	 call	 _TlenP2PPacketPackBuffer

; 172  : 		mir_free(hash);

  000b9	ff 75 fc	 push	 DWORD PTR _hash$[ebp]
  000bc	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12

; 173  : 		TlenP2PPacketSend(ft->s, packet);

  000c2	53		 push	 ebx
  000c3	ff 76 04	 push	 DWORD PTR [esi+4]
  000c6	e8 00 00 00 00	 call	 _TlenP2PPacketSend

; 174  : 		TlenP2PPacketFree(packet);

  000cb	53		 push	 ebx
  000cc	e8 00 00 00 00	 call	 _TlenP2PPacketFree
  000d1	83 c4 40	 add	 esp, 64			; 00000040H

; 175  : 		packet = TlenP2PPacketReceive(ft->s);

  000d4	ff 76 04	 push	 DWORD PTR [esi+4]
  000d7	e8 00 00 00 00	 call	 _TlenP2PPacketReceive
  000dc	8b d8		 mov	 ebx, eax
  000de	59		 pop	 ecx

; 176  : 		if (packet != NULL) {

  000df	85 db		 test	 ebx, ebx
  000e1	74 6c		 je	 SHORT $L83317

; 177  : 			if (packet->type == TLEN_FILE_PACKET_CONNECTION_REQUEST_ACK) { // acknowledge

  000e3	83 7b 08 02	 cmp	 DWORD PTR [ebx+8], 2
  000e7	75 5f		 jne	 SHORT $L83727

; 178  : 				if ((int)(*((DWORD*)packet->packet)) == atoi(ft->iqId)) {

  000e9	ff 76 18	 push	 DWORD PTR [esi+24]
  000ec	ff d7		 call	 edi
  000ee	59		 pop	 ecx
  000ef	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000f2	39 01		 cmp	 DWORD PTR [ecx], eax
  000f4	75 52		 jne	 SHORT $L83727

; 179  : 					ft->state = FT_CONNECTING;

  000f6	33 d2		 xor	 edx, edx

; 180  : 					if (sendAck) {

  000f8	39 55 0c	 cmp	 DWORD PTR _sendAck$[ebp], edx
  000fb	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  000fe	74 48		 je	 SHORT $L83727

; 181  : 						ProtoBroadcastAck(proto->iface.m_szModuleName, ft->hContact, ACKTYPE_FILE, ACKRESULT_CONNECTED, ft, 0);

  00100	6a 06		 push	 6
  00102	33 c0		 xor	 eax, eax
  00104	59		 pop	 ecx
  00105	8d 7d e4	 lea	 edi, DWORD PTR _ack$83728[ebp+4]
  00108	f3 ab		 rep stosd
  0010a	8b 45 08	 mov	 eax, DWORD PTR _proto$[ebp]
  0010d	c7 45 e0 1c 00
	00 00		 mov	 DWORD PTR _ack$83728[ebp], 28 ; 0000001cH
  00114	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _ack$83728[ebp+12], 2
  0011b	c7 45 f0 65 00
	00 00		 mov	 DWORD PTR _ack$83728[ebp+16], 101 ; 00000065H
  00122	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00125	89 75 f4	 mov	 DWORD PTR _ack$83728[ebp+20], esi
  00128	89 45 e4	 mov	 DWORD PTR _ack$83728[ebp+4], eax
  0012b	8b 06		 mov	 eax, DWORD PTR [esi]
  0012d	89 45 e8	 mov	 DWORD PTR _ack$83728[ebp+8], eax
  00130	8d 45 e0	 lea	 eax, DWORD PTR _ack$83728[ebp]
  00133	50		 push	 eax
  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00139	52		 push	 edx
  0013a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@IFFL@Proto?1BroadcastAck?$AA@ ; `string'
  0013f	89 55 f8	 mov	 DWORD PTR _ack$83728[ebp+24], edx
  00142	ff 50 24	 call	 DWORD PTR [eax+36]
  00145	83 c4 0c	 add	 esp, 12			; 0000000cH
$L83727:

; 182  : 					}
; 183  : 				}
; 184  : 			}
; 185  : 			TlenP2PPacketFree(packet);

  00148	53		 push	 ebx
  00149	e8 00 00 00 00	 call	 _TlenP2PPacketFree
  0014e	59		 pop	 ecx
$L83317:
  0014f	5f		 pop	 edi
  00150	5e		 pop	 esi
  00151	5b		 pop	 ebx

; 186  : 		}
; 187  : 	}
; 188  : }

  00152	c9		 leave
  00153	c3		 ret	 0
_TlenP2PEstablishOutgoingConnection ENDP
_TEXT	ENDS
PUBLIC	_TlenP2PEstablishIncomingConnection
PUBLIC	??_C@_02MECO@?$CFd?$AA@				; `string'
EXTRN	_JabberListFindNext:NEAR
EXTRN	_JabberListGetItemPtrFromIndex:NEAR
EXTRN	_strcmp:NEAR
EXTRN	_JabberNickFromJID:NEAR
;	COMDAT ??_C@_02MECO@?$CFd?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_protomod.h
_DATA	SEGMENT
??_C@_02MECO@?$CFd?$AA@ DB '%d', 00H			; `string'
_DATA	ENDS
;	COMDAT _TlenP2PEstablishIncomingConnection
_TEXT	SEGMENT
_proto$ = 8
_s$ = 12
_list$ = 16
_sendAck$ = 20
_i$ = -8
_str$ = -344
_iqId$ = -16
_hash$83353 = -12
_nick$83354 = -12
_j$83355 = -4
_ack$83735 = -44
_TlenP2PEstablishIncomingConnection PROC NEAR		; COMDAT

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 58 01 00
	00		 sub	 esp, 344		; 00000158H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 192  : 	JABBER_LIST_ITEM *item = NULL;

  0000c	33 db		 xor	 ebx, ebx

; 193  : 	TLEN_FILE_PACKET *packet;
; 194  : 	int i;
; 195  : 	char str[300];
; 196  : 	DWORD iqId;
; 197  : 	// TYPE: 0x1
; 198  : 	// LEN:
; 199  : 	// (DWORD) 0x1
; 200  : 	// (DWORD) id
; 201  : 	// (BYTE) hash[20]
; 202  : 	packet = TlenP2PPacketReceive(s);

  0000e	ff 75 0c	 push	 DWORD PTR _s$[ebp]
  00011	33 f6		 xor	 esi, esi
  00013	e8 00 00 00 00	 call	 _TlenP2PPacketReceive
  00018	8b f8		 mov	 edi, eax
  0001a	59		 pop	 ecx

; 203  : 	if (packet == NULL || packet->type != TLEN_FILE_PACKET_CONNECTION_REQUEST || packet->len<28) {

  0001b	3b fb		 cmp	 edi, ebx
  0001d	0f 84 dc 01 00
	00		 je	 $L83365
  00023	83 7f 08 01	 cmp	 DWORD PTR [edi+8], 1
  00027	0f 85 cb 01 00
	00		 jne	 $L83340
  0002d	83 7f 0c 1c	 cmp	 DWORD PTR [edi+12], 28	; 0000001cH
  00031	0f 82 c1 01 00
	00		 jb	 $L83340

; 208  : 	}
; 209  : 	iqId = *((DWORD *)(packet->packet+sizeof(DWORD)));

  00037	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 210  : 	i = 0;
; 211  : 	while ((i=JabberListFindNext(proto, list, i)) >= 0) {

  0003a	53		 push	 ebx
  0003b	ff 75 10	 push	 DWORD PTR _list$[ebp]
  0003e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00041	ff 75 08	 push	 DWORD PTR _proto$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR _iqId$[ebp], eax
  00047	e8 00 00 00 00	 call	 _JabberListFindNext
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b c3		 cmp	 eax, ebx
  00051	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00054	0f 8c f1 00 00
	00		 jl	 $L83742
  0005a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp___snprintf
$L83347:

; 212  : 		if ((item=JabberListGetItemPtrFromIndex(proto, i))!=NULL) {

  00060	ff 75 f8	 push	 DWORD PTR _i$[ebp]
  00063	ff 75 08	 push	 DWORD PTR _proto$[ebp]
  00066	e8 00 00 00 00	 call	 _JabberListGetItemPtrFromIndex
  0006b	8b f0		 mov	 esi, eax
  0006d	59		 pop	 ecx
  0006e	85 f6		 test	 esi, esi
  00070	59		 pop	 ecx
  00071	0f 84 b4 00 00
	00		 je	 $L83361

; 213  : 			_snprintf(str, sizeof(str), "%d", iqId);

  00077	ff 75 f0	 push	 DWORD PTR _iqId$[ebp]
  0007a	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00080	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@ ; `string'
  00085	68 2c 01 00 00	 push	 300			; 0000012cH
  0008a	50		 push	 eax
  0008b	ff d3		 call	 ebx

; 214  : 			if (!strcmp(item->ft->iqId, str)) {

  0008d	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  00093	50		 push	 eax
  00094	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  00097	ff 70 18	 push	 DWORD PTR [eax+24]
  0009a	e8 00 00 00 00	 call	 _strcmp
  0009f	83 c4 18	 add	 esp, 24			; 00000018H
  000a2	85 c0		 test	 eax, eax
  000a4	0f 85 81 00 00
	00		 jne	 $L83361

; 215  : 				char *hash, *nick;
; 216  : 				int j;
; 217  : 				nick = JabberNickFromJID(item->ft->jid);

  000aa	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  000ad	ff 70 10	 push	 DWORD PTR [eax+16]
  000b0	e8 00 00 00 00	 call	 _JabberNickFromJID

; 218  : 				_snprintf(str, sizeof(str), "%08X%s%d", iqId, nick, iqId);

  000b5	ff 75 f0	 push	 DWORD PTR _iqId$[ebp]
  000b8	89 45 f4	 mov	 DWORD PTR _nick$83354[ebp], eax
  000bb	50		 push	 eax
  000bc	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  000c2	ff 75 f0	 push	 DWORD PTR _iqId$[ebp]
  000c5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08NBNM@?$CF08X?$CFs?$CFd?$AA@ ; `string'
  000ca	68 2c 01 00 00	 push	 300			; 0000012cH
  000cf	50		 push	 eax
  000d0	ff d3		 call	 ebx

; 219  : 				mir_free(nick);

  000d2	ff 75 f4	 push	 DWORD PTR _nick$83354[ebp]
  000d5	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12

; 220  : 				hash = TlenSha1(str, strlen(str));

  000db	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 _strlen
  000e7	50		 push	 eax
  000e8	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _str$[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _TlenSha1
  000f4	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 221  : 				for (j=0;j<20;j++) {

  000f7	83 65 fc 00	 and	 DWORD PTR _j$83355[ebp], 0
  000fb	83 c4 2c	 add	 esp, 44			; 0000002cH
  000fe	89 45 f4	 mov	 DWORD PTR _hash$83353[ebp], eax
  00101	83 c1 08	 add	 ecx, 8
$L83356:

; 222  : 					if (hash[j]!=packet->packet[2*sizeof(DWORD)+j]) break;

  00104	8b 45 fc	 mov	 eax, DWORD PTR _j$83355[ebp]
  00107	8b 55 f4	 mov	 edx, DWORD PTR _hash$83353[ebp]
  0010a	8a 04 10	 mov	 al, BYTE PTR [eax+edx]
  0010d	3a 01		 cmp	 al, BYTE PTR [ecx]
  0010f	75 0a		 jne	 SHORT $L83741
  00111	ff 45 fc	 inc	 DWORD PTR _j$83355[ebp]
  00114	41		 inc	 ecx
  00115	83 7d fc 14	 cmp	 DWORD PTR _j$83355[ebp], 20 ; 00000014H
  00119	7c e9		 jl	 SHORT $L83356
$L83741:

; 223  : 				}
; 224  : 				mir_free(hash);

  0011b	ff 75 f4	 push	 DWORD PTR _hash$83353[ebp]
  0011e	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12

; 225  : 				if (j==20) break;

  00124	83 7d fc 14	 cmp	 DWORD PTR _j$83355[ebp], 20 ; 00000014H
  00128	59		 pop	 ecx
  00129	74 1e		 je	 SHORT $L83746
$L83361:

; 226  : 			}
; 227  : 		}
; 228  : 		i++;

  0012b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0012e	40		 inc	 eax
  0012f	50		 push	 eax
  00130	ff 75 10	 push	 DWORD PTR _list$[ebp]
  00133	ff 75 08	 push	 DWORD PTR _proto$[ebp]
  00136	e8 00 00 00 00	 call	 _JabberListFindNext
  0013b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013e	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00141	85 c0		 test	 eax, eax
  00143	0f 8d 17 ff ff
	ff		 jge	 $L83347
$L83746:

; 210  : 	i = 0;
; 211  : 	while ((i=JabberListFindNext(proto, list, i)) >= 0) {

  00149	33 db		 xor	 ebx, ebx
$L83742:

; 229  : 	}
; 230  : 	TlenP2PPacketFree(packet);

  0014b	57		 push	 edi
  0014c	e8 00 00 00 00	 call	 _TlenP2PPacketFree

; 231  : 	if (i >=0) {

  00151	39 5d f8	 cmp	 DWORD PTR _i$[ebp], ebx
  00154	59		 pop	 ecx
  00155	0f 8c a4 00 00
	00		 jl	 $L83365

; 232  : 		if ((packet=TlenP2PPacketCreate(sizeof(DWORD))) != NULL) {

  0015b	6a 04		 push	 4
  0015d	e8 00 00 00 00	 call	 _TlenP2PPacketCreate
  00162	8b f8		 mov	 edi, eax
  00164	59		 pop	 ecx
  00165	3b fb		 cmp	 edi, ebx
  00167	0f 84 92 00 00
	00		 je	 $L83365

; 233  : 			// Send connection establishment acknowledgement
; 234  : 			TlenP2PPacketSetType(packet, TLEN_FILE_PACKET_CONNECTION_REQUEST_ACK);

  0016d	6a 02		 push	 2
  0016f	57		 push	 edi
  00170	e8 00 00 00 00	 call	 _TlenP2PPacketSetType

; 235  : 			TlenP2PPacketPackDword(packet, (DWORD) atoi(item->ft->iqId));

  00175	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  00178	ff 70 18	 push	 DWORD PTR [eax+24]
  0017b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00181	50		 push	 eax
  00182	57		 push	 edi
  00183	e8 00 00 00 00	 call	 _TlenP2PPacketPackDword

; 236  : 			TlenP2PPacketSend(s, packet);

  00188	57		 push	 edi
  00189	ff 75 0c	 push	 DWORD PTR _s$[ebp]
  0018c	e8 00 00 00 00	 call	 _TlenP2PPacketSend

; 237  : 			TlenP2PPacketFree(packet);

  00191	57		 push	 edi
  00192	e8 00 00 00 00	 call	 _TlenP2PPacketFree

; 238  : 			item->ft->state = FT_CONNECTING;

  00197	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  0019a	83 c4 20	 add	 esp, 32			; 00000020H

; 239  : 			if (sendAck) {

  0019d	39 5d 14	 cmp	 DWORD PTR _sendAck$[ebp], ebx
  001a0	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
  001a3	74 4e		 je	 SHORT $L83734

; 240  : 				ProtoBroadcastAck(item->ft->proto->iface.m_szModuleName, item->ft->hContact, ACKTYPE_FILE, ACKRESULT_CONNECTED, item->ft, 0);

  001a5	6a 06		 push	 6
  001a7	33 c0		 xor	 eax, eax
  001a9	59		 pop	 ecx
  001aa	8d 7d d8	 lea	 edi, DWORD PTR _ack$83735[ebp+4]
  001ad	f3 ab		 rep stosd
  001af	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  001b2	c7 45 d4 1c 00
	00 00		 mov	 DWORD PTR _ack$83735[ebp], 28 ; 0000001cH
  001b9	89 45 e8	 mov	 DWORD PTR _ack$83735[ebp+20], eax
  001bc	c7 45 e0 02 00
	00 00		 mov	 DWORD PTR _ack$83735[ebp+12], 2
  001c3	8b 88 7c 02 00
	00		 mov	 ecx, DWORD PTR [eax+636]
  001c9	c7 45 e4 65 00
	00 00		 mov	 DWORD PTR _ack$83735[ebp+16], 101 ; 00000065H
  001d0	89 5d ec	 mov	 DWORD PTR _ack$83735[ebp+24], ebx
  001d3	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  001d6	89 4d d8	 mov	 DWORD PTR _ack$83735[ebp+4], ecx
  001d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  001db	8d 45 d4	 lea	 eax, DWORD PTR _ack$83735[ebp]
  001de	89 4d dc	 mov	 DWORD PTR _ack$83735[ebp+8], ecx
  001e1	50		 push	 eax
  001e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  001e7	53		 push	 ebx
  001e8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@IFFL@Proto?1BroadcastAck?$AA@ ; `string'
  001ed	ff 50 24	 call	 DWORD PTR [eax+36]
  001f0	83 c4 0c	 add	 esp, 12			; 0000000cH
$L83734:

; 241  : 			}
; 242  : 			return item->ft;

  001f3	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  001f6	eb 09		 jmp	 SHORT $L83331
$L83340:

; 204  : 		if (packet!=NULL) {
; 205  : 			TlenP2PPacketFree(packet);

  001f8	57		 push	 edi
  001f9	e8 00 00 00 00	 call	 _TlenP2PPacketFree
  001fe	59		 pop	 ecx
$L83365:

; 206  : 		}
; 207  : 		return NULL;

  001ff	33 c0		 xor	 eax, eax
$L83331:
  00201	5f		 pop	 edi
  00202	5e		 pop	 esi
  00203	5b		 pop	 ebx

; 243  : 		}
; 244  : 	}
; 245  : 	return NULL;
; 246  : }

  00204	c9		 leave
  00205	c3		 ret	 0
_TlenP2PEstablishIncomingConnection ENDP
_TEXT	ENDS
PUBLIC	_TlenP2PListen
PUBLIC	??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@	; `string'
PUBLIC	??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@	; `string'
PUBLIC	??_C@_0N@BODO@UseFileProxy?$AA@			; `string'
PUBLIC	??_C@_0O@GFGJ@FileProxyHost?$AA@		; `string'
PUBLIC	??_C@_0O@MHC@FileProxyPort?$AA@			; `string'
PUBLIC	??_C@_00A@?$AA@					; `string'
PUBLIC	??_C@_0O@EJJI@FileProxyAuth?$AA@		; `string'
PUBLIC	??_C@_0BC@CBEM@FileProxyUsername?$AA@		; `string'
PUBLIC	??_C@_0BC@EIFA@FileProxyPassword?$AA@		; `string'
PUBLIC	??_C@_0BG@PHIF@DB?1Crypt?1DecodeString?$AA@	; `string'
PUBLIC	??_C@_0O@HKJF@FileProxyType?$AA@		; `string'
PUBLIC	??_C@_0BL@FHBN@Calling?5MS_NETLIB_BINDPORT?$AA@	; `string'
PUBLIC	??_C@_0BA@GLLO@Netlib?1BindPort?$AA@		; `string'
PUBLIC	??_C@_0BA@JJCP@listening?5on?5?$CFd?$AA@	; `string'
EXTRN	_strcpy:NEAR
EXTRN	_htonl@4:NEAR
EXTRN	_inet_ntoa@4:NEAR
;	COMDAT ??_C@_00A@?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_database.h
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@
_DATA	SEGMENT
??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@ DB 'DB/Contact/GetSetting', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@
_DATA	SEGMENT
??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@ DB 'DB/Contact/FreeVariant', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@BODO@UseFileProxy?$AA@
_DATA	SEGMENT
??_C@_0N@BODO@UseFileProxy?$AA@ DB 'UseFileProxy', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@GFGJ@FileProxyHost?$AA@
_DATA	SEGMENT
??_C@_0O@GFGJ@FileProxyHost?$AA@ DB 'FileProxyHost', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@MHC@FileProxyPort?$AA@
_DATA	SEGMENT
??_C@_0O@MHC@FileProxyPort?$AA@ DB 'FileProxyPort', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@EJJI@FileProxyAuth?$AA@
_DATA	SEGMENT
??_C@_0O@EJJI@FileProxyAuth?$AA@ DB 'FileProxyAuth', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@CBEM@FileProxyUsername?$AA@
_DATA	SEGMENT
??_C@_0BC@CBEM@FileProxyUsername?$AA@ DB 'FileProxyUsername', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@EIFA@FileProxyPassword?$AA@
_DATA	SEGMENT
??_C@_0BC@EIFA@FileProxyPassword?$AA@ DB 'FileProxyPassword', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@PHIF@DB?1Crypt?1DecodeString?$AA@
_DATA	SEGMENT
??_C@_0BG@PHIF@DB?1Crypt?1DecodeString?$AA@ DB 'DB/Crypt/DecodeString', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@HKJF@FileProxyType?$AA@
_DATA	SEGMENT
??_C@_0O@HKJF@FileProxyType?$AA@ DB 'FileProxyType', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@FHBN@Calling?5MS_NETLIB_BINDPORT?$AA@
_DATA	SEGMENT
??_C@_0BL@FHBN@Calling?5MS_NETLIB_BINDPORT?$AA@ DB 'Calling MS_NETLIB_BIN'
	DB	'DPORT', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@GLLO@Netlib?1BindPort?$AA@
_DATA	SEGMENT
??_C@_0BA@GLLO@Netlib?1BindPort?$AA@ DB 'Netlib/BindPort', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JJCP@listening?5on?5?$CFd?$AA@
_DATA	SEGMENT
??_C@_0BA@JJCP@listening?5on?5?$CFd?$AA@ DB 'listening on %d', 00H ; `string'
_DATA	ENDS
;	COMDAT _TlenP2PListen
_TEXT	SEGMENT
_ft$ = 8
_nlb$ = -72
_s$ = -16
_useProxy$ = 8
_dbv$ = -28
_sb$ = -848
_dbv$83750 = -40
_cgs$83751 = -12
_cgs$83760 = -12
_dbv$83769 = -40
_cgs$83770 = -12
_dbv$83778 = -40
_cgs$83779 = -12
_cgs$83788 = -12
_cgs$83798 = -12
_dbv$83807 = -40
_cgs$83808 = -12
_TlenP2PListen PROC NEAR				; COMDAT

; 459  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 03 00
	00		 sub	 esp, 848		; 00000350H
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 460  : 	NETLIBBIND nlb = {0};
; 461  : 	JABBER_SOCKET s = NULL;
; 462  : 	int	  useProxy;
; 463  : 	DBVARIANT dbv;
; 464  : 	SOCKSBIND sb;
; 465  : 	struct in_addr in;
; 466  : 	TlenProtocol *proto = ft->proto;

  0000b	8b 75 08	 mov	 esi, DWORD PTR _ft$[ebp]
  0000e	57		 push	 edi
  0000f	6a 06		 push	 6
  00011	33 d2		 xor	 edx, edx
  00013	8b 9e 7c 02 00
	00		 mov	 ebx, DWORD PTR [esi+636]
  00019	59		 pop	 ecx
  0001a	33 c0		 xor	 eax, eax
  0001c	8d 7d bc	 lea	 edi, DWORD PTR _nlb$[ebp+4]
  0001f	89 55 b8	 mov	 DWORD PTR _nlb$[ebp], edx
  00022	89 55 f0	 mov	 DWORD PTR _s$[ebp], edx
  00025	f3 ab		 rep stosd

; 467  : 	useProxy=0;
; 468  : 	if (ft->localName!= NULL) mir_free(ft->localName);

  00027	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0002a	89 55 08	 mov	 DWORD PTR _useProxy$[ebp], edx
  0002d	3b c2		 cmp	 eax, edx
  0002f	74 0a		 je	 SHORT $L83507
  00031	50		 push	 eax
  00032	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00038	59		 pop	 ecx
  00039	33 d2		 xor	 edx, edx
$L83507:

; 469  : 	ft->localName = NULL;

  0003b	89 56 28	 mov	 DWORD PTR [esi+40], edx

; 470  : 	ft->wPort = 0;

  0003e	66 89 56 24	 mov	 WORD PTR [esi+36], dx

; 471  : 	if (DBGetContactSettingByte(NULL, proto->iface.m_szModuleName, "UseFileProxy", FALSE)) {

  00042	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00045	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@ ; `string'
  0004a	89 45 f4	 mov	 DWORD PTR _cgs$83751[ebp], eax
  0004d	8d 45 d8	 lea	 eax, DWORD PTR _dbv$83750[ebp]
  00050	89 45 fc	 mov	 DWORD PTR _cgs$83751[ebp+8], eax
  00053	8d 45 f4	 lea	 eax, DWORD PTR _cgs$83751[ebp]
  00056	50		 push	 eax
  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0005c	52		 push	 edx
  0005d	57		 push	 edi
  0005e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cgs$83751[ebp+4], OFFSET FLAT:??_C@_0N@BODO@UseFileProxy?$AA@ ; `string'
  00065	ff 50 24	 call	 DWORD PTR [eax+36]
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	85 c0		 test	 eax, eax
  0006d	0f 85 4d 02 00
	00		 jne	 $L83814
  00073	0f b6 45 dc	 movzx	 eax, BYTE PTR _dbv$83750[ebp+4]
  00077	85 c0		 test	 eax, eax
  00079	0f 84 41 02 00
	00		 je	 $L83814

; 472  : 		if (!DBGetContactSetting(NULL, proto->iface.m_szModuleName, "FileProxyHost", &dbv)) {

  0007f	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00082	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cgs$83760[ebp+4], OFFSET FLAT:??_C@_0O@GFGJ@FileProxyHost?$AA@ ; `string'
  00089	89 45 f4	 mov	 DWORD PTR _cgs$83760[ebp], eax
  0008c	8d 45 e4	 lea	 eax, DWORD PTR _dbv$[ebp]
  0008f	89 45 fc	 mov	 DWORD PTR _cgs$83760[ebp+8], eax
  00092	8d 45 f4	 lea	 eax, DWORD PTR _cgs$83760[ebp]
  00095	50		 push	 eax
  00096	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0009b	6a 00		 push	 0
  0009d	57		 push	 edi
  0009e	ff 50 24	 call	 DWORD PTR [eax+36]
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	85 c0		 test	 eax, eax
  000a6	0f 85 14 02 00
	00		 jne	 $L83814

; 473  : 			strcpy(sb.szHost, dbv.pszVal);

  000ac	ff 75 e8	 push	 DWORD PTR _dbv$[ebp+4]
  000af	8d 85 b0 fc ff
	ff		 lea	 eax, DWORD PTR _sb$[ebp]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _strcpy

; 474  : 			DBFreeVariant(&dbv);

  000bb	8d 45 e4	 lea	 eax, DWORD PTR _dbv$[ebp]
  000be	50		 push	 eax
  000bf	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  000c4	6a 00		 push	 0
  000c6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@ ; `string'
  000cb	ff 50 24	 call	 DWORD PTR [eax+36]

; 475  : 			sb.wPort = DBGetContactSettingWord(NULL, proto->iface.m_szModuleName, "FileProxyPort", 0);

  000ce	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  000d1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cgs$83770[ebp+4], OFFSET FLAT:??_C@_0O@MHC@FileProxyPort?$AA@ ; `string'
  000d8	89 45 f4	 mov	 DWORD PTR _cgs$83770[ebp], eax
  000db	8d 45 d8	 lea	 eax, DWORD PTR _dbv$83769[ebp]
  000de	89 45 fc	 mov	 DWORD PTR _cgs$83770[ebp+8], eax
  000e1	8d 45 f4	 lea	 eax, DWORD PTR _cgs$83770[ebp]
  000e4	50		 push	 eax
  000e5	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  000ea	6a 00		 push	 0
  000ec	57		 push	 edi
  000ed	ff 50 24	 call	 DWORD PTR [eax+36]
  000f0	83 c4 20	 add	 esp, 32			; 00000020H
  000f3	85 c0		 test	 eax, eax
  000f5	74 04		 je	 SHORT $L83771
  000f7	33 c0		 xor	 eax, eax
  000f9	eb 04		 jmp	 SHORT $L83768
$L83771:
  000fb	0f b7 45 dc	 movzx	 eax, WORD PTR _dbv$83769[ebp+4]
$L83768:

; 476  : 			sb.useAuth = FALSE;

  000ff	83 a5 b4 fd ff
	ff 00		 and	 DWORD PTR _sb$[ebp+260], 0
  00106	89 85 b0 fd ff
	ff		 mov	 DWORD PTR _sb$[ebp+256], eax

; 477  : 			strcpy(sb.szUser, "");

  0010c	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR _sb$[ebp+264]
  00112	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _strcpy

; 478  : 			strcpy(sb.szPassword, "");

  0011d	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _sb$[ebp+520]
  00123	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _strcpy

; 479  : 			if (DBGetContactSettingByte(NULL, proto->iface.m_szModuleName, "FileProxyAuth", FALSE)) {

  0012e	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00131	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cgs$83779[ebp+4], OFFSET FLAT:??_C@_0O@EJJI@FileProxyAuth?$AA@ ; `string'
  00138	89 45 f4	 mov	 DWORD PTR _cgs$83779[ebp], eax
  0013b	8d 45 d8	 lea	 eax, DWORD PTR _dbv$83778[ebp]
  0013e	89 45 fc	 mov	 DWORD PTR _cgs$83779[ebp+8], eax
  00141	8d 45 f4	 lea	 eax, DWORD PTR _cgs$83779[ebp]
  00144	50		 push	 eax
  00145	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0014a	6a 00		 push	 0
  0014c	57		 push	 edi
  0014d	ff 50 24	 call	 DWORD PTR [eax+36]
  00150	83 c4 1c	 add	 esp, 28			; 0000001cH
  00153	85 c0		 test	 eax, eax
  00155	0f 85 d5 00 00
	00		 jne	 $L83803
  0015b	0f b6 45 dc	 movzx	 eax, BYTE PTR _dbv$83778[ebp+4]
  0015f	85 c0		 test	 eax, eax
  00161	0f 84 c9 00 00
	00		 je	 $L83803

; 480  : 				sb.useAuth = TRUE;

  00167	c7 85 b4 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR _sb$[ebp+260], 1

; 481  : 				if (!DBGetContactSetting(NULL, proto->iface.m_szModuleName, "FileProxyUsername", &dbv)) {

  00171	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00174	89 45 f4	 mov	 DWORD PTR _cgs$83788[ebp], eax
  00177	8d 45 e4	 lea	 eax, DWORD PTR _dbv$[ebp]
  0017a	89 45 fc	 mov	 DWORD PTR _cgs$83788[ebp+8], eax
  0017d	8d 45 f4	 lea	 eax, DWORD PTR _cgs$83788[ebp]
  00180	50		 push	 eax
  00181	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00186	6a 00		 push	 0
  00188	57		 push	 edi
  00189	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cgs$83788[ebp+4], OFFSET FLAT:??_C@_0BC@CBEM@FileProxyUsername?$AA@ ; `string'
  00190	ff 50 24	 call	 DWORD PTR [eax+36]
  00193	83 c4 0c	 add	 esp, 12			; 0000000cH
  00196	85 c0		 test	 eax, eax
  00198	75 25		 jne	 SHORT $L83793

; 482  : 					strcpy(sb.szUser, dbv.pszVal);

  0019a	ff 75 e8	 push	 DWORD PTR _dbv$[ebp+4]
  0019d	8d 85 b8 fd ff
	ff		 lea	 eax, DWORD PTR _sb$[ebp+264]
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 _strcpy

; 483  : 					DBFreeVariant(&dbv);

  001a9	8d 45 e4	 lea	 eax, DWORD PTR _dbv$[ebp]
  001ac	50		 push	 eax
  001ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  001b2	6a 00		 push	 0
  001b4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@ ; `string'
  001b9	ff 50 24	 call	 DWORD PTR [eax+36]
  001bc	83 c4 14	 add	 esp, 20			; 00000014H
$L83793:

; 484  : 				}
; 485  : 				if (!DBGetContactSetting(NULL, proto->iface.m_szModuleName, "FileProxyPassword", &dbv)) {

  001bf	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  001c2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cgs$83798[ebp+4], OFFSET FLAT:??_C@_0BC@EIFA@FileProxyPassword?$AA@ ; `string'
  001c9	89 45 f4	 mov	 DWORD PTR _cgs$83798[ebp], eax
  001cc	8d 45 e4	 lea	 eax, DWORD PTR _dbv$[ebp]
  001cf	89 45 fc	 mov	 DWORD PTR _cgs$83798[ebp+8], eax
  001d2	8d 45 f4	 lea	 eax, DWORD PTR _cgs$83798[ebp]
  001d5	50		 push	 eax
  001d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  001db	6a 00		 push	 0
  001dd	57		 push	 edi
  001de	ff 50 24	 call	 DWORD PTR [eax+36]
  001e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e4	85 c0		 test	 eax, eax
  001e6	75 48		 jne	 SHORT $L83803

; 486  : 					CallService(MS_DB_CRYPT_DECODESTRING, strlen(dbv.pszVal)+1, (LPARAM) dbv.pszVal);

  001e8	ff 75 e8	 push	 DWORD PTR _dbv$[ebp+4]
  001eb	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  001f0	83 c0 24	 add	 eax, 36			; 00000024H
  001f3	ff 75 e8	 push	 DWORD PTR _dbv$[ebp+4]
  001f6	89 45 d4	 mov	 DWORD PTR -44+[ebp], eax
  001f9	e8 00 00 00 00	 call	 _strlen
  001fe	59		 pop	 ecx
  001ff	40		 inc	 eax
  00200	50		 push	 eax
  00201	8b 45 d4	 mov	 eax, DWORD PTR -44+[ebp]
  00204	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@PHIF@DB?1Crypt?1DecodeString?$AA@ ; `string'
  00209	ff 10		 call	 DWORD PTR [eax]

; 487  : 					strcpy(sb.szPassword, dbv.pszVal);

  0020b	ff 75 e8	 push	 DWORD PTR _dbv$[ebp+4]
  0020e	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _sb$[ebp+520]
  00214	50		 push	 eax
  00215	e8 00 00 00 00	 call	 _strcpy

; 488  : 					DBFreeVariant(&dbv);

  0021a	8d 45 e4	 lea	 eax, DWORD PTR _dbv$[ebp]
  0021d	50		 push	 eax
  0021e	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00223	6a 00		 push	 0
  00225	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@ ; `string'
  0022a	ff 50 24	 call	 DWORD PTR [eax+36]
  0022d	83 c4 20	 add	 esp, 32			; 00000020H
$L83803:

; 489  : 				}
; 490  : 			}
; 491  : 			switch (DBGetContactSettingWord(NULL, proto->iface.m_szModuleName, "FileProxyType", 0)) {

  00230	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00233	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cgs$83808[ebp+4], OFFSET FLAT:??_C@_0O@HKJF@FileProxyType?$AA@ ; `string'
  0023a	89 45 f4	 mov	 DWORD PTR _cgs$83808[ebp], eax
  0023d	8d 45 d8	 lea	 eax, DWORD PTR _dbv$83807[ebp]
  00240	89 45 fc	 mov	 DWORD PTR _cgs$83808[ebp+8], eax
  00243	8d 45 f4	 lea	 eax, DWORD PTR _cgs$83808[ebp]
  00246	50		 push	 eax
  00247	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0024c	6a 00		 push	 0
  0024e	57		 push	 edi
  0024f	ff 50 24	 call	 DWORD PTR [eax+36]
  00252	83 c4 0c	 add	 esp, 12			; 0000000cH
  00255	85 c0		 test	 eax, eax
  00257	74 04		 je	 SHORT $L83809
  00259	33 c0		 xor	 eax, eax
  0025b	eb 04		 jmp	 SHORT $L83806
$L83809:
  0025d	0f b7 45 dc	 movzx	 eax, WORD PTR _dbv$83807[ebp+4]
$L83806:
  00261	6a 02		 push	 2
  00263	83 e8 00	 sub	 eax, 0
  00266	5f		 pop	 edi
  00267	74 2c		 je	 SHORT $L83536
  00269	48		 dec	 eax
  0026a	74 1a		 je	 SHORT $L83537
  0026c	48		 dec	 eax
  0026d	75 2d		 jne	 SHORT $L83532

; 499  : 				case 2: // socks5
; 500  : 					s = TlenP2PBindSocks5(&sb, ft);

  0026f	8d 85 b0 fc ff
	ff		 lea	 eax, DWORD PTR _sb$[ebp]
  00275	56		 push	 esi
  00276	50		 push	 eax
  00277	e8 00 00 00 00	 call	 _TlenP2PBindSocks5
$L83820:
  0027c	59		 pop	 ecx
  0027d	89 45 f0	 mov	 DWORD PTR _s$[ebp], eax
  00280	59		 pop	 ecx

; 501  : 					useProxy = 2;

  00281	89 7d 08	 mov	 DWORD PTR _useProxy$[ebp], edi

; 502  : 					break;

  00284	eb 16		 jmp	 SHORT $L83532
$L83537:

; 494  : 					break;
; 495  : 				case 1: // socks4
; 496  : 					s = TlenP2PBindSocks4(&sb, ft);

  00286	8d 85 b0 fc ff
	ff		 lea	 eax, DWORD PTR _sb$[ebp]
  0028c	56		 push	 esi
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 _TlenP2PBindSocks4

; 497  : 					useProxy = 2;
; 498  : 					break;

  00293	eb e7		 jmp	 SHORT $L83820
$L83536:

; 492  : 				case 0: // forwarding
; 493  : 					useProxy = 1;

  00295	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _useProxy$[ebp], 1
$L83532:

; 503  : 			}
; 504  : 			ft->localName = mir_strdup(sb.szHost);

  0029c	8d 85 b0 fc ff
	ff		 lea	 eax, DWORD PTR _sb$[ebp]
  002a2	50		 push	 eax
  002a3	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20

; 505  : 			ft->wPort = sb.wPort;
; 506  : 			ft->wLocalPort = sb.wPort;
; 507  : 		}
; 508  : 	}
; 509  : 	if (useProxy<2) {

  002a9	39 7d 08	 cmp	 DWORD PTR _useProxy$[ebp], edi
  002ac	89 46 28	 mov	 DWORD PTR [esi+40], eax
  002af	8b 85 b0 fd ff
	ff		 mov	 eax, DWORD PTR _sb$[ebp+256]
  002b5	59		 pop	 ecx
  002b6	66 89 46 24	 mov	 WORD PTR [esi+36], ax
  002ba	66 89 46 2c	 mov	 WORD PTR [esi+44], ax
  002be	7d 59		 jge	 SHORT $L83539
$L83814:

; 510  : 		nlb.cbSize = sizeof(NETLIBBIND);
; 511  : 		nlb.pfnNewConnectionV2 = ft->pfnNewConnectionV2;

  002c0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 512  : 		nlb.wPort = 0;	// Use user-specified incoming port ranges, if available

  002c3	66 83 65 c4 00	 and	 WORD PTR _nlb$[ebp+12], 0

; 513  : 		nlb.pExtra = proto;
; 514  : 		JabberLog(ft->proto, "Calling MS_NETLIB_BINDPORT");

  002c8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@FHBN@Calling?5MS_NETLIB_BINDPORT?$AA@ ; `string'
  002cd	c7 45 b8 1c 00
	00 00		 mov	 DWORD PTR _nlb$[ebp], 28 ; 0000001cH
  002d4	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  002da	89 45 bc	 mov	 DWORD PTR _nlb$[ebp+4], eax
  002dd	89 5d c8	 mov	 DWORD PTR _nlb$[ebp+16], ebx
  002e0	e8 00 00 00 00	 call	 _JabberLog

; 515  : 		s = (HANDLE) CallService(MS_NETLIB_BINDPORT, (WPARAM) ft->proto->hNetlibUser, (LPARAM) &nlb);

  002e5	8d 45 b8	 lea	 eax, DWORD PTR _nlb$[ebp]
  002e8	50		 push	 eax
  002e9	8b 86 7c 02 00
	00		 mov	 eax, DWORD PTR [esi+636]
  002ef	ff b0 c0 00 00
	00		 push	 DWORD PTR [eax+192]
  002f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  002fa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@GLLO@Netlib?1BindPort?$AA@ ; `string'
  002ff	ff 50 24	 call	 DWORD PTR [eax+36]

; 516  : 		JabberLog(ft->proto, "listening on %d",s);

  00302	50		 push	 eax
  00303	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@JJCP@listening?5on?5?$CFd?$AA@ ; `string'
  00308	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  0030e	89 45 f0	 mov	 DWORD PTR _s$[ebp], eax
  00311	e8 00 00 00 00	 call	 _JabberLog
  00316	83 c4 20	 add	 esp, 32			; 00000020H
$L83539:

; 517  : 	}
; 518  : 	if (useProxy==0) {

  00319	83 7d 08 00	 cmp	 DWORD PTR _useProxy$[ebp], 0
  0031d	75 29		 jne	 SHORT $L83547

; 519  : 		in.S_un.S_addr = htonl(nlb.dwExternalIP);

  0031f	ff 75 cc	 push	 DWORD PTR _nlb$[ebp+20]
  00322	e8 00 00 00 00	 call	 _htonl@4

; 520  : 		ft->localName = mir_strdup(inet_ntoa(in));

  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 _inet_ntoa@4
  0032d	50		 push	 eax
  0032e	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  00334	89 46 28	 mov	 DWORD PTR [esi+40], eax

; 521  : 		ft->wPort = nlb.wPort;

  00337	66 8b 45 c4	 mov	 ax, WORD PTR _nlb$[ebp+12]
  0033b	66 89 46 24	 mov	 WORD PTR [esi+36], ax

; 522  : 		ft->wLocalPort = nlb.wExPort;

  0033f	66 8b 45 d0	 mov	 ax, WORD PTR _nlb$[ebp+24]
  00343	59		 pop	 ecx
  00344	66 89 46 2c	 mov	 WORD PTR [esi+44], ax
$L83547:

; 523  : 	}
; 524  : 	if (s != NULL) {
; 525  : //		listenCount++;
; 526  : 	}
; 527  : 	return s;

  00348	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  0034b	5f		 pop	 edi
  0034c	5e		 pop	 esi
  0034d	5b		 pop	 ebx

; 528  : }

  0034e	c9		 leave
  0034f	c3		 ret	 0
_TlenP2PListen ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@JEKK@Netlib?1OpenConnection?$AA@	; `string'
PUBLIC	??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@		; `string'
EXTRN	_JabberForkThread:NEAR
EXTRN	_htons@4:NEAR
;	COMDAT ??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_netlib.h
_DATA	SEGMENT
??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@ DB 'Netlib/CloseHandle', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@JEKK@Netlib?1OpenConnection?$AA@
_DATA	SEGMENT
??_C@_0BG@JEKK@Netlib?1OpenConnection?$AA@ DB 'Netlib/OpenConnection', 00H ; `string'
_DATA	ENDS
;	COMDAT _TlenP2PBindSocks4
_TEXT	SEGMENT
_sb$ = 8
_ft$ = 12
_buf$ = -292
_nloc$ = -36
_nlb$83825 = -12
_nlb$83832 = -12
_nlb$83839 = -12
_TlenP2PBindSocks4 PROC NEAR				; COMDAT

; 302  : {	//rfc1928

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 303  : 	int len;
; 304  : 	BYTE buf[256];
; 305  : 	int status;
; 306  : 	struct in_addr in;
; 307  : 	NETLIBOPENCONNECTION nloc;
; 308  : 	JABBER_SOCKET s;
; 309  : 
; 310  : 	nloc.cbSize = NETLIBOPENCONNECTION_V1_SIZE;//sizeof(NETLIBOPENCONNECTION);
; 311  : 	nloc.szHost = sb->szHost;

  0000b	8b 75 08	 mov	 esi, DWORD PTR _sb$[ebp]
  0000e	57		 push	 edi

; 312  : 	nloc.wPort = sb->wPort;
; 313  : 	nloc.flags = 0;

  0000f	33 ff		 xor	 edi, edi
  00011	c7 45 dc 10 00
	00 00		 mov	 DWORD PTR _nloc$[ebp], 16 ; 00000010H
  00018	66 8b 86 00 01
	00 00		 mov	 ax, WORD PTR [esi+256]
  0001f	89 75 e0	 mov	 DWORD PTR _nloc$[ebp+4], esi
  00022	66 89 45 e4	 mov	 WORD PTR _nloc$[ebp+8], ax

; 314  : 	s = (HANDLE) CallService(MS_NETLIB_OPENCONNECTION, (WPARAM) ft->proto->hFileNetlibUser, (LPARAM) &nloc);

  00026	8d 45 dc	 lea	 eax, DWORD PTR _nloc$[ebp]
  00029	50		 push	 eax
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _ft$[ebp]
  0002d	89 7d e8	 mov	 DWORD PTR _nloc$[ebp+12], edi
  00030	8b 80 7c 02 00
	00		 mov	 eax, DWORD PTR [eax+636]
  00036	ff b0 c4 00 00
	00		 push	 DWORD PTR [eax+196]
  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@JEKK@Netlib?1OpenConnection?$AA@ ; `string'
  00046	ff 50 24	 call	 DWORD PTR [eax+36]
  00049	8b d8		 mov	 ebx, eax
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 315  : 	if (s==NULL) {

  0004e	3b df		 cmp	 ebx, edi

; 316  : //		JabberLog("Connection failed (%d), thread ended", WSAGetLastError());
; 317  : 		return NULL;

  00050	0f 84 6d 01 00
	00		 je	 $L83844

; 318  : 	}
; 319  : 	buf[0] = 4;  //socks4
; 320  : 	buf[1] = 2;  //2-bind, 1-connect
; 321  : 	*(PWORD)(buf+2) = htons(0); // port

  00056	57		 push	 edi
  00057	c6 85 dc fe ff
	ff 04		 mov	 BYTE PTR _buf$[ebp], 4
  0005e	c6 85 dd fe ff
	ff 02		 mov	 BYTE PTR _buf$[ebp+1], 2
  00065	e8 00 00 00 00	 call	 _htons@4

; 322  : 	*(PDWORD)(buf+4) = INADDR_ANY;
; 323  : 	if (sb->useAuth) {

  0006a	39 be 04 01 00
	00		 cmp	 DWORD PTR [esi+260], edi
  00070	66 89 85 de fe
	ff ff		 mov	 WORD PTR _buf$[ebp+2], ax
  00077	89 bd e0 fe ff
	ff		 mov	 DWORD PTR _buf$[ebp+4], edi
  0007d	74 20		 je	 SHORT $L83422

; 324  : 		strcpy(buf+8, sb->szUser);

  0007f	81 c6 08 01 00
	00		 add	 esi, 264		; 00000108H
  00085	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp+8]
  0008b	56		 push	 esi
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _strcpy

; 325  : 		len = strlen(sb->szUser);

  00092	56		 push	 esi
  00093	e8 00 00 00 00	 call	 _strlen
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009b	8b f8		 mov	 edi, eax

; 326  : 	} else {

  0009d	eb 07		 jmp	 SHORT $L83423
$L83422:

; 327  : 		buf[8] = 0;

  0009f	80 a5 e4 fe ff
	ff 00		 and	 BYTE PTR _buf$[ebp+8], 0
$L83423:

; 328  : 		len = 0;
; 329  : 	}
; 330  : 	len += 9;
; 331  : 	status = Netlib_Send(s, buf, len, MSG_NODUMP);

  000a6	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  000ac	83 c7 09	 add	 edi, 9
  000af	89 45 f4	 mov	 DWORD PTR _nlb$83825[ebp], eax
  000b2	8d 45 f4	 lea	 eax, DWORD PTR _nlb$83825[ebp]
  000b5	50		 push	 eax
  000b6	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  000bb	be 00 00 02 00	 mov	 esi, 131072		; 00020000H
  000c0	53		 push	 ebx
  000c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@EFDJ@Netlib?1Send?$AA@ ; `string'
  000c6	89 7d f8	 mov	 DWORD PTR _nlb$83825[ebp+4], edi
  000c9	89 75 fc	 mov	 DWORD PTR _nlb$83825[ebp+8], esi
  000cc	ff 50 24	 call	 DWORD PTR [eax+36]
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 332  : 	if (status==SOCKET_ERROR || status<len) {

  000d2	83 f8 ff	 cmp	 eax, -1
  000d5	0f 84 d5 00 00
	00		 je	 $L83431
  000db	3b c7		 cmp	 eax, edi
  000dd	0f 8c cd 00 00
	00		 jl	 $L83431

; 336  : 	}
; 337  : 	status = Netlib_Recv(s, buf, 8, MSG_NODUMP);

  000e3	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  000e9	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:??_C@_0M@GFGB@Netlib?1Recv?$AA@ ; `string'
  000ee	89 45 f4	 mov	 DWORD PTR _nlb$83832[ebp], eax
  000f1	8d 45 f4	 lea	 eax, DWORD PTR _nlb$83832[ebp]
  000f4	50		 push	 eax
  000f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  000fa	53		 push	 ebx
  000fb	57		 push	 edi
  000fc	c7 45 f8 08 00
	00 00		 mov	 DWORD PTR _nlb$83832[ebp+4], 8
  00103	89 75 fc	 mov	 DWORD PTR _nlb$83832[ebp+8], esi
  00106	ff 50 24	 call	 DWORD PTR [eax+36]
  00109	83 c4 0c	 add	 esp, 12			; 0000000cH

; 338  : 	if (status==SOCKET_ERROR || status<8 || buf[1]!=90) {

  0010c	83 f8 ff	 cmp	 eax, -1
  0010f	0f 84 9b 00 00
	00		 je	 $L83431
  00115	83 f8 08	 cmp	 eax, 8
  00118	0f 8c 92 00 00
	00		 jl	 $L83431
  0011e	80 bd dd fe ff
	ff 5a		 cmp	 BYTE PTR _buf$[ebp+1], 90 ; 0000005aH
  00125	0f 85 85 00 00
	00		 jne	 $L83431

; 339  : //		JabberLog("SOCKS4 negotiation failed");
; 340  : 		Netlib_CloseHandle(s);
; 341  : 		return NULL;
; 342  : 	}
; 343  : 	status = Netlib_Recv(s, buf, sizeof(buf), MSG_NODUMP);

  0012b	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00131	c7 45 f8 00 01
	00 00		 mov	 DWORD PTR _nlb$83839[ebp+4], 256 ; 00000100H
  00138	89 45 f4	 mov	 DWORD PTR _nlb$83839[ebp], eax
  0013b	8d 45 f4	 lea	 eax, DWORD PTR _nlb$83839[ebp]
  0013e	50		 push	 eax
  0013f	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00144	53		 push	 ebx
  00145	57		 push	 edi
  00146	89 75 fc	 mov	 DWORD PTR _nlb$83839[ebp+8], esi
  00149	ff 50 24	 call	 DWORD PTR [eax+36]
  0014c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 344  : 	if ( status == SOCKET_ERROR || status<7 || buf[0]!=5 || buf[1]!=0) {

  0014f	83 f8 ff	 cmp	 eax, -1
  00152	74 5c		 je	 SHORT $L83431
  00154	83 f8 07	 cmp	 eax, 7
  00157	7c 57		 jl	 SHORT $L83431
  00159	80 bd dc fe ff
	ff 05		 cmp	 BYTE PTR _buf$[ebp], 5
  00160	75 4e		 jne	 SHORT $L83431
  00162	80 bd dd fe ff
	ff 00		 cmp	 BYTE PTR _buf$[ebp+1], 0
  00169	75 45		 jne	 SHORT $L83431

; 345  : //		JabberLog("SOCKS5 request failed");
; 346  : 		Netlib_CloseHandle(s);
; 347  : 		return NULL;
; 348  : 	}
; 349  : 	in.S_un.S_addr = *(PDWORD)(buf+4);
; 350  : 	strcpy(sb->szHost, inet_ntoa(in));

  0016b	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _buf$[ebp+4]
  00171	e8 00 00 00 00	 call	 _inet_ntoa@4
  00176	8b 75 08	 mov	 esi, DWORD PTR _sb$[ebp]
  00179	50		 push	 eax
  0017a	56		 push	 esi
  0017b	e8 00 00 00 00	 call	 _strcpy
  00180	59		 pop	 ecx
  00181	59		 pop	 ecx

; 351  : 	sb->wPort = htons(*(PWORD)(buf+2));

  00182	ff b5 de fe ff
	ff		 push	 DWORD PTR _buf$[ebp+2]
  00188	e8 00 00 00 00	 call	 _htons@4
  0018d	0f b7 c0	 movzx	 eax, ax
  00190	89 86 00 01 00
	00		 mov	 DWORD PTR [esi+256], eax

; 352  : 	ft->s = s;

  00196	8b 45 0c	 mov	 eax, DWORD PTR _ft$[ebp]

; 353  : 	JabberForkThread((void (__cdecl *)(void*))TlenFileBindSocks4Thread, 0, ft);

  00199	50		 push	 eax
  0019a	6a 00		 push	 0
  0019c	68 00 00 00 00	 push	 OFFSET FLAT:_TlenFileBindSocks4Thread
  001a1	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  001a4	e8 00 00 00 00	 call	 _JabberForkThread
  001a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 354  : 	return s;

  001ac	8b c3		 mov	 eax, ebx
  001ae	eb 15		 jmp	 SHORT $L83405
$L83431:

; 333  : //		JabberLog("Send failed (%d), thread ended", WSAGetLastError());
; 334  : 		Netlib_CloseHandle(s);

  001b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  001b5	6a 00		 push	 0
  001b7	53		 push	 ebx
  001b8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@ ; `string'
  001bd	ff 50 24	 call	 DWORD PTR [eax+36]
  001c0	83 c4 0c	 add	 esp, 12			; 0000000cH
$L83844:

; 335  : 		return NULL;

  001c3	33 c0		 xor	 eax, eax
$L83405:
  001c5	5f		 pop	 edi
  001c6	5e		 pop	 esi
  001c7	5b		 pop	 ebx

; 355  : }

  001c8	c9		 leave
  001c9	c3		 ret	 0
_TlenP2PBindSocks4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@MAFD@Closing?5connection?5for?5this?5file@ ; `string'
EXTRN	__imp__SetEvent@4:NEAR
;	COMDAT ??_C@_0CN@MAFD@Closing?5connection?5for?5this?5file@
; File C:\MirandaDev\miranda_svn2\include\m_netlib.h
_DATA	SEGMENT
??_C@_0CN@MAFD@Closing?5connection?5for?5this?5file@ DB 'Closing connecti'
	DB	'on for this file transfer...', 00H		; `string'
_DATA	ENDS
;	COMDAT _TlenFileBindSocks4Thread
_TEXT	SEGMENT
_ft$ = 8
_buf$ = -8
_nlb$83849 = -20
_TlenFileBindSocks4Thread PROC NEAR			; COMDAT

; 249  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi

; 250  : 	BYTE buf[8];
; 251  : 	int status;
; 252  : 
; 253  : //	JabberLog("Waiting for the file to be sent via SOCKS...");
; 254  : 	status = Netlib_Recv(ft->s, buf, 8, MSG_NODUMP);

  00007	8b 75 08	 mov	 esi, DWORD PTR _ft$[ebp]
  0000a	8d 4d f8	 lea	 ecx, DWORD PTR _buf$[ebp]
  0000d	c7 45 f0 08 00
	00 00		 mov	 DWORD PTR _nlb$83849[ebp+4], 8
  00014	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00017	89 4d ec	 mov	 DWORD PTR _nlb$83849[ebp], ecx
  0001a	8d 4d ec	 lea	 ecx, DWORD PTR _nlb$83849[ebp]
  0001d	c7 45 f4 00 00
	02 00		 mov	 DWORD PTR _nlb$83849[ebp+8], 131072 ; 00020000H
  00024	51		 push	 ecx
  00025	50		 push	 eax
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@GFGB@Netlib?1Recv?$AA@ ; `string'
  00030	ff 50 24	 call	 DWORD PTR [eax+36]
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 255  : //	JabberLog("accepted connection !!!");
; 256  : 	if ( status == SOCKET_ERROR || status<8 || buf[1]!=90) {

  00036	83 f8 ff	 cmp	 eax, -1
  00039	74 1a		 je	 SHORT $L83378
  0003b	83 f8 08	 cmp	 eax, 8
  0003e	7c 15		 jl	 SHORT $L83378
  00040	80 7d f9 5a	 cmp	 BYTE PTR _buf$[ebp+1], 90 ; 0000005aH

; 257  : 		status = 1;
; 258  : 	} else {
; 259  : 		status = 0;
; 260  : 	}
; 261  : 	if (!status) {

  00044	75 0f		 jne	 SHORT $L83378

; 262  : 		ft->pfnNewConnectionV2(ft->s, 0, NULL);

  00046	6a 00		 push	 0
  00048	6a 00		 push	 0
  0004a	ff 76 04	 push	 DWORD PTR [esi+4]
  0004d	ff 56 08	 call	 DWORD PTR [esi+8]
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 263  : 	} else {

  00053	eb 0d		 jmp	 SHORT $L83381
$L83378:

; 264  : 		if (ft->state!=FT_SWITCH) {

  00055	83 7e 0c 06	 cmp	 DWORD PTR [esi+12], 6
  00059	74 07		 je	 SHORT $L83381

; 265  : 			ft->state = FT_ERROR;

  0005b	c7 46 0c 04 00
	00 00		 mov	 DWORD PTR [esi+12], 4
$L83381:

; 266  : 		}
; 267  : 	}
; 268  : 	JabberLog(ft->proto, "Closing connection for this file transfer...");

  00062	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@MAFD@Closing?5connection?5for?5this?5file@ ; `string'
  00067	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  0006d	e8 00 00 00 00	 call	 _JabberLog

; 269  : //	Netlib_CloseHandle(ft->s);
; 270  : 	if (ft->hFileEvent != NULL)

  00072	8b 76 3c	 mov	 esi, DWORD PTR [esi+60]
  00075	59		 pop	 ecx
  00076	85 f6		 test	 esi, esi
  00078	59		 pop	 ecx
  00079	74 07		 je	 SHORT $L83384

; 271  : 		SetEvent(ft->hFileEvent);

  0007b	56		 push	 esi
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$L83384:
  00082	5e		 pop	 esi

; 272  : 
; 273  : }

  00083	c9		 leave
  00084	c3		 ret	 0
_TlenFileBindSocks4Thread ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@FAEI@Connection?5failed?5?$CI?$CFd?$CJ?0?5thread?5e@ ; `string'
PUBLIC	??_C@_0BP@FOKB@Send?5failed?5?$CI?$CFd?$CJ?0?5thread?5ended?$AA@ ; `string'
PUBLIC	??_C@_0BK@NJPE@SOCKS5?5negotiation?5failed?$AA@	; `string'
PUBLIC	??_C@_0BO@JHMG@SOCKS5?5sub?9negotiation?5failed?$AA@ ; `string'
EXTRN	_WSAGetLastError@0:NEAR
;	COMDAT ??_C@_0CF@FAEI@Connection?5failed?5?$CI?$CFd?$CJ?0?5thread?5e@
; File C:\MirandaDev\miranda_svn2\include\m_netlib.h
_DATA	SEGMENT
??_C@_0CF@FAEI@Connection?5failed?5?$CI?$CFd?$CJ?0?5thread?5e@ DB 'Connec'
	DB	'tion failed (%d), thread ended', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@FOKB@Send?5failed?5?$CI?$CFd?$CJ?0?5thread?5ended?$AA@
_DATA	SEGMENT
??_C@_0BP@FOKB@Send?5failed?5?$CI?$CFd?$CJ?0?5thread?5ended?$AA@ DB 'Send'
	DB	' failed (%d), thread ended', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@NJPE@SOCKS5?5negotiation?5failed?$AA@
_DATA	SEGMENT
??_C@_0BK@NJPE@SOCKS5?5negotiation?5failed?$AA@ DB 'SOCKS5 negotiation fa'
	DB	'iled', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@JHMG@SOCKS5?5sub?9negotiation?5failed?$AA@
_DATA	SEGMENT
??_C@_0BO@JHMG@SOCKS5?5sub?9negotiation?5failed?$AA@ DB 'SOCKS5 sub-negot'
	DB	'iation failed', 00H				; `string'
_DATA	ENDS
;	COMDAT _TlenP2PBindSocks5
_TEXT	SEGMENT
_sb$ = 8
_ft$ = 12
_buf$ = -560
_status$ = -4
_nloc$ = -48
_s$ = -20
_nPassLen$83466 = -4
_nlb$83856 = -16
_nlb$83863 = -16
_nlb$83870 = -16
_nlb$83877 = -16
_nlb$83884 = -16
_nlb$83891 = -16
_TlenP2PBindSocks5 PROC NEAR				; COMDAT

; 358  : {	//rfc1928

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 02 00
	00		 sub	 esp, 560		; 00000230H
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 359  : 	BYTE buf[512];
; 360  : 	int len, status;
; 361  : 	NETLIBOPENCONNECTION nloc;
; 362  : 	struct in_addr in;
; 363  : 	JABBER_SOCKET s;
; 364  : 
; 365  : 	nloc.cbSize = NETLIBOPENCONNECTION_V1_SIZE;//sizeof(NETLIBOPENCONNECTION);
; 366  : 	nloc.szHost = sb->szHost;

  0000b	8b 75 08	 mov	 esi, DWORD PTR _sb$[ebp]

; 367  : 	nloc.wPort = sb->wPort;
; 368  : 	nloc.flags = 0;

  0000e	83 65 dc 00	 and	 DWORD PTR _nloc$[ebp+12], 0
  00012	57		 push	 edi

; 369  : 	s = (HANDLE) CallService(MS_NETLIB_OPENCONNECTION, (WPARAM) ft->proto->hFileNetlibUser, (LPARAM) &nloc);

  00013	8b 7d 0c	 mov	 edi, DWORD PTR _ft$[ebp]
  00016	66 8b 86 00 01
	00 00		 mov	 ax, WORD PTR [esi+256]
  0001d	c7 45 d0 10 00
	00 00		 mov	 DWORD PTR _nloc$[ebp], 16 ; 00000010H
  00024	66 89 45 d8	 mov	 WORD PTR _nloc$[ebp+8], ax
  00028	8d 45 d0	 lea	 eax, DWORD PTR _nloc$[ebp]
  0002b	50		 push	 eax
  0002c	8b 87 7c 02 00
	00		 mov	 eax, DWORD PTR [edi+636]
  00032	89 75 d4	 mov	 DWORD PTR _nloc$[ebp+4], esi
  00035	ff b0 c4 00 00
	00		 push	 DWORD PTR [eax+196]
  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00040	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@JEKK@Netlib?1OpenConnection?$AA@ ; `string'
  00045	ff 50 24	 call	 DWORD PTR [eax+36]
  00048	8b d8		 mov	 ebx, eax
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 370  : 	if (s==NULL) {

  0004d	85 db		 test	 ebx, ebx
  0004f	89 5d ec	 mov	 DWORD PTR _s$[ebp], ebx
  00052	75 1b		 jne	 SHORT $L83453

; 371  : 		JabberLog(ft->proto, "Connection failed (%d), thread ended", WSAGetLastError());

  00054	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00059	50		 push	 eax
  0005a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CF@FAEI@Connection?5failed?5?$CI?$CFd?$CJ?0?5thread?5e@ ; `string'
  0005f	ff b7 7c 02 00
	00		 push	 DWORD PTR [edi+636]
  00065	e8 00 00 00 00	 call	 _JabberLog

; 372  : 		return NULL;

  0006a	e9 1a 03 00 00	 jmp	 $L83901
$L83453:

; 373  : 	}
; 374  : 	buf[0] = 5;  //yep, socks5
; 375  : 	buf[1] = 1;  //one auth method
; 376  : 	buf[2] = sb->useAuth?2:0; // authorization

  0006f	83 be 04 01 00
	00 00		 cmp	 DWORD PTR [esi+260], 0

; 377  : 	status = Netlib_Send(s, buf, 3, MSG_NODUMP);

  00076	bf 00 00 02 00	 mov	 edi, 131072		; 00020000H
  0007b	c6 85 d0 fd ff
	ff 05		 mov	 BYTE PTR _buf$[ebp], 5
  00082	c6 85 d1 fd ff
	ff 01		 mov	 BYTE PTR _buf$[ebp+1], 1
  00089	0f 94 c0	 sete	 al
  0008c	48		 dec	 eax
  0008d	c7 45 f4 03 00
	00 00		 mov	 DWORD PTR _nlb$83856[ebp+4], 3
  00094	83 e0 02	 and	 eax, 2
  00097	89 7d f8	 mov	 DWORD PTR _nlb$83856[ebp+8], edi
  0009a	88 85 d2 fd ff
	ff		 mov	 BYTE PTR _buf$[ebp+2], al
  000a0	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  000a6	89 45 f0	 mov	 DWORD PTR _nlb$83856[ebp], eax
  000a9	8d 45 f0	 lea	 eax, DWORD PTR _nlb$83856[ebp]
  000ac	50		 push	 eax
  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  000b2	53		 push	 ebx
  000b3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@EFDJ@Netlib?1Send?$AA@ ; `string'
  000b8	ff 50 24	 call	 DWORD PTR [eax+36]
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 378  : 	if (status==SOCKET_ERROR || status<3) {

  000be	83 f8 ff	 cmp	 eax, -1
  000c1	0f 84 ef 02 00
	00		 je	 $L83457
  000c7	83 f8 03	 cmp	 eax, 3
  000ca	0f 8c e6 02 00
	00		 jl	 $L83457

; 382  : 	}
; 383  : 	status = Netlib_Recv(s, buf, 2, MSG_NODUMP);

  000d0	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  000d6	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _nlb$83863[ebp+4], 2
  000dd	89 45 f0	 mov	 DWORD PTR _nlb$83863[ebp], eax
  000e0	8d 45 f0	 lea	 eax, DWORD PTR _nlb$83863[ebp]
  000e3	50		 push	 eax
  000e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  000e9	53		 push	 ebx
  000ea	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@GFGB@Netlib?1Recv?$AA@ ; `string'
  000ef	89 7d f8	 mov	 DWORD PTR _nlb$83863[ebp+8], edi
  000f2	ff 50 24	 call	 DWORD PTR [eax+36]
  000f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 384  : 	if (status==SOCKET_ERROR || status<2 || (buf[1]!=0 && buf[1]!=2)) {

  000f8	83 f8 ff	 cmp	 eax, -1
  000fb	0f 84 8d 02 00
	00		 je	 $L83461
  00101	83 f8 02	 cmp	 eax, 2
  00104	0f 8c 84 02 00
	00		 jl	 $L83461
  0010a	80 bd d1 fd ff
	ff 00		 cmp	 BYTE PTR _buf$[ebp+1], 0
  00111	74 0d		 je	 SHORT $L83460
  00113	80 bd d1 fd ff
	ff 02		 cmp	 BYTE PTR _buf$[ebp+1], 2
  0011a	0f 85 6e 02 00
	00		 jne	 $L83461
$L83460:

; 388  : 	}
; 389  : 	if(buf[1]==2) {		//rfc1929

  00120	80 bd d1 fd ff
	ff 02		 cmp	 BYTE PTR _buf$[ebp+1], 2
  00127	0f 85 19 01 00
	00		 jne	 $L83472

; 390  : 		int nUserLen, nPassLen;
; 391  : 		PBYTE pAuthBuf;
; 392  : 
; 393  : 		nUserLen = strlen(sb->szUser);

  0012d	8d 86 08 01 00
	00		 lea	 eax, DWORD PTR [esi+264]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 _strlen
  00139	8b d8		 mov	 ebx, eax

; 394  : 		nPassLen = strlen(sb->szPassword);

  0013b	8d 86 08 02 00
	00		 lea	 eax, DWORD PTR [esi+520]
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 _strlen
  00147	89 45 fc	 mov	 DWORD PTR _nPassLen$83466[ebp], eax

; 395  : 		pAuthBuf = (PBYTE)mir_alloc(3+nUserLen+nPassLen);

  0014a	8d 44 18 03	 lea	 eax, DWORD PTR [eax+ebx+3]
  0014e	50		 push	 eax
  0014f	89 45 e8	 mov	 DWORD PTR -24+[ebp], eax
  00152	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  00158	8b f0		 mov	 esi, eax

; 396  : 		pAuthBuf[0] = 1;		//auth version
; 397  : 		pAuthBuf[1] = nUserLen;
; 398  : 		memcpy(pAuthBuf+2, sb->szUser, nUserLen);

  0015a	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  0015d	05 08 01 00 00	 add	 eax, 264		; 00000108H
  00162	53		 push	 ebx
  00163	50		 push	 eax
  00164	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  00167	50		 push	 eax
  00168	c6 06 01	 mov	 BYTE PTR [esi], 1
  0016b	88 5e 01	 mov	 BYTE PTR [esi+1], bl
  0016e	e8 00 00 00 00	 call	 _memcpy

; 399  : 		pAuthBuf[2+nUserLen]=nPassLen;

  00173	8b 45 fc	 mov	 eax, DWORD PTR _nPassLen$83466[ebp]
  00176	03 de		 add	 ebx, esi

; 400  : 		memcpy(pAuthBuf+3+nUserLen,sb->szPassword,nPassLen);

  00178	50		 push	 eax
  00179	88 43 02	 mov	 BYTE PTR [ebx+2], al
  0017c	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  0017f	05 08 02 00 00	 add	 eax, 520		; 00000208H
  00184	83 c3 03	 add	 ebx, 3
  00187	50		 push	 eax
  00188	53		 push	 ebx
  00189	e8 00 00 00 00	 call	 _memcpy

; 401  : 		status = Netlib_Send(s, pAuthBuf, 3+nUserLen+nPassLen, MSG_NODUMP);

  0018e	8b 5d e8	 mov	 ebx, DWORD PTR -24+[ebp]
  00191	8d 45 f0	 lea	 eax, DWORD PTR _nlb$83870[ebp]
  00194	50		 push	 eax
  00195	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0019a	ff 75 ec	 push	 DWORD PTR _s$[ebp]
  0019d	89 75 f0	 mov	 DWORD PTR _nlb$83870[ebp], esi
  001a0	89 5d f4	 mov	 DWORD PTR _nlb$83870[ebp+4], ebx
  001a3	89 7d f8	 mov	 DWORD PTR _nlb$83870[ebp+8], edi
  001a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@EFDJ@Netlib?1Send?$AA@ ; `string'
  001ab	ff 50 24	 call	 DWORD PTR [eax+36]

; 402  : 		mir_free(pAuthBuf);

  001ae	56		 push	 esi
  001af	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax
  001b2	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  001b8	83 c4 34	 add	 esp, 52			; 00000034H

; 403  : 		if (status==SOCKET_ERROR || status<3+nUserLen+nPassLen) {

  001bb	83 7d fc ff	 cmp	 DWORD PTR _status$[ebp], -1
  001bf	74 5f		 je	 SHORT $L83470
  001c1	39 5d fc	 cmp	 DWORD PTR _status$[ebp], ebx
  001c4	7c 5a		 jl	 SHORT $L83470

; 407  : 		}
; 408  : 		status = Netlib_Recv(s, buf, sizeof(buf), MSG_NODUMP);

  001c6	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  001cc	c7 45 f4 00 02
	00 00		 mov	 DWORD PTR _nlb$83877[ebp+4], 512 ; 00000200H
  001d3	89 45 f0	 mov	 DWORD PTR _nlb$83877[ebp], eax
  001d6	8d 45 f0	 lea	 eax, DWORD PTR _nlb$83877[ebp]
  001d9	50		 push	 eax
  001da	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  001df	ff 75 ec	 push	 DWORD PTR _s$[ebp]
  001e2	89 7d f8	 mov	 DWORD PTR _nlb$83877[ebp+8], edi
  001e5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@GFGB@Netlib?1Recv?$AA@ ; `string'
  001ea	ff 50 24	 call	 DWORD PTR [eax+36]
  001ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 409  : 		if (status==SOCKET_ERROR || status<2 || buf[1]!=0) {

  001f0	83 f8 ff	 cmp	 eax, -1
  001f3	74 0e		 je	 SHORT $L83473
  001f5	83 f8 02	 cmp	 eax, 2
  001f8	7c 09		 jl	 SHORT $L83473
  001fa	80 bd d1 fd ff
	ff 00		 cmp	 BYTE PTR _buf$[ebp+1], 0
  00201	74 40		 je	 SHORT $L83896
$L83473:

; 410  : 			JabberLog(ft->proto, "SOCKS5 sub-negotiation failed");

  00203	8b 45 0c	 mov	 eax, DWORD PTR _ft$[ebp]
  00206	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@JHMG@SOCKS5?5sub?9negotiation?5failed?$AA@ ; `string'
  0020b	ff b0 7c 02 00
	00		 push	 DWORD PTR [eax+636]
  00211	e8 00 00 00 00	 call	 _JabberLog

; 411  : 			Netlib_CloseHandle(s);

  00216	6a 00		 push	 0
  00218	ff 75 ec	 push	 DWORD PTR _s$[ebp]

; 412  : 			return NULL;

  0021b	e9 84 01 00 00	 jmp	 $L83900
$L83470:

; 404  : 			JabberLog(ft->proto, "Send failed (%d), thread ended", WSAGetLastError());

  00220	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00225	50		 push	 eax
  00226	8b 45 0c	 mov	 eax, DWORD PTR _ft$[ebp]
  00229	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@FOKB@Send?5failed?5?$CI?$CFd?$CJ?0?5thread?5ended?$AA@ ; `string'
  0022e	ff b0 7c 02 00
	00		 push	 DWORD PTR [eax+636]
  00234	e8 00 00 00 00	 call	 _JabberLog

; 405  : 			Netlib_CloseHandle(s);

  00239	6a 00		 push	 0
  0023b	ff 75 ec	 push	 DWORD PTR _s$[ebp]

; 406  : 			return NULL;

  0023e	e9 8f 01 00 00	 jmp	 $L83899
$L83896:
  00243	8b 5d ec	 mov	 ebx, DWORD PTR _s$[ebp]
$L83472:

; 413  : 		}
; 414  : 	}
; 415  : 
; 416  : 	{	PBYTE pInit;
; 417  : 		int nHostLen=4;
; 418  : 		DWORD hostIP=INADDR_ANY;
; 419  : 		pInit=(PBYTE)mir_alloc(6+nHostLen);

  00246	6a 0a		 push	 10			; 0000000aH
  00248	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  0024e	59		 pop	 ecx
  0024f	8b f0		 mov	 esi, eax

; 420  : 		pInit[0]=5;   //SOCKS5
; 421  : 		pInit[1]=2;   //bind
; 422  : 		pInit[2]=0;   //reserved
; 423  : 		pInit[3]=1;
; 424  : 		*(PDWORD)(pInit+4)=hostIP;
; 425  : 		*(PWORD)(pInit+4+nHostLen)=htons(0);

  00251	6a 00		 push	 0
  00253	80 66 02 00	 and	 BYTE PTR [esi+2], 0
  00257	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  0025b	c6 06 05	 mov	 BYTE PTR [esi], 5
  0025e	c6 46 01 02	 mov	 BYTE PTR [esi+1], 2
  00262	c6 46 03 01	 mov	 BYTE PTR [esi+3], 1
  00266	e8 00 00 00 00	 call	 _htons@4
  0026b	66 89 46 08	 mov	 WORD PTR [esi+8], ax

; 426  : 		status = Netlib_Send(s, pInit, 6+nHostLen, MSG_NODUMP);

  0026f	8d 45 f0	 lea	 eax, DWORD PTR _nlb$83884[ebp]
  00272	50		 push	 eax
  00273	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00278	53		 push	 ebx
  00279	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@EFDJ@Netlib?1Send?$AA@ ; `string'
  0027e	89 75 f0	 mov	 DWORD PTR _nlb$83884[ebp], esi
  00281	c7 45 f4 0a 00
	00 00		 mov	 DWORD PTR _nlb$83884[ebp+4], 10 ; 0000000aH
  00288	89 7d f8	 mov	 DWORD PTR _nlb$83884[ebp+8], edi
  0028b	ff 50 24	 call	 DWORD PTR [eax+36]

; 427  : 		mir_free(pInit);

  0028e	56		 push	 esi
  0028f	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax
  00292	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00298	83 c4 10	 add	 esp, 16			; 00000010H

; 428  : 		if (status==SOCKET_ERROR || status<6+nHostLen) {

  0029b	83 7d fc ff	 cmp	 DWORD PTR _status$[ebp], -1
  0029f	0f 84 d4 00 00
	00		 je	 $L83487
  002a5	83 7d fc 0a	 cmp	 DWORD PTR _status$[ebp], 10 ; 0000000aH
  002a9	0f 8c ca 00 00
	00		 jl	 $L83487

; 432  : 		}
; 433  : 	}
; 434  : 	status = Netlib_Recv(s, buf, sizeof(buf), MSG_NODUMP);

  002af	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  002b5	c7 45 f4 00 02
	00 00		 mov	 DWORD PTR _nlb$83891[ebp+4], 512 ; 00000200H
  002bc	89 45 f0	 mov	 DWORD PTR _nlb$83891[ebp], eax
  002bf	8d 45 f0	 lea	 eax, DWORD PTR _nlb$83891[ebp]
  002c2	50		 push	 eax
  002c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  002c8	53		 push	 ebx
  002c9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@GFGB@Netlib?1Recv?$AA@ ; `string'
  002ce	89 7d f8	 mov	 DWORD PTR _nlb$83891[ebp+8], edi
  002d1	ff 50 24	 call	 DWORD PTR [eax+36]
  002d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 435  : 	if ( status == SOCKET_ERROR || status<7 || buf[0]!=5 || buf[1]!=0) {

  002d7	83 f8 ff	 cmp	 eax, -1
  002da	0f 84 99 00 00
	00		 je	 $L83487
  002e0	83 f8 07	 cmp	 eax, 7
  002e3	0f 8c 90 00 00
	00		 jl	 $L83487
  002e9	80 bd d0 fd ff
	ff 05		 cmp	 BYTE PTR _buf$[ebp], 5
  002f0	0f 85 83 00 00
	00		 jne	 $L83487
  002f6	80 bd d1 fd ff
	ff 00		 cmp	 BYTE PTR _buf$[ebp+1], 0
  002fd	75 7a		 jne	 SHORT $L83487

; 436  : //		JabberLog("SOCKS5 request failed");
; 437  : 		Netlib_CloseHandle(s);
; 438  : 		return NULL;
; 439  : 	}
; 440  : 	if (buf[2]==1) { // domain

  002ff	80 bd d2 fd ff
	ff 01		 cmp	 BYTE PTR _buf$[ebp+2], 1
  00306	75 24		 jne	 SHORT $L83489

; 441  : 		len = buf[4];

  00308	0f b6 b5 d4 fd
	ff ff		 movzx	 esi, BYTE PTR _buf$[ebp+4]

; 442  : 		memcpy(sb->szHost, buf+5, len);

  0030f	8b 7d 08	 mov	 edi, DWORD PTR _sb$[ebp]
  00312	8d 85 d5 fd ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp+5]
  00318	56		 push	 esi
  00319	50		 push	 eax
  0031a	57		 push	 edi
  0031b	e8 00 00 00 00	 call	 _memcpy

; 443  : 		sb->szHost[len]=0;

  00320	80 24 3e 00	 and	 BYTE PTR [esi+edi], 0
  00324	83 c4 0c	 add	 esp, 12			; 0000000cH

; 444  : 		len += 4;

  00327	83 c6 04	 add	 esi, 4

; 445  : 	} else { // ip address

  0032a	eb 1c		 jmp	 SHORT $L83490
$L83489:

; 446  : 		in.S_un.S_addr = *(PDWORD)(buf+4);
; 447  : 		strcpy(sb->szHost, inet_ntoa(in));

  0032c	ff b5 d4 fd ff
	ff		 push	 DWORD PTR _buf$[ebp+4]
  00332	e8 00 00 00 00	 call	 _inet_ntoa@4
  00337	50		 push	 eax
  00338	ff 75 08	 push	 DWORD PTR _sb$[ebp]
  0033b	e8 00 00 00 00	 call	 _strcpy

; 448  : 		len = 8;

  00340	8b 7d 08	 mov	 edi, DWORD PTR _sb$[ebp]
  00343	59		 pop	 ecx
  00344	59		 pop	 ecx
  00345	6a 08		 push	 8
  00347	5e		 pop	 esi
$L83490:

; 449  : 	}
; 450  : 	sb->wPort = htons(*(PWORD)(buf+len));

  00348	66 8b 84 35 d0
	fd ff ff	 mov	 ax, WORD PTR _buf$[ebp+esi]
  00350	50		 push	 eax
  00351	e8 00 00 00 00	 call	 _htons@4
  00356	0f b7 c0	 movzx	 eax, ax
  00359	89 87 00 01 00
	00		 mov	 DWORD PTR [edi+256], eax

; 451  : 	ft->s = s;

  0035f	8b 45 0c	 mov	 eax, DWORD PTR _ft$[ebp]

; 452  : 
; 453  : 	JabberForkThread((void (__cdecl *)(void*))TlenFileBindSocks5Thread, 0, ft);

  00362	50		 push	 eax
  00363	6a 00		 push	 0
  00365	68 00 00 00 00	 push	 OFFSET FLAT:_TlenFileBindSocks5Thread
  0036a	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  0036d	e8 00 00 00 00	 call	 _JabberForkThread
  00372	83 c4 0c	 add	 esp, 12			; 0000000cH

; 454  : 	return s;

  00375	8b c3		 mov	 eax, ebx
  00377	eb 6b		 jmp	 SHORT $L83442
$L83487:

; 429  : //			JabberLog("Send failed (%d), thread ended", WSAGetLastError());
; 430  : 			Netlib_CloseHandle(s);

  00379	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0037e	6a 00		 push	 0
  00380	53		 push	 ebx
  00381	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@ ; `string'
  00386	ff 50 24	 call	 DWORD PTR [eax+36]
$L83901:
  00389	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  : 			return NULL;

  0038c	eb 54		 jmp	 SHORT $L83898
$L83461:

; 385  : 		JabberLog(ft->proto, "SOCKS5 negotiation failed");

  0038e	8b 45 0c	 mov	 eax, DWORD PTR _ft$[ebp]
  00391	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@NJPE@SOCKS5?5negotiation?5failed?$AA@ ; `string'
  00396	ff b0 7c 02 00
	00		 push	 DWORD PTR [eax+636]
  0039c	e8 00 00 00 00	 call	 _JabberLog

; 386  : 		Netlib_CloseHandle(s);

  003a1	6a 00		 push	 0
  003a3	53		 push	 ebx
$L83900:
  003a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  003a9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@ ; `string'
  003ae	ff 50 24	 call	 DWORD PTR [eax+36]
  003b1	83 c4 14	 add	 esp, 20			; 00000014H

; 387  : 		return NULL;

  003b4	eb 2c		 jmp	 SHORT $L83898
$L83457:

; 379  : 		JabberLog(ft->proto, "Send failed (%d), thread ended", WSAGetLastError());

  003b6	e8 00 00 00 00	 call	 _WSAGetLastError@0
  003bb	50		 push	 eax
  003bc	8b 45 0c	 mov	 eax, DWORD PTR _ft$[ebp]
  003bf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@FOKB@Send?5failed?5?$CI?$CFd?$CJ?0?5thread?5ended?$AA@ ; `string'
  003c4	ff b0 7c 02 00
	00		 push	 DWORD PTR [eax+636]
  003ca	e8 00 00 00 00	 call	 _JabberLog

; 380  : 		Netlib_CloseHandle(s);

  003cf	6a 00		 push	 0
  003d1	53		 push	 ebx
$L83899:
  003d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  003d7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@ ; `string'
  003dc	ff 50 24	 call	 DWORD PTR [eax+36]
  003df	83 c4 18	 add	 esp, 24			; 00000018H
$L83898:

; 381  : 		return NULL;

  003e2	33 c0		 xor	 eax, eax
$L83442:
  003e4	5f		 pop	 edi
  003e5	5e		 pop	 esi
  003e6	5b		 pop	 ebx

; 455  : }

  003e7	c9		 leave
  003e8	c3		 ret	 0
_TlenP2PBindSocks5 ENDP
_TEXT	ENDS
;	COMDAT _TlenFileBindSocks5Thread
_TEXT	SEGMENT
_ft$ = 8
_buf$ = -268
_nlb$83905 = -12
_TlenFileBindSocks5Thread PROC NEAR			; COMDAT

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	56		 push	 esi

; 276  : 	BYTE buf[256];
; 277  : 	int status;
; 278  : 
; 279  : //	JabberLog("Waiting for the file to be sent via SOCKS...");
; 280  : 	status = Netlib_Recv(ft->s, buf, sizeof(buf), MSG_NODUMP);

  0000a	8b 75 08	 mov	 esi, DWORD PTR _ft$[ebp]
  0000d	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  00013	c7 45 f8 00 01
	00 00		 mov	 DWORD PTR _nlb$83905[ebp+4], 256 ; 00000100H
  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	89 4d f4	 mov	 DWORD PTR _nlb$83905[ebp], ecx
  00020	8d 4d f4	 lea	 ecx, DWORD PTR _nlb$83905[ebp]
  00023	c7 45 fc 00 00
	02 00		 mov	 DWORD PTR _nlb$83905[ebp+8], 131072 ; 00020000H
  0002a	51		 push	 ecx
  0002b	50		 push	 eax
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@GFGB@Netlib?1Recv?$AA@ ; `string'
  00036	ff 50 24	 call	 DWORD PTR [eax+36]
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 281  : //	JabberLog("accepted connection !!!");
; 282  : 	if ( status == SOCKET_ERROR || status<7 || buf[1]!=0) {

  0003c	83 f8 ff	 cmp	 eax, -1
  0003f	74 1d		 je	 SHORT $L83394
  00041	83 f8 07	 cmp	 eax, 7
  00044	7c 18		 jl	 SHORT $L83394
  00046	80 bd f5 fe ff
	ff 00		 cmp	 BYTE PTR _buf$[ebp+1], 0

; 283  : 		status = 1;
; 284  : 	} else {
; 285  : 		status = 0;
; 286  : 	}
; 287  : 	if (!status) {

  0004d	75 0f		 jne	 SHORT $L83394

; 288  : 		ft->pfnNewConnectionV2(ft->s, 0, NULL);

  0004f	6a 00		 push	 0
  00051	6a 00		 push	 0
  00053	ff 76 04	 push	 DWORD PTR [esi+4]
  00056	ff 56 08	 call	 DWORD PTR [esi+8]
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 289  : 	} else {

  0005c	eb 0d		 jmp	 SHORT $L83397
$L83394:

; 290  : 		if (ft->state!=FT_SWITCH) {

  0005e	83 7e 0c 06	 cmp	 DWORD PTR [esi+12], 6
  00062	74 07		 je	 SHORT $L83397

; 291  : 			ft->state = FT_ERROR;

  00064	c7 46 0c 04 00
	00 00		 mov	 DWORD PTR [esi+12], 4
$L83397:

; 292  : 		}
; 293  : 	}
; 294  : //	JabberLog("Closing connection for this file transfer...");
; 295  : //	Netlib_CloseHandle(ft->s);
; 296  : 	if (ft->hFileEvent != NULL)

  0006b	8b 76 3c	 mov	 esi, DWORD PTR [esi+60]
  0006e	85 f6		 test	 esi, esi
  00070	74 07		 je	 SHORT $L83399

; 297  : 		SetEvent(ft->hFileEvent);

  00072	56		 push	 esi
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$L83399:
  00079	5e		 pop	 esi

; 298  : 
; 299  : }

  0007a	c9		 leave
  0007b	c3		 ret	 0
_TlenFileBindSocks5Thread ENDP
_TEXT	ENDS
PUBLIC	_TlenP2PStopListening
;	COMDAT _TlenP2PStopListening
_TEXT	SEGMENT
_TlenP2PStopListening PROC NEAR				; COMDAT

; 531  : 	if (s != NULL) {
; 532  : //		listenCount--;
; 533  : //		if (listenCount <= 0) {
; 534  : //			Netlib_CloseHandle(s);
; 535  : //		}
; 536  : 	}
; 537  : }

  00000	c3		 ret	 0
_TlenP2PStopListening ENDP
_TEXT	ENDS
END
