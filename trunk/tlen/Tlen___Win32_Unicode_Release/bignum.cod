	TITLE	E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\crypto\bignum.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04LDEB@?$CF02X?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DCMN@?$CFs?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _mpi_init
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_free
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_grow
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_copy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_swap
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_lset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_get_digit
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_read_string
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_write_hlp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_write_string
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_read_file
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_write_file
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_read_binary
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_write_binary
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_msb
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_lsb
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_shift_l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_shift_r
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_cmp_abs
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_cmp_mpi
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_cmp_int
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_add_abs
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_sub_hlp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_sub_abs
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_add_mpi
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_sub_mpi
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_add_int
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_sub_int
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_mul_hlp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_mul_mpi
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_mul_int
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_div_mpi
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_div_int
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_mod_mpi
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_mod_int
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_montg_init
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_montmul
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_montred
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_exp_mod
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_gcd
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_inv_mod
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_is_prime
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_gen_prime
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mpi_self_test
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
CONST	SEGMENT
_small_prime DD	03H
	DD	071H
	DD	010fH
	DD	01bbH
	DD	026bH
	DD	0335H
	DD	03f5H
	DD	04bdH
	DD	05H
	DD	07fH
	DD	0115H
	DD	01c1H
	DD	0277H
	DD	0337H
	DD	03fbH
	DD	04c1H
	DD	07H
	DD	083H
	DD	0119H
	DD	01c9H
	DD	0281H
	DD	033bH
	DD	03fdH
	DD	04c7H
	DD	0bH
	DD	089H
	DD	011bH
	DD	01cdH
	DD	0283H
	DD	033dH
	DD	0407H
	DD	04cdH
	DD	0dH
	DD	08bH
	DD	0125H
	DD	01cfH
	DD	0287H
	DD	0347H
	DD	0409H
	DD	04cfH
	DD	011H
	DD	095H
	DD	0133H
	DD	01d3H
	DD	028dH
	DD	0355H
	DD	040fH
	DD	04d5H
	DD	013H
	DD	097H
	DD	0137H
	DD	01dfH
	DD	0293H
	DD	0359H
	DD	0419H
	DD	04e1H
	DD	017H
	DD	09dH
	DD	0139H
	DD	01e7H
	DD	0295H
	DD	035bH
	DD	041bH
	DD	04ebH
	DD	01dH
	DD	0a3H
	DD	013dH
	DD	01ebH
	DD	02a1H
	DD	035fH
	DD	0425H
	DD	04fdH
	DD	01fH
	DD	0a7H
	DD	014bH
	DD	01f3H
	DD	02a5H
	DD	036dH
	DD	0427H
	DD	04ffH
	DD	025H
	DD	0adH
	DD	0151H
	DD	01f7H
	DD	02abH
	DD	0371H
	DD	042dH
	DD	0503H
	DD	029H
	DD	0b3H
	DD	015bH
	DD	01fdH
	DD	02b3H
	DD	0373H
	DD	043fH
	DD	0509H
	DD	02bH
	DD	0b5H
	DD	015dH
	DD	0209H
	DD	02bdH
	DD	0377H
	DD	0443H
	DD	050bH
	DD	02fH
	DD	0bfH
	DD	0161H
	DD	020bH
	DD	02c5H
	DD	038bH
	DD	0445H
	DD	0511H
	DD	035H
	DD	0c1H
	DD	0167H
	DD	021dH
	DD	02cfH
	DD	038fH
	DD	0449H
	DD	0515H
	DD	03bH
	DD	0c5H
	DD	016fH
	DD	0223H
	DD	02d7H
	DD	0397H
	DD	044fH
	DD	0517H
	DD	03dH
	DD	0c7H
	DD	0175H
	DD	022dH
	DD	02ddH
	DD	03a1H
	DD	0455H
	DD	051bH
	DD	043H
	DD	0d3H
	DD	017bH
	DD	0233H
	DD	02e3H
	DD	03a9H
	DD	045dH
	DD	0527H
	DD	047H
	DD	0dfH
	DD	017fH
	DD	0239H
	DD	02e7H
	DD	03adH
	DD	0463H
	DD	0529H
	DD	049H
	DD	0e3H
	DD	0185H
	DD	023bH
	DD	02efH
	DD	03b3H
	DD	0469H
	DD	052fH
	DD	04fH
	DD	0e5H
	DD	018dH
	DD	0241H
	DD	02f5H
	DD	03b9H
	DD	047fH
	DD	0551H
	DD	053H
	DD	0e9H
	DD	0191H
	DD	024bH
	DD	02f9H
	DD	03c7H
	DD	0481H
	DD	0557H
	DD	059H
	DD	0efH
	DD	0199H
	DD	0251H
	DD	0301H
	DD	03cbH
	DD	048bH
	DD	055dH
	DD	061H
	DD	0f1H
	DD	01a3H
	DD	0257H
	DD	0305H
	DD	03d1H
	DD	0493H
	DD	0565H
	DD	065H
	DD	0fbH
	DD	01a5H
	DD	0259H
	DD	0313H
	DD	03d7H
	DD	049dH
	DD	0577H
	DD	067H
	DD	0101H
	DD	01afH
	DD	025fH
	DD	031dH
	DD	03dfH
	DD	04a3H
	DD	0581H
	DD	06bH
	DD	0107H
	DD	01b1H
	DD	0265H
	DD	0329H
	DD	03e5H
	DD	04a9H
	DD	058fH
	DD	06dH
	DD	010dH
	DD	01b7H
	DD	0269H
	DD	032bH
	DD	03f1H
	DD	04b1H
	DD	0ffffff91H
__bignum_src DB	'_bignum_src', 00H
CONST	ENDS
PUBLIC	_mpi_init
EXTRN	_memset:NEAR
;	COMDAT _mpi_init
_TEXT	SEGMENT
_X$ = 8
_mpi_init PROC NEAR					; COMDAT

; 50   :     va_list args;
; 51   : 
; 52   :     va_start( args, X );
; 53   : 
; 54   :     while( X != NULL )

  00000	83 7c 24 04 00	 cmp	 DWORD PTR _X$[esp-4], 0
  00005	74 24		 je	 SHORT $L1168
  00007	56		 push	 esi
  00008	8d 74 24 08	 lea	 esi, DWORD PTR _X$[esp]
$L1167:

; 55   :     {
; 56   :         memset( X, 0, sizeof( mpi ) );

  0000c	6a 0c		 push	 12			; 0000000cH
  0000e	6a 00		 push	 0
  00010	ff 74 24 10	 push	 DWORD PTR _X$[esp+8]
  00014	e8 00 00 00 00	 call	 _memset

; 57   :         X = va_arg( args, mpi* );

  00019	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001c	83 c6 04	 add	 esi, 4
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00022	89 44 24 08	 mov	 DWORD PTR _X$[esp], eax
  00026	85 c0		 test	 eax, eax
  00028	75 e2		 jne	 SHORT $L1167
  0002a	5e		 pop	 esi
$L1168:

; 58   :     }
; 59   : 
; 60   :     va_end( args );
; 61   : }

  0002b	c3		 ret	 0
_mpi_init ENDP
_TEXT	ENDS
PUBLIC	_mpi_free
EXTRN	__imp__free:NEAR
;	COMDAT _mpi_free
_TEXT	SEGMENT
_X$ = 8
_mpi_free PROC NEAR					; COMDAT

; 67   : {

  00000	56		 push	 esi

; 68   :     va_list args;
; 69   : 
; 70   :     va_start( args, X );
; 71   : 
; 72   :     while( X != NULL )

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _X$[esp]
  00005	85 f6		 test	 esi, esi
  00007	74 43		 je	 SHORT $L1188
  00009	57		 push	 edi
  0000a	8d 7c 24 0c	 lea	 edi, DWORD PTR _X$[esp+4]
$L1187:

; 73   :     {
; 74   :         if( X->p != NULL )

  0000e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00011	85 c0		 test	 eax, eax
  00013	74 1b		 je	 SHORT $L1190

; 75   :         {
; 76   :             memset( X->p, 0, X->n * ciL );

  00015	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00018	c1 e1 02	 shl	 ecx, 2
  0001b	51		 push	 ecx
  0001c	6a 00		 push	 0
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _memset

; 77   :             free( X->p );

  00024	ff 76 08	 push	 DWORD PTR [esi+8]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0002d	83 c4 10	 add	 esp, 16			; 00000010H
$L1190:

; 78   :         }
; 79   : 
; 80   :         memset( X, 0, sizeof( mpi ) );

  00030	6a 0c		 push	 12			; 0000000cH
  00032	6a 00		 push	 0
  00034	56		 push	 esi
  00035	e8 00 00 00 00	 call	 _memset

; 81   : 
; 82   :         X = va_arg( args, mpi* );

  0003a	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0003d	83 c7 04	 add	 edi, 4
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	89 74 24 0c	 mov	 DWORD PTR _X$[esp+4], esi
  00047	85 f6		 test	 esi, esi
  00049	75 c3		 jne	 SHORT $L1187
  0004b	5f		 pop	 edi
$L1188:
  0004c	5e		 pop	 esi

; 83   :     }
; 84   : 
; 85   :     va_end( args );
; 86   : }

  0004d	c3		 ret	 0
_mpi_free ENDP
_TEXT	ENDS
PUBLIC	_mpi_grow
EXTRN	__imp__realloc:NEAR
;	COMDAT _mpi_grow
_TEXT	SEGMENT
_X$ = 8
_nblimbs$ = 12
_mpi_grow PROC NEAR					; COMDAT

; 93   :     int n = X->n;
; 94   : 
; 95   :     if( n < nblimbs )

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _nblimbs$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR _X$[esp]
  00009	57		 push	 edi
  0000a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	7d 46		 jge	 SHORT $L1208

; 96   :     {
; 97   :         if( X->s == 0 )

  00011	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00014	75 06		 jne	 SHORT $L1209

; 98   :             X->s = 1;

  00016	c7 06 01 00 00
	00		 mov	 DWORD PTR [esi], 1
$L1209:

; 99   : 
; 100  :         X->n = nblimbs;

  0001c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 101  :         X->p = (t_int *) realloc( X->p, X->n * ciL );

  0001f	c1 e0 02	 shl	 eax, 2
  00022	50		 push	 eax
  00023	ff 76 08	 push	 DWORD PTR [esi+8]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  0002c	59		 pop	 ecx
  0002d	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 102  : 
; 103  :         if( X->p == NULL )

  00030	85 c0		 test	 eax, eax
  00032	59		 pop	 ecx
  00033	75 05		 jne	 SHORT $L1214

; 104  :             return( 1 );

  00035	6a 01		 push	 1
  00037	58		 pop	 eax
  00038	eb 1f		 jmp	 SHORT $L1206
$L1214:

; 105  : 
; 106  :         memset( X->p + n, 0, ( X->n - n ) * ciL );

  0003a	8b cf		 mov	 ecx, edi
  0003c	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  0003f	69 c9 ff ff ff
	3f		 imul	 ecx, 1073741823		; 3fffffffH
  00045	03 4e 04	 add	 ecx, DWORD PTR [esi+4]
  00048	c1 e1 02	 shl	 ecx, 2
  0004b	51		 push	 ecx
  0004c	6a 00		 push	 0
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _memset
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
$L1208:

; 107  :     }
; 108  : 
; 109  :     return( 0 );

  00057	33 c0		 xor	 eax, eax
$L1206:
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi

; 110  : }

  0005b	c3		 ret	 0
_mpi_grow ENDP
_TEXT	ENDS
PUBLIC	_mpi_copy
EXTRN	_memcpy:NEAR
;	COMDAT _mpi_copy
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_ret$ = 8
_mpi_copy PROC NEAR					; COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 117  :     int ret, i;
; 118  : 
; 119  :     if( X == Y )

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _Y$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR _X$[ebp]
  0000b	3b fb		 cmp	 edi, ebx
  0000d	75 04		 jne	 SHORT $L1224

; 120  :         return( 0 );

  0000f	33 c0		 xor	 eax, eax
  00011	eb 5a		 jmp	 SHORT $L1221
$L1224:
  00013	56		 push	 esi

; 121  : 
; 122  :     for( i = Y->n - 1; i > 0; i-- )

  00014	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00017	4e		 dec	 esi
  00018	85 f6		 test	 esi, esi
  0001a	7e 13		 jle	 SHORT $L2405
  0001c	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0001f	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
$L1225:

; 123  :         if( Y->p[i] != 0 )

  00022	83 38 00	 cmp	 DWORD PTR [eax], 0
  00025	75 08		 jne	 SHORT $L2405
  00027	4e		 dec	 esi
  00028	83 e8 04	 sub	 eax, 4
  0002b	85 f6		 test	 esi, esi
  0002d	7f f3		 jg	 SHORT $L1225
$L2405:

; 124  :             break;
; 125  :     i++;
; 126  : 
; 127  :     X->s = Y->s;

  0002f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00031	46		 inc	 esi

; 128  : 
; 129  :     CHK( mpi_grow( X, i ) );

  00032	56		 push	 esi
  00033	57		 push	 edi
  00034	89 07		 mov	 DWORD PTR [edi], eax
  00036	e8 00 00 00 00	 call	 _mpi_grow
  0003b	59		 pop	 ecx
  0003c	89 45 08	 mov	 DWORD PTR _ret$[ebp], eax
  0003f	85 c0		 test	 eax, eax
  00041	59		 pop	 ecx
  00042	75 25		 jne	 SHORT $cleanup$1230

; 130  : 
; 131  :     memset( X->p, 0, X->n * ciL );

  00044	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00047	c1 e0 02	 shl	 eax, 2
  0004a	50		 push	 eax
  0004b	6a 00		 push	 0
  0004d	ff 77 08	 push	 DWORD PTR [edi+8]
  00050	e8 00 00 00 00	 call	 _memset

; 132  :     memcpy( X->p, Y->p, i * ciL );

  00055	8b c6		 mov	 eax, esi
  00057	c1 e0 02	 shl	 eax, 2
  0005a	50		 push	 eax
  0005b	ff 73 08	 push	 DWORD PTR [ebx+8]
  0005e	ff 77 08	 push	 DWORD PTR [edi+8]
  00061	e8 00 00 00 00	 call	 _memcpy
  00066	83 c4 18	 add	 esp, 24			; 00000018H
$cleanup$1230:

; 133  : 
; 134  : cleanup:
; 135  : 
; 136  :     return( ret );

  00069	8b 45 08	 mov	 eax, DWORD PTR _ret$[ebp]
  0006c	5e		 pop	 esi
$L1221:
  0006d	5f		 pop	 edi
  0006e	5b		 pop	 ebx

; 137  : }

  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_mpi_copy ENDP
_TEXT	ENDS
PUBLIC	_mpi_swap
;	COMDAT _mpi_swap
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_T$ = -12
_mpi_swap PROC NEAR					; COMDAT

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 144  :     mpi T;
; 145  : 
; 146  :     memcpy( &T, X , sizeof( mpi ) );

  00006	6a 0c		 push	 12			; 0000000cH
  00008	8d 45 f4	 lea	 eax, DWORD PTR _T$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR _X$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _memcpy

; 147  :     memcpy( X , Y , sizeof( mpi ) );

  00014	6a 0c		 push	 12			; 0000000cH
  00016	ff 75 0c	 push	 DWORD PTR _Y$[ebp]
  00019	ff 75 08	 push	 DWORD PTR _X$[ebp]
  0001c	e8 00 00 00 00	 call	 _memcpy

; 148  :     memcpy( Y , &T, sizeof( mpi ) );

  00021	8d 45 f4	 lea	 eax, DWORD PTR _T$[ebp]
  00024	6a 0c		 push	 12			; 0000000cH
  00026	50		 push	 eax
  00027	ff 75 0c	 push	 DWORD PTR _Y$[ebp]
  0002a	e8 00 00 00 00	 call	 _memcpy
  0002f	83 c4 24	 add	 esp, 36			; 00000024H

; 149  : }

  00032	c9		 leave
  00033	c3		 ret	 0
_mpi_swap ENDP
_TEXT	ENDS
PUBLIC	_mpi_lset
;	COMDAT _mpi_lset
_TEXT	SEGMENT
_X$ = 8
_z$ = 12
_mpi_lset PROC NEAR					; COMDAT

; 155  : {

  00000	56		 push	 esi

; 156  :     int ret;
; 157  : 
; 158  :     CHK( mpi_grow( X, 1 ) );

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _X$[esp]
  00005	57		 push	 edi
  00006	6a 01		 push	 1
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 _mpi_grow
  0000e	8b f8		 mov	 edi, eax
  00010	59		 pop	 ecx
  00011	85 ff		 test	 edi, edi
  00013	59		 pop	 ecx
  00014	75 31		 jne	 SHORT $cleanup$1251

; 159  :     memset( X->p, 0, X->n * ciL );

  00016	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00019	c1 e0 02	 shl	 eax, 2
  0001c	50		 push	 eax
  0001d	57		 push	 edi
  0001e	ff 76 08	 push	 DWORD PTR [esi+8]
  00021	e8 00 00 00 00	 call	 _memset

; 160  :     X->p[0] = ( z < 0 ) ? -z : z;

  00026	8b 4c 24 1c	 mov	 ecx, DWORD PTR _z$[esp+16]
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002d	85 c9		 test	 ecx, ecx
  0002f	8b c1		 mov	 eax, ecx
  00031	7d 02		 jge	 SHORT $L2410
  00033	f7 d8		 neg	 eax
$L2410:
  00035	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00038	89 02		 mov	 DWORD PTR [edx], eax

; 161  :     X->s    = ( z < 0 ) ? -1 : 1;

  0003a	33 c0		 xor	 eax, eax
  0003c	85 c9		 test	 ecx, ecx
  0003e	0f 9d c0	 setge	 al
  00041	48		 dec	 eax
  00042	24 fe		 and	 al, -2			; fffffffeH
  00044	40		 inc	 eax
  00045	89 06		 mov	 DWORD PTR [esi], eax
$cleanup$1251:

; 162  : 
; 163  : cleanup:
; 164  : 
; 165  :     return( ret );

  00047	8b c7		 mov	 eax, edi
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi

; 166  : }

  0004b	c3		 ret	 0
_mpi_lset ENDP
_TEXT	ENDS
PUBLIC	_mpi_add_int
PUBLIC	_mpi_mul_int
PUBLIC	_mpi_read_string
EXTRN	_strlen:NEAR
;	COMDAT _mpi_read_string
_TEXT	SEGMENT
_X$ = 8
_radix$ = 12
_s$ = 16
_j$ = 12
_d$ = -4
_T$ = -16
_mpi_read_string PROC NEAR				; COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 190  :     int ret, i, j, n;
; 191  :     t_int d;
; 192  :     mpi T;
; 193  : 
; 194  :     if( radix < 2 || radix > 16 )

  00006	83 7d 0c 02	 cmp	 DWORD PTR _radix$[ebp], 2
  0000a	0f 8c 7c 01 00
	00		 jl	 $L1281
  00010	83 7d 0c 10	 cmp	 DWORD PTR _radix$[ebp], 16 ; 00000010H
  00014	0f 8f 72 01 00
	00		 jg	 $L1281
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi

; 196  : 
; 197  :     mpi_init( &T, NULL );

  0001d	33 ff		 xor	 edi, edi
  0001f	8d 45 f0	 lea	 eax, DWORD PTR _T$[ebp]
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _mpi_init

; 198  : 
; 199  :     if( radix == 16 )

  00029	83 7d 0c 10	 cmp	 DWORD PTR _radix$[ebp], 16 ; 00000010H
  0002d	59		 pop	 ecx
  0002e	59		 pop	 ecx
  0002f	0f 85 be 00 00
	00		 jne	 $L1283

; 200  :     {
; 201  :         n = BITS_TO_LIMBS( strlen( s ) << 2 );

  00035	8b 75 10	 mov	 esi, DWORD PTR _s$[ebp]
  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 _strlen
  0003e	8d 04 85 1f 00
	00 00		 lea	 eax, DWORD PTR [eax*4+31]
  00045	c1 e8 05	 shr	 eax, 5

; 202  : 
; 203  :         CHK( mpi_grow( X, n ) );

  00048	50		 push	 eax
  00049	ff 75 08	 push	 DWORD PTR _X$[ebp]
  0004c	e8 00 00 00 00	 call	 _mpi_grow
  00051	8b d8		 mov	 ebx, eax
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	3b df		 cmp	 ebx, edi
  00058	0f 85 1a 01 00
	00		 jne	 $cleanup$1289

; 204  :         CHK( mpi_lset( X, 0 ) );

  0005e	57		 push	 edi
  0005f	ff 75 08	 push	 DWORD PTR _X$[ebp]
  00062	e8 00 00 00 00	 call	 _mpi_lset
  00067	8b d8		 mov	 ebx, eax
  00069	59		 pop	 ecx
  0006a	3b df		 cmp	 ebx, edi
  0006c	59		 pop	 ecx
  0006d	0f 85 05 01 00
	00		 jne	 $cleanup$1289

; 205  : 
; 206  :         for( i = strlen( s ) - 1, j = 0; i >= 0; i--, j++ )

  00073	56		 push	 esi
  00074	e8 00 00 00 00	 call	 _strlen
  00079	8b f8		 mov	 edi, eax
  0007b	59		 pop	 ecx
  0007c	4f		 dec	 edi
  0007d	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00084	0f 88 ee 00 00
	00		 js	 $cleanup$1289
  0008a	eb 03		 jmp	 SHORT $L1291
$L2422:
  0008c	8b 75 10	 mov	 esi, DWORD PTR _s$[ebp]
$L1291:

; 207  :         {
; 208  :             if( i == 0 && s[i] == '-' )

  0008f	85 ff		 test	 edi, edi
  00091	75 05		 jne	 SHORT $L1294
  00093	80 3e 2d	 cmp	 BYTE PTR [esi], 45	; 0000002dH
  00096	74 50		 je	 SHORT $L2415
$L1294:

; 212  :             }
; 213  : 
; 214  :             CHK( mpi_get_digit( &d, radix, s[i] ) );

  00098	8a 04 37	 mov	 al, BYTE PTR [edi+esi]
  0009b	50		 push	 eax
  0009c	8d 45 fc	 lea	 eax, DWORD PTR _d$[ebp]
  0009f	6a 10		 push	 16			; 00000010H
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _mpi_get_digit
  000a7	8b d8		 mov	 ebx, eax
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ac	85 db		 test	 ebx, ebx
  000ae	0f 85 c4 00 00
	00		 jne	 $cleanup$1289

; 215  :             X->p[j / (ciL * 2)] |= d << ( (j % (ciL * 2)) << 2 );

  000b4	8b 45 0c	 mov	 eax, DWORD PTR _j$[ebp]
  000b7	6a 08		 push	 8
  000b9	99		 cdq
  000ba	59		 pop	 ecx
  000bb	f7 f9		 idiv	 ecx
  000bd	8b 4d 08	 mov	 ecx, DWORD PTR _X$[ebp]
  000c0	6a 08		 push	 8
  000c2	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  000c5	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  000c8	8b 45 0c	 mov	 eax, DWORD PTR _j$[ebp]
  000cb	99		 cdq
  000cc	59		 pop	 ecx
  000cd	f7 f9		 idiv	 ecx
  000cf	8b 45 fc	 mov	 eax, DWORD PTR _d$[ebp]
  000d2	8b ca		 mov	 ecx, edx
  000d4	c1 e1 02	 shl	 ecx, 2
  000d7	d3 e0		 shl	 eax, cl
  000d9	09 06		 or	 DWORD PTR [esi], eax
  000db	4f		 dec	 edi
  000dc	ff 45 0c	 inc	 DWORD PTR _j$[ebp]
  000df	85 ff		 test	 edi, edi
  000e1	7d a9		 jge	 SHORT $L2422

; 232  :             CHK( mpi_add_int( X, &T, d ) );

  000e3	e9 90 00 00 00	 jmp	 $cleanup$1289
$L2415:

; 209  :             {
; 210  :                 X->s = -1;

  000e8	8b 45 08	 mov	 eax, DWORD PTR _X$[ebp]
  000eb	83 08 ff	 or	 DWORD PTR [eax], -1

; 211  :                 break;

  000ee	e9 85 00 00 00	 jmp	 $cleanup$1289
$L1283:

; 216  :         }
; 217  :     }
; 218  :     else
; 219  :     {
; 220  :         CHK( mpi_lset( X, 0 ) );

  000f3	57		 push	 edi
  000f4	ff 75 08	 push	 DWORD PTR _X$[ebp]
  000f7	e8 00 00 00 00	 call	 _mpi_lset
  000fc	8b d8		 mov	 ebx, eax
  000fe	59		 pop	 ecx
  000ff	3b df		 cmp	 ebx, edi
  00101	59		 pop	 ecx
  00102	75 74		 jne	 SHORT $cleanup$1289

; 221  : 
; 222  :         for( i = 0; i < (int) strlen( s ); i++ )

  00104	8b 75 10	 mov	 esi, DWORD PTR _s$[ebp]
  00107	56		 push	 esi
  00108	e8 00 00 00 00	 call	 _strlen
  0010d	85 c0		 test	 eax, eax
  0010f	59		 pop	 ecx
  00110	7e 66		 jle	 SHORT $cleanup$1289
$L1303:

; 223  :         {
; 224  :             if( i == 0 && s[i] == '-' )

  00112	85 ff		 test	 edi, edi
  00114	75 0d		 jne	 SHORT $L1306
  00116	80 3e 2d	 cmp	 BYTE PTR [esi], 45	; 0000002dH
  00119	75 08		 jne	 SHORT $L1306

; 225  :             {
; 226  :                 X->s = -1;

  0011b	8b 45 08	 mov	 eax, DWORD PTR _X$[ebp]
  0011e	83 08 ff	 or	 DWORD PTR [eax], -1

; 227  :                 continue;

  00121	eb 49		 jmp	 SHORT $L1304
$L1306:

; 228  :             }
; 229  : 
; 230  :             CHK( mpi_get_digit( &d, radix, s[i] ) );

  00123	8a 04 37	 mov	 al, BYTE PTR [edi+esi]
  00126	50		 push	 eax
  00127	8d 45 fc	 lea	 eax, DWORD PTR _d$[ebp]
  0012a	ff 75 0c	 push	 DWORD PTR _radix$[ebp]
  0012d	50		 push	 eax
  0012e	e8 00 00 00 00	 call	 _mpi_get_digit
  00133	8b d8		 mov	 ebx, eax
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH
  00138	85 db		 test	 ebx, ebx
  0013a	75 3c		 jne	 SHORT $cleanup$1289

; 231  :             CHK( mpi_mul_int( &T, X, radix ) );

  0013c	ff 75 0c	 push	 DWORD PTR _radix$[ebp]
  0013f	8d 45 f0	 lea	 eax, DWORD PTR _T$[ebp]
  00142	ff 75 08	 push	 DWORD PTR _X$[ebp]
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 _mpi_mul_int
  0014b	8b d8		 mov	 ebx, eax
  0014d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00150	85 db		 test	 ebx, ebx
  00152	75 24		 jne	 SHORT $cleanup$1289

; 232  :             CHK( mpi_add_int( X, &T, d ) );

  00154	ff 75 fc	 push	 DWORD PTR _d$[ebp]
  00157	8d 45 f0	 lea	 eax, DWORD PTR _T$[ebp]
  0015a	50		 push	 eax
  0015b	ff 75 08	 push	 DWORD PTR _X$[ebp]
  0015e	e8 00 00 00 00	 call	 _mpi_add_int
  00163	8b d8		 mov	 ebx, eax
  00165	83 c4 0c	 add	 esp, 12			; 0000000cH
  00168	85 db		 test	 ebx, ebx
  0016a	75 0c		 jne	 SHORT $cleanup$1289
$L1304:

; 221  : 
; 222  :         for( i = 0; i < (int) strlen( s ); i++ )

  0016c	56		 push	 esi
  0016d	47		 inc	 edi
  0016e	e8 00 00 00 00	 call	 _strlen
  00173	3b f8		 cmp	 edi, eax
  00175	59		 pop	 ecx
  00176	7c 9a		 jl	 SHORT $L1303
$cleanup$1289:

; 233  :         }
; 234  :     }
; 235  : 
; 236  : cleanup:
; 237  : 
; 238  :     mpi_free( &T, NULL );

  00178	8d 45 f0	 lea	 eax, DWORD PTR _T$[ebp]
  0017b	6a 00		 push	 0
  0017d	50		 push	 eax
  0017e	e8 00 00 00 00	 call	 _mpi_free
  00183	59		 pop	 ecx

; 239  :     return( ret );

  00184	8b c3		 mov	 eax, ebx
  00186	59		 pop	 ecx
  00187	5f		 pop	 edi
  00188	5e		 pop	 esi
  00189	5b		 pop	 ebx

; 240  : }

  0018a	c9		 leave
  0018b	c3		 ret	 0
$L1281:

; 195  :         return( ERR_MPI_INVALID_PARAMETER );

  0018c	6a 06		 push	 6
  0018e	58		 pop	 eax

; 240  : }

  0018f	c9		 leave
  00190	c3		 ret	 0
_mpi_read_string ENDP
_TEXT	ENDS
;	COMDAT _mpi_get_digit
_TEXT	SEGMENT
_d$ = 8
_radix$ = 12
_c$ = 16
_mpi_get_digit PROC NEAR				; COMDAT

; 173  :     *d = 16;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _d$[esp-4]

; 174  : 
; 175  :     if( c >= 0x30 && c <= 0x39 ) *d = c - 0x30;

  00004	8a 4c 24 0c	 mov	 cl, BYTE PTR _c$[esp-4]
  00008	80 f9 30	 cmp	 cl, 48			; 00000030H
  0000b	c7 00 10 00 00
	00		 mov	 DWORD PTR [eax], 16	; 00000010H
  00011	7c 0d		 jl	 SHORT $L1262
  00013	80 f9 39	 cmp	 cl, 57			; 00000039H
  00016	7f 08		 jg	 SHORT $L1262
  00018	0f be d1	 movsx	 edx, cl
  0001b	83 ea 30	 sub	 edx, 48			; 00000030H
  0001e	89 10		 mov	 DWORD PTR [eax], edx
$L1262:

; 176  :     if( c >= 0x41 && c <= 0x46 ) *d = c - 0x37;

  00020	80 f9 41	 cmp	 cl, 65			; 00000041H
  00023	7c 0d		 jl	 SHORT $L1263
  00025	80 f9 46	 cmp	 cl, 70			; 00000046H
  00028	7f 08		 jg	 SHORT $L1263
  0002a	0f be d1	 movsx	 edx, cl
  0002d	83 ea 37	 sub	 edx, 55			; 00000037H
  00030	89 10		 mov	 DWORD PTR [eax], edx
$L1263:

; 177  :     if( c >= 0x61 && c <= 0x66 ) *d = c - 0x57;

  00032	80 f9 61	 cmp	 cl, 97			; 00000061H
  00035	7c 0d		 jl	 SHORT $L1264
  00037	80 f9 66	 cmp	 cl, 102			; 00000066H
  0003a	7f 08		 jg	 SHORT $L1264
  0003c	0f be c9	 movsx	 ecx, cl
  0003f	83 e9 57	 sub	 ecx, 87			; 00000057H
  00042	89 08		 mov	 DWORD PTR [eax], ecx
$L1264:

; 178  : 
; 179  :     if( *d >= (t_int) radix )

  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	3b 44 24 08	 cmp	 eax, DWORD PTR _radix$[esp-4]
  0004a	1b c0		 sbb	 eax, eax
  0004c	24 fc		 and	 al, -4			; fffffffcH
  0004e	83 c0 04	 add	 eax, 4

; 180  :         return( ERR_MPI_INVALID_CHARACTER );
; 181  : 
; 182  :     return( 0 );
; 183  : }

  00051	c3		 ret	 0
_mpi_get_digit ENDP
_TEXT	ENDS
PUBLIC	??_C@_04LDEB@?$CF02X?$AA@			; `string'
PUBLIC	_mpi_write_string
PUBLIC	_mpi_msb
EXTRN	__imp__sprintf:NEAR
;	COMDAT ??_C@_04LDEB@?$CF02X?$AA@
; File E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\crypto\bignum.c
_DATA	SEGMENT
??_C@_04LDEB@?$CF02X?$AA@ DB '%02X', 00H		; `string'
_DATA	ENDS
;	COMDAT _mpi_write_string
_TEXT	SEGMENT
_X$ = 8
_radix$ = 12
_s$ = 16
_slen$ = 20
_ret$ = -4
_p$ = 12
_T$ = -16
_mpi_write_string PROC NEAR				; COMDAT

; 271  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 272  :     int ret = 0, n;

  00006	83 65 fc 00	 and	 DWORD PTR _ret$[ebp], 0
  0000a	53		 push	 ebx
  0000b	56		 push	 esi

; 273  :     char *p;
; 274  :     mpi T;
; 275  : 
; 276  :     if( radix < 2 || radix > 16 )

  0000c	8b 75 0c	 mov	 esi, DWORD PTR _radix$[ebp]
  0000f	83 fe 02	 cmp	 esi, 2
  00012	57		 push	 edi
  00013	0f 8c f7 00 00
	00		 jl	 $L1345
  00019	83 fe 10	 cmp	 esi, 16			; 00000010H
  0001c	0f 8f ee 00 00
	00		 jg	 $L1345

; 278  : 
; 279  :     n = mpi_msb( X );

  00022	8b 5d 08	 mov	 ebx, DWORD PTR _X$[ebp]
  00025	53		 push	 ebx
  00026	e8 00 00 00 00	 call	 _mpi_msb

; 280  :     if( radix >=  4 ) n >>= 1;

  0002b	83 fe 04	 cmp	 esi, 4
  0002e	59		 pop	 ecx
  0002f	7c 02		 jl	 SHORT $L1346
  00031	d1 f8		 sar	 eax, 1
$L1346:

; 281  :     if( radix >= 16 ) n >>= 1;

  00033	83 fe 10	 cmp	 esi, 16			; 00000010H
  00036	7c 02		 jl	 SHORT $L1347
  00038	d1 f8		 sar	 eax, 1
$L1347:

; 282  :     n += 3;
; 283  : 
; 284  :     if( *slen < n )

  0003a	8b 7d 14	 mov	 edi, DWORD PTR _slen$[ebp]
  0003d	83 c0 03	 add	 eax, 3
  00040	39 07		 cmp	 DWORD PTR [edi], eax
  00042	7d 09		 jge	 SHORT $L1348

; 285  :     {
; 286  :         *slen = n;

  00044	89 07		 mov	 DWORD PTR [edi], eax

; 287  :         return( ERR_MPI_BUFFER_TOO_SMALL );

  00046	6a 08		 push	 8
  00048	e9 c5 00 00 00	 jmp	 $L2436
$L1348:

; 288  :     }
; 289  : 
; 290  :     p = s;

  0004d	8b 45 10	 mov	 eax, DWORD PTR _s$[ebp]

; 291  :     mpi_init( &T, NULL );

  00050	6a 00		 push	 0
  00052	89 45 0c	 mov	 DWORD PTR _p$[ebp], eax
  00055	8d 45 f0	 lea	 eax, DWORD PTR _T$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _mpi_init

; 292  : 
; 293  :     if( X->s == -1 )

  0005e	83 3b ff	 cmp	 DWORD PTR [ebx], -1
  00061	59		 pop	 ecx
  00062	59		 pop	 ecx
  00063	75 09		 jne	 SHORT $L1350

; 294  :         *p++ = '-';

  00065	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00068	c6 00 2d	 mov	 BYTE PTR [eax], 45	; 0000002dH
  0006b	ff 45 0c	 inc	 DWORD PTR _p$[ebp]
$L1350:

; 295  : 
; 296  :     if( radix == 16 )

  0006e	83 fe 10	 cmp	 esi, 16			; 00000010H
  00071	75 4e		 jne	 SHORT $L1351

; 297  :     {
; 298  :         int c, i, j, k;
; 299  : 
; 300  :         for( i = X->n - 1, k = 0; i >= 0; i-- )

  00073	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00076	6a 00		 push	 0
  00078	4e		 dec	 esi
  00079	5a		 pop	 edx
  0007a	78 70		 js	 SHORT $L1369
$L1356:

; 301  :         {
; 302  :             for( j = ciL - 1; j >= 0; j-- )

  0007c	6a 03		 push	 3
  0007e	5f		 pop	 edi
$L1361:

; 303  :             {
; 304  :                 c = ( X->p[i] >> (j << 3) ) & 0xFF;

  0007f	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00082	8b cf		 mov	 ecx, edi
  00084	c1 e1 03	 shl	 ecx, 3
  00087	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0008a	d3 e8		 shr	 eax, cl
  0008c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 305  : 
; 306  :                 if( c == 0 && k == 0 && (i + j) != 0 )

  00091	75 0b		 jne	 SHORT $L1364
  00093	85 d2		 test	 edx, edx
  00095	75 07		 jne	 SHORT $L1364
  00097	8d 0c 37	 lea	 ecx, DWORD PTR [edi+esi]
  0009a	85 c9		 test	 ecx, ecx
  0009c	75 18		 jne	 SHORT $L1362
$L1364:

; 307  :                     continue;
; 308  : 
; 309  :                 p += sprintf( p, "%02X", c );

  0009e	50		 push	 eax
  0009f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04LDEB@?$CF02X?$AA@ ; `string'
  000a4	ff 75 0c	 push	 DWORD PTR _p$[ebp]
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b0	01 45 0c	 add	 DWORD PTR _p$[ebp], eax

; 310  :                 k = 1;

  000b3	6a 01		 push	 1
  000b5	5a		 pop	 edx
$L1362:

; 301  :         {
; 302  :             for( j = ciL - 1; j >= 0; j-- )

  000b6	4f		 dec	 edi
  000b7	79 c6		 jns	 SHORT $L1361

; 297  :     {
; 298  :         int c, i, j, k;
; 299  : 
; 300  :         for( i = X->n - 1, k = 0; i >= 0; i-- )

  000b9	4e		 dec	 esi
  000ba	79 c0		 jns	 SHORT $L1356

; 311  :             }
; 312  :         }
; 313  :     }
; 314  :     else

  000bc	8b 7d 14	 mov	 edi, DWORD PTR _slen$[ebp]
  000bf	eb 2b		 jmp	 SHORT $L1369
$L1351:

; 315  :     {
; 316  :         CHK( mpi_copy( &T, X ) );

  000c1	8d 45 f0	 lea	 eax, DWORD PTR _T$[ebp]
  000c4	53		 push	 ebx
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _mpi_copy
  000cb	59		 pop	 ecx
  000cc	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  000cf	85 c0		 test	 eax, eax
  000d1	59		 pop	 ecx
  000d2	75 2a		 jne	 SHORT $cleanup$1368

; 317  :         CHK( mpi_write_hlp( &T, radix, &p ) );

  000d4	8d 45 0c	 lea	 eax, DWORD PTR _p$[ebp]
  000d7	50		 push	 eax
  000d8	8d 45 f0	 lea	 eax, DWORD PTR _T$[ebp]
  000db	56		 push	 esi
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _mpi_write_hlp
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e5	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  000e8	85 c0		 test	 eax, eax
  000ea	75 12		 jne	 SHORT $cleanup$1368
$L1369:

; 318  :     }
; 319  : 
; 320  :     *p++ = '\0';

  000ec	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  000ef	80 20 00	 and	 BYTE PTR [eax], 0
  000f2	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  000f5	40		 inc	 eax
  000f6	89 45 0c	 mov	 DWORD PTR _p$[ebp], eax

; 321  :     *slen = p - s;

  000f9	2b 45 10	 sub	 eax, DWORD PTR _s$[ebp]
  000fc	89 07		 mov	 DWORD PTR [edi], eax
$cleanup$1368:

; 322  : 
; 323  : cleanup:
; 324  : 
; 325  :     mpi_free( &T, NULL );

  000fe	8d 45 f0	 lea	 eax, DWORD PTR _T$[ebp]
  00101	6a 00		 push	 0
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 _mpi_free

; 326  :     return( ret );

  00109	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
  0010c	59		 pop	 ecx
  0010d	59		 pop	 ecx
  0010e	eb 03		 jmp	 SHORT $L1339
$L1345:

; 277  :         return( ERR_MPI_INVALID_PARAMETER );

  00110	6a 06		 push	 6
$L2436:
  00112	58		 pop	 eax
$L1339:
  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx

; 327  : }

  00116	c9		 leave
  00117	c3		 ret	 0
_mpi_write_string ENDP
_TEXT	ENDS
PUBLIC	_mpi_cmp_int
PUBLIC	_mpi_div_int
PUBLIC	_mpi_mod_int
;	COMDAT _mpi_write_hlp
_TEXT	SEGMENT
_X$ = 8
_radix$ = 12
_p$ = 16
_r$ = 8
_mpi_write_hlp PROC NEAR				; COMDAT

; 246  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 247  :     int ret;
; 248  :     t_int r;
; 249  : 
; 250  :     if( radix < 2 || radix > 16 )

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _radix$[ebp]
  00007	83 ff 02	 cmp	 edi, 2
  0000a	7c 71		 jl	 SHORT $L1322
  0000c	83 ff 10	 cmp	 edi, 16			; 00000010H
  0000f	7f 6c		 jg	 SHORT $L1322
  00011	53		 push	 ebx
  00012	56		 push	 esi

; 252  : 
; 253  :     CHK( mpi_mod_int( &r, X, radix ) );

  00013	8b 75 08	 mov	 esi, DWORD PTR _X$[ebp]
  00016	57		 push	 edi
  00017	8d 45 08	 lea	 eax, DWORD PTR _r$[ebp]
  0001a	56		 push	 esi
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _mpi_mod_int
  00021	8b d8		 mov	 ebx, eax
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	85 db		 test	 ebx, ebx
  00028	75 4d		 jne	 SHORT $cleanup$1324

; 254  :     CHK( mpi_div_int( X, NULL, X, radix ) );

  0002a	57		 push	 edi
  0002b	56		 push	 esi
  0002c	50		 push	 eax
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 _mpi_div_int
  00033	8b d8		 mov	 ebx, eax
  00035	83 c4 10	 add	 esp, 16			; 00000010H
  00038	85 db		 test	 ebx, ebx
  0003a	75 3b		 jne	 SHORT $cleanup$1324

; 255  : 
; 256  :     if( mpi_cmp_int( X, 0 ) != 0 )

  0003c	50		 push	 eax
  0003d	56		 push	 esi
  0003e	e8 00 00 00 00	 call	 _mpi_cmp_int
  00043	8b 7d 10	 mov	 edi, DWORD PTR _p$[ebp]
  00046	59		 pop	 ecx
  00047	85 c0		 test	 eax, eax
  00049	59		 pop	 ecx
  0004a	74 13		 je	 SHORT $L1328

; 257  :         CHK( mpi_write_hlp( X, radix, p ) );

  0004c	57		 push	 edi
  0004d	ff 75 0c	 push	 DWORD PTR _radix$[ebp]
  00050	56		 push	 esi
  00051	e8 00 00 00 00	 call	 _mpi_write_hlp
  00056	8b d8		 mov	 ebx, eax
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	85 db		 test	 ebx, ebx
  0005d	75 18		 jne	 SHORT $cleanup$1324
$L1328:

; 258  : 
; 259  :     *(*p)++ = ( r < 10 ) ? ( (char) r + 0x30 )
; 260  :                          : ( (char) r + 0x37 );

  0005f	83 7d 08 0a	 cmp	 DWORD PTR _r$[ebp], 10	; 0000000aH
  00063	0f be 45 08	 movsx	 eax, BYTE PTR _r$[ebp]
  00067	73 05		 jae	 SHORT $L2438
  00069	83 c0 30	 add	 eax, 48			; 00000030H
  0006c	eb 03		 jmp	 SHORT $L2439
$L2438:
  0006e	83 c0 37	 add	 eax, 55			; 00000037H
$L2439:
  00071	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00073	88 01		 mov	 BYTE PTR [ecx], al
  00075	ff 07		 inc	 DWORD PTR [edi]
$cleanup$1324:

; 261  : 
; 262  : cleanup:
; 263  : 
; 264  :     return( ret );

  00077	8b c3		 mov	 eax, ebx
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	eb 03		 jmp	 SHORT $L1318
$L1322:

; 251  :         return( ERR_MPI_INVALID_PARAMETER );

  0007d	6a 06		 push	 6
  0007f	58		 pop	 eax
$L1318:
  00080	5f		 pop	 edi

; 265  : }

  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
_mpi_write_hlp ENDP
_TEXT	ENDS
PUBLIC	_mpi_read_file
EXTRN	__imp__fgets:NEAR
;	COMDAT _mpi_read_file
_TEXT	SEGMENT
_X$ = 8
_radix$ = 12
_fin$ = 16
_s$ = -1540
_d$ = -4
_mpi_read_file PROC NEAR				; COMDAT

; 333  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 06 00
	00		 sub	 esp, 1540		; 00000604H

; 334  :     char s[1536], *p;
; 335  :     int slen;
; 336  :     t_int d;
; 337  : 
; 338  :     memset( s, 0, sizeof( s ) );

  00009	68 00 06 00 00	 push	 1536			; 00000600H
  0000e	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00014	6a 00		 push	 0
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _memset

; 339  :     if( fgets( s, sizeof( s ) - 1, fin ) == NULL )

  0001c	ff 75 10	 push	 DWORD PTR _fin$[ebp]
  0001f	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00025	68 ff 05 00 00	 push	 1535			; 000005ffH
  0002a	50		 push	 eax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgets
  00031	83 c4 18	 add	 esp, 24			; 00000018H
  00034	85 c0		 test	 eax, eax
  00036	75 05		 jne	 SHORT $L1383

; 340  :         return( ERR_MPI_FILE_IO_ERROR );

  00038	6a 02		 push	 2
  0003a	58		 pop	 eax

; 352  : }

  0003b	c9		 leave
  0003c	c3		 ret	 0
$L1383:

; 341  : 
; 342  :     slen = strlen( s );

  0003d	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _strlen

; 343  :     if( s[slen - 1] == '\n' ) { slen--; s[slen] = '\0'; }

  00049	80 bc 05 fb f9
	ff ff 0a	 cmp	 BYTE PTR _s$[ebp+eax-1], 10 ; 0000000aH
  00051	59		 pop	 ecx
  00052	8d 8c 05 fc f9
	ff ff		 lea	 ecx, DWORD PTR _s$[ebp+eax]
  00059	75 10		 jne	 SHORT $L1384
  0005b	48		 dec	 eax
  0005c	80 a4 05 fc f9
	ff ff 00	 and	 BYTE PTR _s$[ebp+eax], 0
  00064	8d 8c 05 fc f9
	ff ff		 lea	 ecx, DWORD PTR _s$[ebp+eax]
$L1384:

; 344  :     if( s[slen - 1] == '\r' ) { slen--; s[slen] = '\0'; }

  0006b	80 79 ff 0d	 cmp	 BYTE PTR [ecx-1], 13	; 0000000dH
  0006f	75 0f		 jne	 SHORT $L1385
  00071	80 a4 05 fb f9
	ff ff 00	 and	 BYTE PTR _s$[ebp+eax-1], 0
  00079	8d 8c 05 fb f9
	ff ff		 lea	 ecx, DWORD PTR _s$[ebp+eax-1]
$L1385:
  00080	56		 push	 esi

; 348  :         if( mpi_get_digit( &d, radix, *p ) != 0 )
; 349  :             break;
; 350  : 
; 351  :     return( mpi_read_string( X, radix, p + 1 ) );

  00081	8d 71 ff	 lea	 esi, DWORD PTR [ecx-1]
$L2443:
  00084	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0008a	3b f0		 cmp	 esi, eax
  0008c	72 19		 jb	 SHORT $L2442
  0008e	8a 06		 mov	 al, BYTE PTR [esi]
  00090	50		 push	 eax
  00091	8d 45 fc	 lea	 eax, DWORD PTR _d$[ebp]
  00094	ff 75 0c	 push	 DWORD PTR _radix$[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _mpi_get_digit
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a0	85 c0		 test	 eax, eax
  000a2	75 03		 jne	 SHORT $L2442

; 345  : 
; 346  :     p = s + slen;
; 347  :     while( --p >= s )

  000a4	4e		 dec	 esi
  000a5	eb dd		 jmp	 SHORT $L2443
$L2442:

; 348  :         if( mpi_get_digit( &d, radix, *p ) != 0 )
; 349  :             break;
; 350  : 
; 351  :     return( mpi_read_string( X, radix, p + 1 ) );

  000a7	46		 inc	 esi
  000a8	56		 push	 esi
  000a9	ff 75 0c	 push	 DWORD PTR _radix$[ebp]
  000ac	ff 75 08	 push	 DWORD PTR _X$[ebp]
  000af	e8 00 00 00 00	 call	 _mpi_read_string
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b7	5e		 pop	 esi

; 352  : }

  000b8	c9		 leave
  000b9	c3		 ret	 0
_mpi_read_file ENDP
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
PUBLIC	??_C@_04DCMN@?$CFs?$CFs?$AA@			; `string'
PUBLIC	_mpi_write_file
EXTRN	__imp__fwrite:NEAR
EXTRN	__imp__printf:NEAR
;	COMDAT ??_C@_00A@?$AA@
; File E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\crypto\bignum.c
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??_C@_04DCMN@?$CFs?$CFs?$AA@
_DATA	SEGMENT
??_C@_04DCMN@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
_DATA	ENDS
;	COMDAT _mpi_write_file
_TEXT	SEGMENT
_p$ = 8
_X$ = 12
_radix$ = 16
_fout$ = 20
_slen$ = -4
_s$ = -1540
_mpi_write_file PROC NEAR				; COMDAT

; 358  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 06 00
	00		 sub	 esp, 1540		; 00000604H
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 359  :     int ret = 0;
; 360  :     size_t slen;
; 361  :     size_t plen;
; 362  :     char s[1536];
; 363  : 
; 364  :     slen = sizeof( s );

  0000b	b8 00 06 00 00	 mov	 eax, 1536		; 00000600H
  00010	57		 push	 edi
  00011	89 45 fc	 mov	 DWORD PTR _slen$[ebp], eax

; 365  :     memset( s, 0, slen );

  00014	50		 push	 eax
  00015	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0001b	6a 00		 push	 0
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _memset

; 366  :     slen -= 2;
; 367  : 
; 368  :     CHK( mpi_write_string( X, radix, s, (int *) &slen ) );

  00023	8d 45 fc	 lea	 eax, DWORD PTR _slen$[ebp]
  00026	83 6d fc 02	 sub	 DWORD PTR _slen$[ebp], 2
  0002a	50		 push	 eax
  0002b	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00031	50		 push	 eax
  00032	ff 75 10	 push	 DWORD PTR _radix$[ebp]
  00035	ff 75 0c	 push	 DWORD PTR _X$[ebp]
  00038	e8 00 00 00 00	 call	 _mpi_write_string
  0003d	8b d8		 mov	 ebx, eax
  0003f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00042	85 db		 test	 ebx, ebx
  00044	0f 85 87 00 00
	00		 jne	 $cleanup$1405

; 369  : 
; 370  :     if( p == NULL )

  0004a	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  0004d	85 f6		 test	 esi, esi
  0004f	75 05		 jne	 SHORT $L1407

; 371  :         p = "";

  00051	be 00 00 00 00	 mov	 esi, OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
$L1407:

; 372  : 
; 373  :     plen = strlen( p );

  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 _strlen
  0005c	8b f8		 mov	 edi, eax

; 374  :     slen = strlen( s );

  0005e	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _strlen

; 375  :     s[slen++] = '\r';

  0006a	c6 84 05 fc f9
	ff ff 0d	 mov	 BYTE PTR _s$[ebp+eax], 13 ; 0000000dH
  00072	40		 inc	 eax
  00073	59		 pop	 ecx

; 376  :     s[slen++] = '\n';

  00074	c6 84 05 fc f9
	ff ff 0a	 mov	 BYTE PTR _s$[ebp+eax], 10 ; 0000000aH
  0007c	40		 inc	 eax

; 377  : 
; 378  :     if( fout != NULL )

  0007d	83 7d 14 00	 cmp	 DWORD PTR _fout$[ebp], 0
  00081	59		 pop	 ecx
  00082	89 45 fc	 mov	 DWORD PTR _slen$[ebp], eax
  00085	74 34		 je	 SHORT $L1410

; 379  :     {
; 380  :         if( fwrite( p, 1, plen, fout ) != plen ||
; 381  :             fwrite( s, 1, slen, fout ) != slen )

  00087	ff 75 14	 push	 DWORD PTR _fout$[ebp]
  0008a	57		 push	 edi
  0008b	6a 01		 push	 1
  0008d	56		 push	 esi
  0008e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__fwrite
  00094	ff d6		 call	 esi
  00096	83 c4 10	 add	 esp, 16			; 00000010H
  00099	3b c7		 cmp	 eax, edi
  0009b	75 19		 jne	 SHORT $L1412
  0009d	ff 75 14	 push	 DWORD PTR _fout$[ebp]
  000a0	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  000a6	ff 75 fc	 push	 DWORD PTR _slen$[ebp]
  000a9	6a 01		 push	 1
  000ab	50		 push	 eax
  000ac	ff d6		 call	 esi
  000ae	83 c4 10	 add	 esp, 16			; 00000010H
  000b1	3b 45 fc	 cmp	 eax, DWORD PTR _slen$[ebp]
  000b4	74 1b		 je	 SHORT $cleanup$1405
$L1412:

; 382  :             return( ERR_MPI_FILE_IO_ERROR );

  000b6	6a 02		 push	 2
  000b8	58		 pop	 eax
  000b9	eb 18		 jmp	 SHORT $L1398
$L1410:

; 383  :     }
; 384  :     else
; 385  :         printf( "%s%s", p, s );

  000bb	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  000c1	50		 push	 eax
  000c2	56		 push	 esi
  000c3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04DCMN@?$CFs?$CFs?$AA@ ; `string'
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
$cleanup$1405:

; 386  : 
; 387  : cleanup:
; 388  : 
; 389  :     return( ret );

  000d1	8b c3		 mov	 eax, ebx
$L1398:
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx

; 390  : }

  000d6	c9		 leave
  000d7	c3		 ret	 0
_mpi_write_file ENDP
_TEXT	ENDS
PUBLIC	_mpi_read_binary
;	COMDAT _mpi_read_binary
_TEXT	SEGMENT
_X$ = 8
_buf$ = 12
_buflen$ = 16
_ret$ = -8
_j$ = 16
_n$ = -4
_mpi_read_binary PROC NEAR				; COMDAT

; 396  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi

; 397  :     int ret, i, j, n;
; 398  : 
; 399  :     for( n = 0; n < buflen; n++ )

  00008	8b 7d 10	 mov	 edi, DWORD PTR _buflen$[ebp]
  0000b	33 db		 xor	 ebx, ebx
  0000d	33 f6		 xor	 esi, esi
  0000f	3b fb		 cmp	 edi, ebx
  00011	89 75 fc	 mov	 DWORD PTR _n$[ebp], esi
  00014	7e 10		 jle	 SHORT $L2449
$L1426:

; 400  :         if( buf[n] != 0 )

  00016	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00019	38 1c 06	 cmp	 BYTE PTR [esi+eax], bl
  0001c	75 08		 jne	 SHORT $L2449
  0001e	46		 inc	 esi
  0001f	3b f7		 cmp	 esi, edi
  00021	89 75 fc	 mov	 DWORD PTR _n$[ebp], esi
  00024	7c f0		 jl	 SHORT $L1426
$L2449:

; 401  :             break;
; 402  : 
; 403  :     CHK( mpi_grow( X, CHARS_TO_LIMBS( buflen - n ) ) );

  00026	8b c7		 mov	 eax, edi
  00028	6a 04		 push	 4
  0002a	2b c6		 sub	 eax, esi
  0002c	59		 pop	 ecx
  0002d	83 c0 03	 add	 eax, 3
  00030	99		 cdq
  00031	f7 f9		 idiv	 ecx
  00033	50		 push	 eax
  00034	ff 75 08	 push	 DWORD PTR _X$[ebp]
  00037	e8 00 00 00 00	 call	 _mpi_grow
  0003c	59		 pop	 ecx
  0003d	3b c3		 cmp	 eax, ebx
  0003f	59		 pop	 ecx
  00040	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  00043	75 4e		 jne	 SHORT $cleanup$1435

; 404  :     CHK( mpi_lset( X, 0 ) );

  00045	53		 push	 ebx
  00046	ff 75 08	 push	 DWORD PTR _X$[ebp]
  00049	e8 00 00 00 00	 call	 _mpi_lset
  0004e	59		 pop	 ecx
  0004f	3b c3		 cmp	 eax, ebx
  00051	59		 pop	 ecx
  00052	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  00055	75 3c		 jne	 SHORT $cleanup$1435

; 405  : 
; 406  :     for( i = buflen - 1, j = 0; i >= n; i--, j++ )

  00057	4f		 dec	 edi
  00058	89 5d 10	 mov	 DWORD PTR _j$[ebp], ebx
  0005b	3b fe		 cmp	 edi, esi
  0005d	7c 34		 jl	 SHORT $cleanup$1435
$L1437:

; 407  :         X->p[j / ciL] |= (t_int)( buf[i] << ((j % ciL) << 3) );

  0005f	8b 45 10	 mov	 eax, DWORD PTR _j$[ebp]
  00062	6a 04		 push	 4
  00064	99		 cdq
  00065	59		 pop	 ecx
  00066	f7 f9		 idiv	 ecx
  00068	8b 4d 08	 mov	 ecx, DWORD PTR _X$[ebp]
  0006b	6a 04		 push	 4
  0006d	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00070	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  00073	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00076	59		 pop	 ecx
  00077	0f b6 1c 07	 movzx	 ebx, BYTE PTR [edi+eax]
  0007b	8b 45 10	 mov	 eax, DWORD PTR _j$[ebp]
  0007e	99		 cdq
  0007f	f7 f9		 idiv	 ecx
  00081	8b ca		 mov	 ecx, edx
  00083	c1 e1 03	 shl	 ecx, 3
  00086	d3 e3		 shl	 ebx, cl
  00088	09 1e		 or	 DWORD PTR [esi], ebx
  0008a	4f		 dec	 edi
  0008b	ff 45 10	 inc	 DWORD PTR _j$[ebp]
  0008e	3b 7d fc	 cmp	 edi, DWORD PTR _n$[ebp]
  00091	7d cc		 jge	 SHORT $L1437
$cleanup$1435:

; 408  : 
; 409  : cleanup:
; 410  : 
; 411  :     return( ret );

  00093	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx

; 412  : }

  00099	c9		 leave
  0009a	c3		 ret	 0
_mpi_read_binary ENDP
_TEXT	ENDS
PUBLIC	_mpi_write_binary
;	COMDAT _mpi_write_binary
_TEXT	SEGMENT
_X$ = 8
_buf$ = 12
_buflen$ = 16
_j$ = 16
_mpi_write_binary PROC NEAR				; COMDAT

; 418  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 419  :     int i, j, n;
; 420  : 
; 421  :     n = ( mpi_msb( X ) + 7 ) >> 3;

  00005	ff 75 08	 push	 DWORD PTR _X$[ebp]
  00008	e8 00 00 00 00	 call	 _mpi_msb

; 422  : 
; 423  :     if( *buflen < n )

  0000d	8b 7d 10	 mov	 edi, DWORD PTR _buflen$[ebp]
  00010	8b f0		 mov	 esi, eax
  00012	83 c6 07	 add	 esi, 7
  00015	59		 pop	 ecx
  00016	8b 07		 mov	 eax, DWORD PTR [edi]
  00018	c1 fe 03	 sar	 esi, 3
  0001b	3b c6		 cmp	 eax, esi
  0001d	7d 07		 jge	 SHORT $L1455

; 424  :     {
; 425  :         *buflen = n;
; 426  :         return( ERR_MPI_BUFFER_TOO_SMALL );

  0001f	6a 08		 push	 8
  00021	89 37		 mov	 DWORD PTR [edi], esi
  00023	58		 pop	 eax
  00024	eb 50		 jmp	 SHORT $L1451
$L1455:
  00026	53		 push	 ebx

; 427  :     }
; 428  : 
; 429  :     memset( buf, 0, *buflen );

  00027	8b 5d 0c	 mov	 ebx, DWORD PTR _buf$[ebp]
  0002a	50		 push	 eax
  0002b	6a 00		 push	 0
  0002d	53		 push	 ebx
  0002e	e8 00 00 00 00	 call	 _memset

; 430  : 
; 431  :     for( i = *buflen - 1, j = 0; n > 0; i--, j++, n-- )

  00033	8b 07		 mov	 eax, DWORD PTR [edi]
  00035	83 65 10 00	 and	 DWORD PTR _j$[ebp], 0
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	48		 dec	 eax
  0003d	85 f6		 test	 esi, esi
  0003f	7e 32		 jle	 SHORT $L1458
  00041	8d 3c 18	 lea	 edi, DWORD PTR [eax+ebx]
  00044	89 75 0c	 mov	 DWORD PTR 12+[ebp], esi
$L1456:

; 432  :         buf[i] = (unsigned char)( X->p[j / ciL] >> ((j % ciL) << 3) );

  00047	8b 45 10	 mov	 eax, DWORD PTR _j$[ebp]
  0004a	6a 04		 push	 4
  0004c	99		 cdq
  0004d	59		 pop	 ecx
  0004e	f7 f9		 idiv	 ecx
  00050	8b f0		 mov	 esi, eax
  00052	8b 45 08	 mov	 eax, DWORD PTR _X$[ebp]
  00055	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  00058	8b 45 10	 mov	 eax, DWORD PTR _j$[ebp]
  0005b	99		 cdq
  0005c	f7 f9		 idiv	 ecx
  0005e	8b 04 b3	 mov	 eax, DWORD PTR [ebx+esi*4]
  00061	8b ca		 mov	 ecx, edx
  00063	c1 e1 03	 shl	 ecx, 3
  00066	d3 e8		 shr	 eax, cl
  00068	88 07		 mov	 BYTE PTR [edi], al
  0006a	4f		 dec	 edi
  0006b	ff 45 10	 inc	 DWORD PTR _j$[ebp]
  0006e	ff 4d 0c	 dec	 DWORD PTR 12+[ebp]
  00071	75 d4		 jne	 SHORT $L1456
$L1458:

; 433  : 
; 434  :     return( 0 );

  00073	33 c0		 xor	 eax, eax
  00075	5b		 pop	 ebx
$L1451:
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi

; 435  : }

  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_mpi_write_binary ENDP
_TEXT	ENDS
;	COMDAT _mpi_msb
_TEXT	SEGMENT
_X$ = 8
_mpi_msb PROC NEAR					; COMDAT

; 442  :     int i, j;
; 443  : 
; 444  :     for( i = X->n - 1; i > 0; i-- )

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _X$[esp-4]
  00004	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00007	48		 dec	 eax
  00008	85 c0		 test	 eax, eax
  0000a	7e 13		 jle	 SHORT $L2460
  0000c	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0000f	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
$L1469:

; 445  :         if( X->p[i] != 0 )

  00012	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00015	75 08		 jne	 SHORT $L2460
  00017	48		 dec	 eax
  00018	83 e9 04	 sub	 ecx, 4
  0001b	85 c0		 test	 eax, eax
  0001d	7f f3		 jg	 SHORT $L1469
$L2460:

; 449  :         if( ( ( X->p[i] >> j ) & 1 ) != 0 )

  0001f	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	6a 1f		 push	 31			; 0000001fH
  00026	8b 3c 81	 mov	 edi, DWORD PTR [ecx+eax*4]
  00029	5e		 pop	 esi
$L1475:
  0002a	8b d7		 mov	 edx, edi
  0002c	8b ce		 mov	 ecx, esi
  0002e	d3 ea		 shr	 edx, cl
  00030	f6 c2 01	 test	 dl, 1
  00033	75 03		 jne	 SHORT $L2461

; 446  :             break;
; 447  : 
; 448  :     for( j = biL - 1; j >= 0; j-- )

  00035	4e		 dec	 esi
  00036	79 f2		 jns	 SHORT $L1475
$L2461:

; 450  :             break;
; 451  : 
; 452  :     return( ( i * biL ) + j + 1 );

  00038	c1 e0 05	 shl	 eax, 5
  0003b	5f		 pop	 edi
  0003c	8d 44 30 01	 lea	 eax, DWORD PTR [eax+esi+1]
  00040	5e		 pop	 esi

; 453  : }

  00041	c3		 ret	 0
_mpi_msb ENDP
_TEXT	ENDS
PUBLIC	_mpi_lsb
;	COMDAT _mpi_lsb
_TEXT	SEGMENT
_X$ = 8
_count$ = -4
_mpi_lsb PROC NEAR					; COMDAT

; 459  : {

  00000	51		 push	 ecx

; 461  : 
; 462  :     for( i = 0; i < X->n; i++ )

  00001	8b 4c 24 08	 mov	 ecx, DWORD PTR _X$[esp]
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000b	33 db		 xor	 ebx, ebx
  0000d	3b f3		 cmp	 esi, ebx
  0000f	57		 push	 edi
  00010	89 5c 24 10	 mov	 DWORD PTR _count$[esp+20], ebx
  00014	7e 23		 jle	 SHORT $L1489

; 460  :     int i, j, count = 0;

  00016	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
$L1487:

; 463  :         for( j = 0; j < (int) biL; j++, count++ )
; 464  :             if( ( ( X->p[i] >> j ) & 1 ) != 0 )

  00019	8b 2a		 mov	 ebp, DWORD PTR [edx]
  0001b	33 ff		 xor	 edi, edi
$L1493:
  0001d	8b c5		 mov	 eax, ebp
  0001f	8b cf		 mov	 ecx, edi
  00021	d3 e8		 shr	 eax, cl
  00023	a8 01		 test	 al, 1
  00025	75 1a		 jne	 SHORT $L2468
  00027	47		 inc	 edi
  00028	ff 44 24 10	 inc	 DWORD PTR _count$[esp+20]
  0002c	83 ff 20	 cmp	 edi, 32			; 00000020H
  0002f	7c ec		 jl	 SHORT $L1493
  00031	43		 inc	 ebx
  00032	83 c2 04	 add	 edx, 4
  00035	3b de		 cmp	 ebx, esi
  00037	7c e0		 jl	 SHORT $L1487
$L1489:

; 466  : 
; 467  :     return( 0 );

  00039	33 c0		 xor	 eax, eax
$L1483:
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5d		 pop	 ebp
  0003e	5b		 pop	 ebx

; 468  : }

  0003f	59		 pop	 ecx
  00040	c3		 ret	 0
$L2468:

; 465  :                 return( count );

  00041	8b 44 24 10	 mov	 eax, DWORD PTR _count$[esp+20]
  00045	eb f4		 jmp	 SHORT $L1483
_mpi_lsb ENDP
_TEXT	ENDS
PUBLIC	_mpi_shift_l
;	COMDAT _mpi_shift_l
_TEXT	SEGMENT
_X$ = 8
_count$ = 12
_ret$ = 8
_v0$ = -4
_t1$ = -8
_r0$ = -12
_mpi_shift_l PROC NEAR					; COMDAT

; 474  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 475  :     int ret, i, v0, t1;
; 476  :     t_int r0 = 0, r1;
; 477  : 
; 478  :     v0 = count /  biL;

  00009	8b 7d 0c	 mov	 edi, DWORD PTR _count$[ebp]
  0000c	8b c7		 mov	 eax, edi
  0000e	6a 20		 push	 32			; 00000020H
  00010	99		 cdq
  00011	59		 pop	 ecx

; 479  :     t1 = count & (biL - 1);
; 480  : 
; 481  :     i = mpi_msb( X ) + count;

  00012	8b 75 08	 mov	 esi, DWORD PTR _X$[ebp]
  00015	f7 f9		 idiv	 ecx
  00017	83 65 f4 00	 and	 DWORD PTR _r0$[ebp], 0
  0001b	83 e7 1f	 and	 edi, 31			; 0000001fH
  0001e	56		 push	 esi
  0001f	89 7d f8	 mov	 DWORD PTR _t1$[ebp], edi
  00022	8b d8		 mov	 ebx, eax
  00024	89 5d fc	 mov	 DWORD PTR _v0$[ebp], ebx
  00027	e8 00 00 00 00	 call	 _mpi_msb
  0002c	03 45 0c	 add	 eax, DWORD PTR _count$[ebp]
  0002f	59		 pop	 ecx

; 482  : 
; 483  :     if( X->n * (int) biL < i )

  00030	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00033	c1 e1 05	 shl	 ecx, 5
  00036	3b c8		 cmp	 ecx, eax
  00038	7d 1d		 jge	 SHORT $L1520

; 484  :         CHK( mpi_grow( X, BITS_TO_LIMBS( i ) ) );

  0003a	83 c0 1f	 add	 eax, 31			; 0000001fH
  0003d	6a 20		 push	 32			; 00000020H
  0003f	99		 cdq
  00040	59		 pop	 ecx
  00041	f7 f9		 idiv	 ecx
  00043	50		 push	 eax
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 _mpi_grow
  0004a	59		 pop	 ecx
  0004b	89 45 08	 mov	 DWORD PTR _ret$[ebp], eax
  0004e	85 c0		 test	 eax, eax
  00050	59		 pop	 ecx
  00051	0f 85 89 00 00
	00		 jne	 $cleanup$1521
$L1520:

; 485  : 
; 486  :     ret = 0;

  00057	83 65 08 00	 and	 DWORD PTR _ret$[ebp], 0

; 487  : 
; 488  :     /*
; 489  :      * shift by count / limb_size
; 490  :      */
; 491  :     if( v0 > 0 )

  0005b	85 db		 test	 ebx, ebx
  0005d	7e 42		 jle	 SHORT $L1528

; 492  :     {
; 493  :         for( i = X->n - 1; i >= v0; i-- )

  0005f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00062	48		 dec	 eax
  00063	3b c3		 cmp	 eax, ebx
  00065	7c 2c		 jl	 SHORT $L1525
  00067	8b d8		 mov	 ebx, eax
  00069	8b f8		 mov	 edi, eax
  0006b	2b 5d fc	 sub	 ebx, DWORD PTR _v0$[ebp]
  0006e	c1 e7 02	 shl	 edi, 2
  00071	43		 inc	 ebx
  00072	2b c3		 sub	 eax, ebx
$L1523:

; 494  :             X->p[i] = X->p[i - v0];

  00074	8b 55 fc	 mov	 edx, DWORD PTR _v0$[ebp]
  00077	8b cf		 mov	 ecx, edi
  00079	c1 e2 02	 shl	 edx, 2
  0007c	2b ca		 sub	 ecx, edx
  0007e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00081	8b 0c 11	 mov	 ecx, DWORD PTR [ecx+edx]
  00084	89 0c 17	 mov	 DWORD PTR [edi+edx], ecx
  00087	83 ef 04	 sub	 edi, 4
  0008a	4b		 dec	 ebx
  0008b	75 e7		 jne	 SHORT $L1523
  0008d	8b 7d f8	 mov	 edi, DWORD PTR _t1$[ebp]
  00090	8b 5d fc	 mov	 ebx, DWORD PTR _v0$[ebp]
$L1525:

; 495  : 
; 496  :         for( ; i >= 0; i-- )

  00093	85 c0		 test	 eax, eax
  00095	7c 0a		 jl	 SHORT $L1528
$L1526:

; 497  :             X->p[i] = 0;

  00097	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0009a	83 24 81 00	 and	 DWORD PTR [ecx+eax*4], 0
  0009e	48		 dec	 eax
  0009f	79 f6		 jns	 SHORT $L1526
$L1528:

; 498  :     }
; 499  : 
; 500  :     /*
; 501  :      * shift by count % limb_size
; 502  :      */
; 503  :     if( t1 > 0 )

  000a1	85 ff		 test	 edi, edi
  000a3	7e 3b		 jle	 SHORT $cleanup$1521

; 504  :     {
; 505  :         for( i = v0; i < X->n; i++ )

  000a5	3b 5e 04	 cmp	 ebx, DWORD PTR [esi+4]
  000a8	7d 36		 jge	 SHORT $cleanup$1521

; 506  :         {
; 507  :             r1 = X->p[i] >> (biL - t1);

  000aa	c7 45 0c 20 00
	00 00		 mov	 DWORD PTR 12+[ebp], 32	; 00000020H
  000b1	29 7d 0c	 sub	 DWORD PTR 12+[ebp], edi
$L1530:
  000b4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b7	8b 4d 0c	 mov	 ecx, DWORD PTR 12+[ebp]
  000ba	8b 14 98	 mov	 edx, DWORD PTR [eax+ebx*4]
  000bd	8d 3c 98	 lea	 edi, DWORD PTR [eax+ebx*4]
  000c0	8b c2		 mov	 eax, edx
  000c2	d3 e8		 shr	 eax, cl

; 508  :             X->p[i] <<= t1;

  000c4	8b 4d f8	 mov	 ecx, DWORD PTR _t1$[ebp]
  000c7	d3 e2		 shl	 edx, cl
  000c9	89 17		 mov	 DWORD PTR [edi], edx
  000cb	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 509  :             X->p[i] |= r0;

  000ce	8b 55 f4	 mov	 edx, DWORD PTR _r0$[ebp]

; 510  :             r0 = r1;

  000d1	89 45 f4	 mov	 DWORD PTR _r0$[ebp], eax
  000d4	09 14 99	 or	 DWORD PTR [ecx+ebx*4], edx
  000d7	8d 0c 99	 lea	 ecx, DWORD PTR [ecx+ebx*4]
  000da	43		 inc	 ebx
  000db	3b 5e 04	 cmp	 ebx, DWORD PTR [esi+4]
  000de	7c d4		 jl	 SHORT $L1530
$cleanup$1521:

; 511  :         }
; 512  :     }
; 513  : 
; 514  : cleanup:
; 515  : 
; 516  :     return( ret );

  000e0	8b 45 08	 mov	 eax, DWORD PTR _ret$[ebp]
  000e3	5f		 pop	 edi
  000e4	5e		 pop	 esi
  000e5	5b		 pop	 ebx

; 517  : }

  000e6	c9		 leave
  000e7	c3		 ret	 0
_mpi_shift_l ENDP
_TEXT	ENDS
PUBLIC	_mpi_shift_r
;	COMDAT _mpi_shift_r
_TEXT	SEGMENT
_X$ = 8
_count$ = 12
_v1$ = 12
_r0$ = -4
_mpi_shift_r PROC NEAR					; COMDAT

; 523  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 524  :     int i, v0, v1;
; 525  :     t_int r0 = 0, r1;
; 526  : 
; 527  :     v0 = count /  biL;

  00004	8b 4d 0c	 mov	 ecx, DWORD PTR _count$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b c1		 mov	 eax, ecx
  0000c	6a 20		 push	 32			; 00000020H
  0000e	99		 cdq
  0000f	5e		 pop	 esi
  00010	83 65 fc 00	 and	 DWORD PTR _r0$[ebp], 0
  00014	f7 fe		 idiv	 esi

; 528  :     v1 = count & (biL - 1);
; 529  : 
; 530  :     /*
; 531  :      * shift by count / limb_size
; 532  :      */
; 533  :     if( v0 > 0 )

  00016	8b 55 08	 mov	 edx, DWORD PTR _X$[ebp]
  00019	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0001c	89 4d 0c	 mov	 DWORD PTR _v1$[ebp], ecx
  0001f	85 c0		 test	 eax, eax
  00021	7e 35		 jle	 SHORT $L1555

; 534  :     {
; 535  :         for( i = 0; i < X->n - v0; i++ )

  00023	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00026	33 c9		 xor	 ecx, ecx
  00028	2b f0		 sub	 esi, eax
  0002a	85 f6		 test	 esi, esi
  0002c	7e 1b		 jle	 SHORT $L2494
  0002e	8b f8		 mov	 edi, eax
  00030	c1 e7 02	 shl	 edi, 2
$L1550:

; 536  :             X->p[i] = X->p[i + v0];

  00033	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00036	8b 1c 37	 mov	 ebx, DWORD PTR [edi+esi]
  00039	83 c7 04	 add	 edi, 4
  0003c	89 1c 8e	 mov	 DWORD PTR [esi+ecx*4], ebx
  0003f	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00042	41		 inc	 ecx
  00043	2b f0		 sub	 esi, eax
  00045	3b ce		 cmp	 ecx, esi
  00047	7c ea		 jl	 SHORT $L1550
$L2494:

; 537  : 
; 538  :         for( ; i < X->n; i++ )

  00049	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  0004c	7d 0a		 jge	 SHORT $L1555

; 539  :             X->p[i] = 0;

  0004e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00051	83 24 88 00	 and	 DWORD PTR [eax+ecx*4], 0
  00055	41		 inc	 ecx
  00056	eb f1		 jmp	 SHORT $L2494
$L1555:

; 540  :     }
; 541  : 
; 542  :     /*
; 543  :      * shift by count % limb_size
; 544  :      */
; 545  :     if( v1 > 0 )

  00058	83 7d 0c 00	 cmp	 DWORD PTR _v1$[ebp], 0
  0005c	7e 38		 jle	 SHORT $L1559

; 546  :     {
; 547  :         for( i = X->n - 1; i >= 0; i-- )

  0005e	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00061	4b		 dec	 ebx
  00062	78 32		 js	 SHORT $L1559

; 548  :         {
; 549  :             r1 = X->p[i] << (biL - v1);

  00064	6a 20		 push	 32			; 00000020H
  00066	58		 pop	 eax
  00067	2b 45 0c	 sub	 eax, DWORD PTR _v1$[ebp]
  0006a	89 45 08	 mov	 DWORD PTR 8+[ebp], eax
$L1557:
  0006d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00070	8b 4d 08	 mov	 ecx, DWORD PTR 8+[ebp]
  00073	8d 34 98	 lea	 esi, DWORD PTR [eax+ebx*4]
  00076	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]
  00079	8b f8		 mov	 edi, eax
  0007b	d3 e7		 shl	 edi, cl

; 550  :             X->p[i] >>= v1;

  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR _v1$[ebp]
  00080	d3 e8		 shr	 eax, cl

; 551  :             X->p[i] |= r0;

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _r0$[ebp]

; 552  :             r0 = r1;

  00085	89 7d fc	 mov	 DWORD PTR _r0$[ebp], edi
  00088	89 06		 mov	 DWORD PTR [esi], eax
  0008a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0008d	09 0c 98	 or	 DWORD PTR [eax+ebx*4], ecx
  00090	8d 04 98	 lea	 eax, DWORD PTR [eax+ebx*4]
  00093	4b		 dec	 ebx
  00094	79 d7		 jns	 SHORT $L1557
$L1559:
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi

; 553  :         }
; 554  :     }
; 555  : 
; 556  :     return( 0 );

  00098	33 c0		 xor	 eax, eax
  0009a	5b		 pop	 ebx

; 557  : }

  0009b	c9		 leave
  0009c	c3		 ret	 0
_mpi_shift_r ENDP
_TEXT	ENDS
PUBLIC	_mpi_cmp_abs
;	COMDAT _mpi_cmp_abs
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_mpi_cmp_abs PROC NEAR					; COMDAT

; 563  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 564  :     int i, j;
; 565  : 
; 566  :     for( i = X->n - 1; i >= 0; i-- )

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _X$[esp+4]
  00006	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00009	48		 dec	 eax
  0000a	78 13		 js	 SHORT $L2499
  0000c	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0000f	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
$L1569:

; 567  :         if( X->p[i] != 0 )

  00012	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00015	75 08		 jne	 SHORT $L2499
  00017	48		 dec	 eax
  00018	83 e9 04	 sub	 ecx, 4
  0001b	85 c0		 test	 eax, eax
  0001d	7d f3		 jge	 SHORT $L1569
$L2499:

; 568  :             break;
; 569  : 
; 570  :     for( j = Y->n - 1; j >= 0; j-- )

  0001f	8b 74 24 10	 mov	 esi, DWORD PTR _Y$[esp+4]
  00023	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00026	49		 dec	 ecx
  00027	78 13		 js	 SHORT $L2500
  00029	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002c	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
$L1573:

; 571  :         if( Y->p[j] != 0 )

  0002f	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00032	75 08		 jne	 SHORT $L2500
  00034	49		 dec	 ecx
  00035	83 ea 04	 sub	 edx, 4
  00038	85 c9		 test	 ecx, ecx
  0003a	7d f3		 jge	 SHORT $L1573
$L2500:

; 572  :             break;
; 573  : 
; 574  :     if( i < 0 && j < 0 )

  0003c	85 c0		 test	 eax, eax
  0003e	7d 04		 jge	 SHORT $L1577
  00040	85 c9		 test	 ecx, ecx

; 575  :         return( 0 );

  00042	7c 28		 jl	 SHORT $L1582
$L1577:

; 576  : 
; 577  :     if( i > j ) return(  1 );

  00044	3b c8		 cmp	 ecx, eax
  00046	7c 29		 jl	 SHORT $L2501

; 578  :     if( j > i ) return( -1 );

  00048	7f 2c		 jg	 SHORT $L2502

; 579  : 
; 580  :     for( ; i >= 0; i-- )

  0004a	85 c0		 test	 eax, eax
  0004c	7c 1e		 jl	 SHORT $L1582

; 581  :     {
; 582  :         if( X->p[i] > Y->p[i] ) return(  1 );

  0004e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00051	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00054	2b f2		 sub	 esi, edx
  00056	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
$L1580:
  00059	8b 14 0e	 mov	 edx, DWORD PTR [esi+ecx]
  0005c	8b 39		 mov	 edi, DWORD PTR [ecx]
  0005e	3b d7		 cmp	 edx, edi
  00060	77 0f		 ja	 SHORT $L2501

; 583  :         if( X->p[i] < Y->p[i] ) return( -1 );

  00062	72 12		 jb	 SHORT $L2502
  00064	48		 dec	 eax
  00065	83 e9 04	 sub	 ecx, 4
  00068	85 c0		 test	 eax, eax
  0006a	7d ed		 jge	 SHORT $L1580
$L1582:

; 584  :     }
; 585  : 
; 586  :     return( 0 );

  0006c	33 c0		 xor	 eax, eax
$L1566:
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi

; 587  : }

  00070	c3		 ret	 0
$L2501:
  00071	6a 01		 push	 1
  00073	58		 pop	 eax
  00074	eb f8		 jmp	 SHORT $L1566
$L2502:

; 583  :         if( X->p[i] < Y->p[i] ) return( -1 );

  00076	83 c8 ff	 or	 eax, -1
  00079	eb f3		 jmp	 SHORT $L1566
_mpi_cmp_abs ENDP
_TEXT	ENDS
PUBLIC	_mpi_cmp_mpi
;	COMDAT _mpi_cmp_mpi
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_mpi_cmp_mpi PROC NEAR					; COMDAT

; 593  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 594  :     int i, j;
; 595  : 
; 596  :     for( i = X->n - 1; i >= 0; i-- )

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR _X$[esp+8]
  00007	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000a	49		 dec	 ecx
  0000b	78 13		 js	 SHORT $L2512
  0000d	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00010	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
$L1592:

; 597  :         if( X->p[i] != 0 )

  00013	83 38 00	 cmp	 DWORD PTR [eax], 0
  00016	75 08		 jne	 SHORT $L2512
  00018	49		 dec	 ecx
  00019	83 e8 04	 sub	 eax, 4
  0001c	85 c9		 test	 ecx, ecx
  0001e	7d f3		 jge	 SHORT $L1592
$L2512:

; 598  :             break;
; 599  : 
; 600  :     for( j = Y->n - 1; j >= 0; j-- )

  00020	8b 54 24 14	 mov	 edx, DWORD PTR _Y$[esp+8]
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	48		 dec	 eax
  00028	78 13		 js	 SHORT $L2513
  0002a	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  0002d	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]
$L1596:

; 601  :         if( Y->p[j] != 0 )

  00030	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00033	75 08		 jne	 SHORT $L2513
  00035	48		 dec	 eax
  00036	83 ee 04	 sub	 esi, 4
  00039	85 c0		 test	 eax, eax
  0003b	7d f3		 jge	 SHORT $L1596
$L2513:

; 602  :             break;
; 603  : 
; 604  :     if( i < 0 && j < 0 )

  0003d	85 c9		 test	 ecx, ecx
  0003f	7d 04		 jge	 SHORT $L1600
  00041	85 c0		 test	 eax, eax

; 605  :         return( 0 );

  00043	7c 4e		 jl	 SHORT $L1607
$L1600:

; 606  : 
; 607  :     if( i > j ) return(  X->s );

  00045	3b c1		 cmp	 eax, ecx
  00047	7d 04		 jge	 SHORT $L2521
  00049	8b 07		 mov	 eax, DWORD PTR [edi]
  0004b	eb 48		 jmp	 SHORT $L1589
$L2521:

; 608  :     if( j > i ) return( -X->s );

  0004d	7e 04		 jle	 SHORT $L1602
  0004f	8b 07		 mov	 eax, DWORD PTR [edi]
  00051	eb 4c		 jmp	 SHORT $L2523
$L1602:

; 609  : 
; 610  :     if( X->s > 0 && Y->s < 0 ) return(  1 );

  00053	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00055	85 db		 test	 ebx, ebx
  00057	7e 0a		 jle	 SHORT $L1603
  00059	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0005c	7d 08		 jge	 SHORT $L2522
  0005e	6a 01		 push	 1
  00060	58		 pop	 eax
  00061	eb 32		 jmp	 SHORT $L1589
$L1603:

; 611  :     if( Y->s > 0 && X->s < 0 ) return( -1 );

  00063	83 3a 00	 cmp	 DWORD PTR [edx], 0
$L2522:
  00066	7e 09		 jle	 SHORT $L1604
  00068	85 db		 test	 ebx, ebx
  0006a	7d 05		 jge	 SHORT $L1604
  0006c	83 c8 ff	 or	 eax, -1
  0006f	eb 24		 jmp	 SHORT $L1589
$L1604:

; 612  : 
; 613  :     for( ; i >= 0; i-- )

  00071	85 c9		 test	 ecx, ecx
  00073	7c 1e		 jl	 SHORT $L1607

; 614  :     {
; 615  :         if( X->p[i] > Y->p[i] ) return(  X->s );

  00075	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00078	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  0007b	2b fe		 sub	 edi, esi
  0007d	8d 14 8e	 lea	 edx, DWORD PTR [esi+ecx*4]
$L1605:
  00080	8b 34 17	 mov	 esi, DWORD PTR [edi+edx]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	3b f0		 cmp	 esi, eax
  00087	77 10		 ja	 SHORT $L2514

; 616  :         if( X->p[i] < Y->p[i] ) return( -X->s );

  00089	72 12		 jb	 SHORT $L2515
  0008b	49		 dec	 ecx
  0008c	83 ea 04	 sub	 edx, 4
  0008f	85 c9		 test	 ecx, ecx
  00091	7d ed		 jge	 SHORT $L1605
$L1607:

; 617  :     }
; 618  : 
; 619  :     return( 0 );

  00093	33 c0		 xor	 eax, eax
$L1589:
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx

; 620  : }

  00098	c3		 ret	 0
$L2514:

; 614  :     {
; 615  :         if( X->p[i] > Y->p[i] ) return(  X->s );

  00099	8b c3		 mov	 eax, ebx
  0009b	eb f8		 jmp	 SHORT $L1589
$L2515:

; 616  :         if( X->p[i] < Y->p[i] ) return( -X->s );

  0009d	8b c3		 mov	 eax, ebx
$L2523:
  0009f	f7 d8		 neg	 eax
  000a1	eb f2		 jmp	 SHORT $L1589
_mpi_cmp_mpi ENDP
_TEXT	ENDS
;	COMDAT _mpi_cmp_int
_TEXT	SEGMENT
_X$ = 8
_z$ = 12
_Y$ = -12
_p$ = 12
_mpi_cmp_int PROC NEAR					; COMDAT

; 626  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 627  :     mpi Y;
; 628  :     t_int p[1];
; 629  : 
; 630  :     *p  = ( z < 0 ) ? -z : z;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _z$[ebp]
  00009	85 c0		 test	 eax, eax
  0000b	7d 09		 jge	 SHORT $L2526
  0000d	8b c8		 mov	 ecx, eax
  0000f	f7 d9		 neg	 ecx
  00011	89 4d 0c	 mov	 DWORD PTR _p$[ebp], ecx
  00014	eb 03		 jmp	 SHORT $L2527
$L2526:
  00016	89 45 0c	 mov	 DWORD PTR _p$[ebp], eax
$L2527:

; 631  :     Y.s = ( z < 0 ) ? -1 : 1;

  00019	33 c9		 xor	 ecx, ecx

; 632  :     Y.n = 1;

  0001b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _Y$[ebp+4], 1
  00022	85 c0		 test	 eax, eax

; 633  :     Y.p = p;

  00024	8d 45 0c	 lea	 eax, DWORD PTR _p$[ebp]
  00027	0f 9d c1	 setge	 cl
  0002a	89 45 fc	 mov	 DWORD PTR _Y$[ebp+8], eax
  0002d	49		 dec	 ecx

; 634  : 
; 635  :     return( mpi_cmp_mpi( X, &Y ) );

  0002e	8d 45 f4	 lea	 eax, DWORD PTR _Y$[ebp]
  00031	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00034	50		 push	 eax
  00035	41		 inc	 ecx
  00036	ff 75 08	 push	 DWORD PTR _X$[ebp]
  00039	89 4d f4	 mov	 DWORD PTR _Y$[ebp], ecx
  0003c	e8 00 00 00 00	 call	 _mpi_cmp_mpi
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 636  : }

  00043	c9		 leave
  00044	c3		 ret	 0
_mpi_cmp_int ENDP
_TEXT	ENDS
PUBLIC	_mpi_add_abs
;	COMDAT _mpi_add_abs
_TEXT	SEGMENT
_X$ = 8
_A$ = 12
_B$ = 16
_ret$ = 8
_i$ = 12
_mpi_add_abs PROC NEAR					; COMDAT

; 642  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 643  :     int ret, i, j;
; 644  :     t_int *o, *p, c;
; 645  : 
; 646  :     if( X == B )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _X$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _B$[ebp]
  0000b	3b de		 cmp	 ebx, esi
  0000d	75 06		 jne	 SHORT $L1630

; 647  :     {
; 648  :         mpi *T = A; A = X; B = T;

  0000f	8b 75 0c	 mov	 esi, DWORD PTR _A$[ebp]
  00012	89 5d 0c	 mov	 DWORD PTR _A$[ebp], ebx
$L1630:

; 649  :     }
; 650  : 
; 651  :     if( X != A )

  00015	3b 5d 0c	 cmp	 ebx, DWORD PTR _A$[ebp]
  00018	74 16		 je	 SHORT $L1633

; 652  :         CHK( mpi_copy( X, A ) );

  0001a	ff 75 0c	 push	 DWORD PTR _A$[ebp]
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 _mpi_copy
  00023	59		 pop	 ecx
  00024	89 45 08	 mov	 DWORD PTR _ret$[ebp], eax
  00027	85 c0		 test	 eax, eax
  00029	59		 pop	 ecx
  0002a	0f 85 9d 00 00
	00		 jne	 $cleanup$1634
$L1633:
  00030	57		 push	 edi

; 653  : 
; 654  :     for( j = B->n - 1; j >= 0; j-- )

  00031	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00034	4f		 dec	 edi
  00035	78 13		 js	 SHORT $L2532
  00037	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0003a	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
$L1635:

; 655  :         if( B->p[j] != 0 )

  0003d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00040	75 08		 jne	 SHORT $L2532
  00042	4f		 dec	 edi
  00043	83 e8 04	 sub	 eax, 4
  00046	85 ff		 test	 edi, edi
  00048	7d f3		 jge	 SHORT $L1635
$L2532:

; 656  :             break;
; 657  : 
; 658  :     CHK( mpi_grow( X, j + 1 ) );

  0004a	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0004d	50		 push	 eax
  0004e	53		 push	 ebx
  0004f	89 45 0c	 mov	 DWORD PTR 12+[ebp], eax
  00052	e8 00 00 00 00	 call	 _mpi_grow
  00057	59		 pop	 ecx
  00058	89 45 08	 mov	 DWORD PTR _ret$[ebp], eax
  0005b	85 c0		 test	 eax, eax
  0005d	59		 pop	 ecx
  0005e	75 6c		 jne	 SHORT $L2539

; 659  : 
; 660  :     o = B->p; p = X->p; c = 0;

  00060	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00063	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00066	33 f6		 xor	 esi, esi

; 661  : 
; 662  :     for( i = 0; i <= j; i++, o++, p++ )

  00068	85 ff		 test	 edi, edi
  0006a	7c 60		 jl	 SHORT $L2539
  0006c	8b 45 0c	 mov	 eax, DWORD PTR 12+[ebp]
  0006f	89 45 0c	 mov	 DWORD PTR _i$[ebp], eax
$L1640:

; 663  :     {
; 664  :         *p +=  c; c  = ( *p <  c );

  00072	01 31		 add	 DWORD PTR [ecx], esi
  00074	39 31		 cmp	 DWORD PTR [ecx], esi

; 665  :         *p += *o; c += ( *p < *o );

  00076	8b 3a		 mov	 edi, DWORD PTR [edx]
  00078	1b f6		 sbb	 esi, esi
  0007a	01 39		 add	 DWORD PTR [ecx], edi
  0007c	8b 39		 mov	 edi, DWORD PTR [ecx]
  0007e	f7 de		 neg	 esi
  00080	3b 3a		 cmp	 edi, DWORD PTR [edx]
  00082	1b ff		 sbb	 edi, edi
  00084	83 c2 04	 add	 edx, 4
  00087	f7 df		 neg	 edi
  00089	03 f7		 add	 esi, edi
  0008b	83 c1 04	 add	 ecx, 4
  0008e	48		 dec	 eax
  0008f	75 e1		 jne	 SHORT $L1640

; 666  :     }
; 667  : 
; 668  :     while( c != 0 )

  00091	85 f6		 test	 esi, esi
  00093	74 37		 je	 SHORT $L2539
  00095	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  00098	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
$L1644:

; 669  :     {
; 670  :         if( i >= X->n )

  0009b	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  0009e	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
  000a1	7c 19		 jl	 SHORT $L1646

; 671  :         {
; 672  :             CHK( mpi_grow( X, i + 1 ) );

  000a3	57		 push	 edi
  000a4	53		 push	 ebx
  000a5	e8 00 00 00 00	 call	 _mpi_grow
  000aa	59		 pop	 ecx
  000ab	89 45 08	 mov	 DWORD PTR _ret$[ebp], eax
  000ae	85 c0		 test	 eax, eax
  000b0	59		 pop	 ecx
  000b1	75 19		 jne	 SHORT $L2539
  000b3	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000b6	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  000b9	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
$L1646:

; 673  :             p = X->p + i;
; 674  :         }
; 675  : 
; 676  :         *p += c; c = ( *p < c ); i++;

  000bc	01 31		 add	 DWORD PTR [ecx], esi
  000be	39 31		 cmp	 DWORD PTR [ecx], esi
  000c0	1b f6		 sbb	 esi, esi
  000c2	f7 de		 neg	 esi
  000c4	ff 45 0c	 inc	 DWORD PTR _i$[ebp]
  000c7	47		 inc	 edi
  000c8	85 f6		 test	 esi, esi
  000ca	75 cf		 jne	 SHORT $L1644
$L2539:
  000cc	5f		 pop	 edi
$cleanup$1634:

; 677  :     }
; 678  : 
; 679  : cleanup:
; 680  : 
; 681  :     return( ret );

  000cd	8b 45 08	 mov	 eax, DWORD PTR _ret$[ebp]
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx

; 682  : }

  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
_mpi_add_abs ENDP
_TEXT	ENDS
PUBLIC	_mpi_sub_abs
;	COMDAT _mpi_sub_abs
_TEXT	SEGMENT
_X$ = 8
_A$ = 12
_B$ = 16
_TB$ = -12
_mpi_sub_abs PROC NEAR					; COMDAT

; 709  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 710  :     mpi TB;
; 711  :     int ret, n;
; 712  : 
; 713  :     if( mpi_cmp_abs( A, B ) < 0 )

  00007	8b 75 10	 mov	 esi, DWORD PTR _B$[ebp]
  0000a	56		 push	 esi
  0000b	ff 75 0c	 push	 DWORD PTR _A$[ebp]
  0000e	e8 00 00 00 00	 call	 _mpi_cmp_abs
  00013	59		 pop	 ecx
  00014	85 c0		 test	 eax, eax
  00016	59		 pop	 ecx
  00017	7d 05		 jge	 SHORT $L1675

; 714  :         return( ERR_MPI_NEGATIVE_VALUE );

  00019	6a 0a		 push	 10			; 0000000aH
  0001b	58		 pop	 eax
  0001c	eb 7d		 jmp	 SHORT $L1671
$L1675:
  0001e	53		 push	 ebx
  0001f	57		 push	 edi

; 715  : 
; 716  :     mpi_init( &TB, NULL );

  00020	8d 45 f4	 lea	 eax, DWORD PTR _TB$[ebp]
  00023	6a 00		 push	 0
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _mpi_init

; 717  : 
; 718  :     if( X == B )

  0002b	8b 5d 08	 mov	 ebx, DWORD PTR _X$[ebp]
  0002e	59		 pop	 ecx
  0002f	3b de		 cmp	 ebx, esi
  00031	59		 pop	 ecx
  00032	75 15		 jne	 SHORT $L1677

; 719  :     {
; 720  :         CHK( mpi_copy( &TB, B ) );

  00034	8d 45 f4	 lea	 eax, DWORD PTR _TB$[ebp]
  00037	56		 push	 esi
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _mpi_copy
  0003e	8b f8		 mov	 edi, eax
  00040	59		 pop	 ecx
  00041	85 ff		 test	 edi, edi
  00043	59		 pop	 ecx
  00044	75 44		 jne	 SHORT $cleanup$1679

; 721  :         B = &TB;

  00046	8d 75 f4	 lea	 esi, DWORD PTR _TB$[ebp]
$L1677:

; 722  :     }
; 723  : 
; 724  :     if( X != A )

  00049	3b 5d 0c	 cmp	 ebx, DWORD PTR _A$[ebp]
  0004c	74 11		 je	 SHORT $L1681

; 725  :         CHK( mpi_copy( X, A ) );

  0004e	ff 75 0c	 push	 DWORD PTR _A$[ebp]
  00051	53		 push	 ebx
  00052	e8 00 00 00 00	 call	 _mpi_copy
  00057	8b f8		 mov	 edi, eax
  00059	59		 pop	 ecx
  0005a	85 ff		 test	 edi, edi
  0005c	59		 pop	 ecx
  0005d	75 2b		 jne	 SHORT $cleanup$1679
$L1681:

; 726  : 
; 727  :     ret = 0;
; 728  : 
; 729  :     for( n = B->n - 1; n >= 0; n-- )

  0005f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00062	33 ff		 xor	 edi, edi
  00064	48		 dec	 eax
  00065	78 13		 js	 SHORT $L2542
  00067	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006a	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
$L1682:

; 730  :         if( B->p[n] != 0 )

  0006d	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00070	75 08		 jne	 SHORT $L2542
  00072	48		 dec	 eax
  00073	83 e9 04	 sub	 ecx, 4
  00076	85 c0		 test	 eax, eax
  00078	7d f3		 jge	 SHORT $L1682
$L2542:

; 731  :             break;
; 732  : 
; 733  :     mpi_sub_hlp( n + 1, B->p, X->p );

  0007a	ff 73 08	 push	 DWORD PTR [ebx+8]
  0007d	40		 inc	 eax
  0007e	ff 76 08	 push	 DWORD PTR [esi+8]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 _mpi_sub_hlp
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
$cleanup$1679:

; 734  : 
; 735  : cleanup:
; 736  : 
; 737  :     mpi_free( &TB, NULL );

  0008a	8d 45 f4	 lea	 eax, DWORD PTR _TB$[ebp]
  0008d	6a 00		 push	 0
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _mpi_free
  00095	59		 pop	 ecx

; 738  :     return( ret );

  00096	8b c7		 mov	 eax, edi
  00098	59		 pop	 ecx
  00099	5f		 pop	 edi
  0009a	5b		 pop	 ebx
$L1671:
  0009b	5e		 pop	 esi

; 739  : }

  0009c	c9		 leave
  0009d	c3		 ret	 0
_mpi_sub_abs ENDP
_TEXT	ENDS
;	COMDAT _mpi_sub_hlp
_TEXT	SEGMENT
_n$ = 8
_s$ = 12
_d$ = 16
_mpi_sub_hlp PROC NEAR					; COMDAT

; 688  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  :     int i;
; 690  :     t_int c, z;
; 691  : 
; 692  :     for( i = c = 0; i < n; i++, s++, d++ )

  00003	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00006	57		 push	 edi
  00007	33 ff		 xor	 edi, edi
  00009	85 c0		 test	 eax, eax
  0000b	7e 49		 jle	 SHORT $L1664
  0000d	53		 push	 ebx
  0000e	8b 5d 0c	 mov	 ebx, DWORD PTR _s$[ebp]
  00011	89 45 08	 mov	 DWORD PTR 8+[ebp], eax
  00014	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  00017	56		 push	 esi
$L1659:

; 693  :     {
; 694  :         z = ( *d <  c );     *d -=  c;

  00018	8b 30		 mov	 esi, DWORD PTR [eax]
  0001a	3b f7		 cmp	 esi, edi
  0001c	1b c9		 sbb	 ecx, ecx
  0001e	2b f7		 sub	 esi, edi
  00020	89 30		 mov	 DWORD PTR [eax], esi

; 695  :         c = ( *d < *s ) + z; *d -= *s;

  00022	8b 13		 mov	 edx, DWORD PTR [ebx]
  00024	f7 d9		 neg	 ecx
  00026	3b f2		 cmp	 esi, edx
  00028	1b ff		 sbb	 edi, edi
  0002a	29 10		 sub	 DWORD PTR [eax], edx
  0002c	f7 df		 neg	 edi
  0002e	03 f9		 add	 edi, ecx
  00030	83 c3 04	 add	 ebx, 4
  00033	83 c0 04	 add	 eax, 4
  00036	ff 4d 08	 dec	 DWORD PTR 8+[ebp]
  00039	75 dd		 jne	 SHORT $L1659
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx

; 696  :     }
; 697  : 
; 698  :     while( c != 0 )

  0003d	85 ff		 test	 edi, edi
  0003f	74 15		 je	 SHORT $L1664
$L1663:

; 699  :     {
; 700  :         z = ( *d < c ); *d -= c;

  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	3b cf		 cmp	 ecx, edi
  00045	1b d2		 sbb	 edx, edx
  00047	2b cf		 sub	 ecx, edi
  00049	f7 da		 neg	 edx
  0004b	89 08		 mov	 DWORD PTR [eax], ecx

; 701  :         c = z; i++; d++;

  0004d	83 c0 04	 add	 eax, 4
  00050	85 d2		 test	 edx, edx
  00052	8b fa		 mov	 edi, edx
  00054	75 eb		 jne	 SHORT $L1663
$L1664:
  00056	5f		 pop	 edi

; 702  :     }
; 703  : }

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
_mpi_sub_hlp ENDP
_TEXT	ENDS
PUBLIC	_mpi_add_mpi
;	COMDAT _mpi_add_mpi
_TEXT	SEGMENT
_X$ = 8
_A$ = 12
_B$ = 16
_mpi_add_mpi PROC NEAR					; COMDAT

; 745  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 746  :     int ret, s = A->s;
; 747  : 
; 748  :     if( A->s * B->s < 0 )

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _B$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR _A$[ebp]

; 749  :     {
; 750  :         if( mpi_cmp_abs( A, B ) >= 0 )

  0000c	53		 push	 ebx
  0000d	57		 push	 edi
  0000e	8b 37		 mov	 esi, DWORD PTR [edi]
  00010	8b c6		 mov	 eax, esi
  00012	0f af 03	 imul	 eax, DWORD PTR [ebx]
  00015	85 c0		 test	 eax, eax
  00017	7d 2e		 jge	 SHORT $L1696
  00019	e8 00 00 00 00	 call	 _mpi_cmp_abs
  0001e	59		 pop	 ecx
  0001f	85 c0		 test	 eax, eax
  00021	59		 pop	 ecx
  00022	7c 0d		 jl	 SHORT $L1697

; 751  :         {
; 752  :             CHK( mpi_sub_abs( X, A, B ) );

  00024	53		 push	 ebx
  00025	57		 push	 edi
  00026	8b 7d 08	 mov	 edi, DWORD PTR _X$[ebp]
  00029	57		 push	 edi
  0002a	e8 00 00 00 00	 call	 _mpi_sub_abs

; 753  :             X->s =  s;
; 754  :         }
; 755  :         else

  0002f	eb 1f		 jmp	 SHORT $L2551
$L1697:

; 756  :         {
; 757  :             CHK( mpi_sub_abs( X, B, A ) );

  00031	57		 push	 edi
  00032	8b 7d 08	 mov	 edi, DWORD PTR _X$[ebp]
  00035	53		 push	 ebx
  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 _mpi_sub_abs
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003f	85 c0		 test	 eax, eax
  00041	75 16		 jne	 SHORT $cleanup$1699

; 758  :             X->s = -s;

  00043	f7 de		 neg	 esi

; 759  :         }
; 760  :     }
; 761  :     else

  00045	eb 10		 jmp	 SHORT $L2552
$L1696:

; 762  :     {
; 763  :         CHK( mpi_add_abs( X, A, B ) );

  00047	8b 7d 08	 mov	 edi, DWORD PTR _X$[ebp]
  0004a	57		 push	 edi
  0004b	e8 00 00 00 00	 call	 _mpi_add_abs
$L2551:
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	85 c0		 test	 eax, eax
  00055	75 02		 jne	 SHORT $cleanup$1699
$L2552:

; 764  :         X->s = s;

  00057	89 37		 mov	 DWORD PTR [edi], esi
$cleanup$1699:
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx

; 765  :     }
; 766  : 
; 767  : cleanup:
; 768  : 
; 769  :     return( ret );
; 770  : }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_mpi_add_mpi ENDP
_TEXT	ENDS
PUBLIC	_mpi_sub_mpi
;	COMDAT _mpi_sub_mpi
_TEXT	SEGMENT
_X$ = 8
_A$ = 12
_B$ = 16
_mpi_sub_mpi PROC NEAR					; COMDAT

; 776  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 777  :     int ret, s = A->s;
; 778  : 
; 779  :     if( A->s * B->s > 0 )

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _B$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR _A$[ebp]

; 780  :     {
; 781  :         if( mpi_cmp_abs( A, B ) >= 0 )

  0000c	53		 push	 ebx
  0000d	57		 push	 edi
  0000e	8b 37		 mov	 esi, DWORD PTR [edi]
  00010	8b c6		 mov	 eax, esi
  00012	0f af 03	 imul	 eax, DWORD PTR [ebx]
  00015	85 c0		 test	 eax, eax
  00017	7e 2e		 jle	 SHORT $L1713
  00019	e8 00 00 00 00	 call	 _mpi_cmp_abs
  0001e	59		 pop	 ecx
  0001f	85 c0		 test	 eax, eax
  00021	59		 pop	 ecx
  00022	7c 0d		 jl	 SHORT $L1714

; 782  :         {
; 783  :             CHK( mpi_sub_abs( X, A, B ) );

  00024	53		 push	 ebx
  00025	57		 push	 edi
  00026	8b 7d 08	 mov	 edi, DWORD PTR _X$[ebp]
  00029	57		 push	 edi
  0002a	e8 00 00 00 00	 call	 _mpi_sub_abs

; 784  :             X->s =  s;
; 785  :         }
; 786  :         else

  0002f	eb 1f		 jmp	 SHORT $L2554
$L1714:

; 787  :         {
; 788  :             CHK( mpi_sub_abs( X, B, A ) );

  00031	57		 push	 edi
  00032	8b 7d 08	 mov	 edi, DWORD PTR _X$[ebp]
  00035	53		 push	 ebx
  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 _mpi_sub_abs
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003f	85 c0		 test	 eax, eax
  00041	75 16		 jne	 SHORT $cleanup$1716

; 789  :             X->s = -s;

  00043	f7 de		 neg	 esi

; 790  :         }
; 791  :     }
; 792  :     else

  00045	eb 10		 jmp	 SHORT $L2555
$L1713:

; 793  :     {
; 794  :         CHK( mpi_add_abs( X, A, B ) );

  00047	8b 7d 08	 mov	 edi, DWORD PTR _X$[ebp]
  0004a	57		 push	 edi
  0004b	e8 00 00 00 00	 call	 _mpi_add_abs
$L2554:
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	85 c0		 test	 eax, eax
  00055	75 02		 jne	 SHORT $cleanup$1716
$L2555:

; 795  :         X->s = s;

  00057	89 37		 mov	 DWORD PTR [edi], esi
$cleanup$1716:
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx

; 796  :     }
; 797  : 
; 798  : cleanup:
; 799  : 
; 800  :     return( ret );
; 801  : }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_mpi_sub_mpi ENDP
_TEXT	ENDS
;	COMDAT _mpi_add_int
_TEXT	SEGMENT
_X$ = 8
_A$ = 12
_b$ = 16
__B$ = -12
_p$ = 16
_mpi_add_int PROC NEAR					; COMDAT

; 807  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 808  :     mpi _B;
; 809  :     t_int p[1];
; 810  : 
; 811  :     p[0] = ( b < 0 ) ? -b : b;

  00006	8b 45 10	 mov	 eax, DWORD PTR _b$[ebp]
  00009	85 c0		 test	 eax, eax
  0000b	7d 09		 jge	 SHORT $L2557
  0000d	8b c8		 mov	 ecx, eax
  0000f	f7 d9		 neg	 ecx
  00011	89 4d 10	 mov	 DWORD PTR _p$[ebp], ecx
  00014	eb 03		 jmp	 SHORT $L2558
$L2557:
  00016	89 45 10	 mov	 DWORD PTR _p$[ebp], eax
$L2558:

; 812  :     _B.s = ( b < 0 ) ? -1 : 1;

  00019	33 c9		 xor	 ecx, ecx

; 813  :     _B.n = 1;

  0001b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR __B$[ebp+4], 1
  00022	85 c0		 test	 eax, eax

; 814  :     _B.p = p;

  00024	8d 45 10	 lea	 eax, DWORD PTR _p$[ebp]
  00027	89 45 fc	 mov	 DWORD PTR __B$[ebp+8], eax

; 815  : 
; 816  :     return( mpi_add_mpi( X, A, &_B ) );

  0002a	8d 45 f4	 lea	 eax, DWORD PTR __B$[ebp]
  0002d	0f 9d c1	 setge	 cl
  00030	50		 push	 eax
  00031	49		 dec	 ecx
  00032	ff 75 0c	 push	 DWORD PTR _A$[ebp]
  00035	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00038	41		 inc	 ecx
  00039	ff 75 08	 push	 DWORD PTR _X$[ebp]
  0003c	89 4d f4	 mov	 DWORD PTR __B$[ebp], ecx
  0003f	e8 00 00 00 00	 call	 _mpi_add_mpi
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 817  : }

  00047	c9		 leave
  00048	c3		 ret	 0
_mpi_add_int ENDP
_TEXT	ENDS
PUBLIC	_mpi_sub_int
;	COMDAT _mpi_sub_int
_TEXT	SEGMENT
_X$ = 8
_A$ = 12
_b$ = 16
__B$ = -12
_p$ = 16
_mpi_sub_int PROC NEAR					; COMDAT

; 823  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 824  :     mpi _B;
; 825  :     t_int p[1];
; 826  : 
; 827  :     p[0] = ( b < 0 ) ? -b : b;

  00006	8b 45 10	 mov	 eax, DWORD PTR _b$[ebp]
  00009	85 c0		 test	 eax, eax
  0000b	7d 09		 jge	 SHORT $L2560
  0000d	8b c8		 mov	 ecx, eax
  0000f	f7 d9		 neg	 ecx
  00011	89 4d 10	 mov	 DWORD PTR _p$[ebp], ecx
  00014	eb 03		 jmp	 SHORT $L2561
$L2560:
  00016	89 45 10	 mov	 DWORD PTR _p$[ebp], eax
$L2561:

; 828  :     _B.s = ( b < 0 ) ? -1 : 1;

  00019	33 c9		 xor	 ecx, ecx

; 829  :     _B.n = 1;

  0001b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR __B$[ebp+4], 1
  00022	85 c0		 test	 eax, eax

; 830  :     _B.p = p;

  00024	8d 45 10	 lea	 eax, DWORD PTR _p$[ebp]
  00027	89 45 fc	 mov	 DWORD PTR __B$[ebp+8], eax

; 831  : 
; 832  :     return( mpi_sub_mpi( X, A, &_B ) );

  0002a	8d 45 f4	 lea	 eax, DWORD PTR __B$[ebp]
  0002d	0f 9d c1	 setge	 cl
  00030	50		 push	 eax
  00031	49		 dec	 ecx
  00032	ff 75 0c	 push	 DWORD PTR _A$[ebp]
  00035	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00038	41		 inc	 ecx
  00039	ff 75 08	 push	 DWORD PTR _X$[ebp]
  0003c	89 4d f4	 mov	 DWORD PTR __B$[ebp], ecx
  0003f	e8 00 00 00 00	 call	 _mpi_sub_mpi
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 833  : }

  00047	c9		 leave
  00048	c3		 ret	 0
_mpi_sub_int ENDP
_TEXT	ENDS
PUBLIC	_mpi_mul_mpi
;	COMDAT _mpi_mul_mpi
_TEXT	SEGMENT
_X$ = 8
_A$ = 12
_B$ = 16
_ret$ = -4
_TA$ = -16
_TB$ = -28
_mpi_mul_mpi PROC NEAR					; COMDAT

; 903  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 904  :     int ret, i, j;
; 905  :     mpi TA, TB;
; 906  : 
; 907  :     mpi_init( &TA, &TB, NULL );

  00009	8d 45 e4	 lea	 eax, DWORD PTR _TB$[ebp]
  0000c	6a 00		 push	 0
  0000e	50		 push	 eax
  0000f	8d 45 f0	 lea	 eax, DWORD PTR _TA$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _mpi_init

; 908  : 
; 909  :     if( X == A ) { CHK( mpi_copy( &TA, A ) ); A = &TA; }

  00018	8b 75 0c	 mov	 esi, DWORD PTR _A$[ebp]
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001e	39 75 08	 cmp	 DWORD PTR _X$[ebp], esi
  00021	75 1f		 jne	 SHORT $L1776
  00023	8d 45 f0	 lea	 eax, DWORD PTR _TA$[ebp]
  00026	56		 push	 esi
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _mpi_copy
  0002d	59		 pop	 ecx
  0002e	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  00031	85 c0		 test	 eax, eax
  00033	59		 pop	 ecx
  00034	0f 85 ba 00 00
	00		 jne	 $cleanup$1778
  0003a	8d 45 f0	 lea	 eax, DWORD PTR _TA$[ebp]
  0003d	89 45 0c	 mov	 DWORD PTR _A$[ebp], eax
  00040	8b f0		 mov	 esi, eax
$L1776:

; 910  :     if( X == B ) { CHK( mpi_copy( &TB, B ) ); B = &TB; }

  00042	8b 5d 10	 mov	 ebx, DWORD PTR _B$[ebp]
  00045	39 5d 08	 cmp	 DWORD PTR _X$[ebp], ebx
  00048	75 1a		 jne	 SHORT $L1779
  0004a	8d 45 e4	 lea	 eax, DWORD PTR _TB$[ebp]
  0004d	53		 push	 ebx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _mpi_copy
  00054	59		 pop	 ecx
  00055	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  00058	85 c0		 test	 eax, eax
  0005a	59		 pop	 ecx
  0005b	0f 85 93 00 00
	00		 jne	 $cleanup$1778
  00061	8d 5d e4	 lea	 ebx, DWORD PTR _TB$[ebp]
$L1779:

; 911  : 
; 912  :     for( i = A->n - 1; i >= 0; i-- )

  00064	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00067	4f		 dec	 edi
  00068	78 13		 js	 SHORT $L2566
  0006a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006d	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
$L1781:

; 913  :         if( A->p[i] != 0 )

  00070	83 38 00	 cmp	 DWORD PTR [eax], 0
  00073	75 08		 jne	 SHORT $L2566
  00075	4f		 dec	 edi
  00076	83 e8 04	 sub	 eax, 4
  00079	85 ff		 test	 edi, edi
  0007b	7d f3		 jge	 SHORT $L1781
$L2566:

; 914  :             break;
; 915  : 
; 916  :     for( j = B->n - 1; j >= 0; j-- )

  0007d	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00080	4e		 dec	 esi
  00081	78 13		 js	 SHORT $L2567
  00083	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00086	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
$L1785:

; 917  :         if( B->p[j] != 0 )

  00089	83 38 00	 cmp	 DWORD PTR [eax], 0
  0008c	75 08		 jne	 SHORT $L2567
  0008e	4e		 dec	 esi
  0008f	83 e8 04	 sub	 eax, 4
  00092	85 f6		 test	 esi, esi
  00094	7d f3		 jge	 SHORT $L1785
$L2567:

; 918  :             break;
; 919  : 
; 920  :     CHK( mpi_grow( X, i + j + 2 ) );

  00096	8d 44 3e 02	 lea	 eax, DWORD PTR [esi+edi+2]
  0009a	50		 push	 eax
  0009b	ff 75 08	 push	 DWORD PTR _X$[ebp]
  0009e	e8 00 00 00 00	 call	 _mpi_grow
  000a3	59		 pop	 ecx
  000a4	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  000a7	85 c0		 test	 eax, eax
  000a9	59		 pop	 ecx
  000aa	75 48		 jne	 SHORT $cleanup$1778

; 921  :     CHK( mpi_lset( X, 0 ) );

  000ac	50		 push	 eax
  000ad	ff 75 08	 push	 DWORD PTR _X$[ebp]
  000b0	e8 00 00 00 00	 call	 _mpi_lset
  000b5	59		 pop	 ecx
  000b6	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  000b9	85 c0		 test	 eax, eax
  000bb	59		 pop	 ecx
  000bc	75 36		 jne	 SHORT $cleanup$1778

; 922  : 
; 923  :     for( i++; j >= 0; j-- )

  000be	47		 inc	 edi
  000bf	85 f6		 test	 esi, esi
  000c1	7c 24		 jl	 SHORT $L1793
$L1791:

; 924  :         mpi_mul_hlp( i, A->p, X->p + j, B->p[j] );

  000c3	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000c6	8b c6		 mov	 eax, esi
  000c8	c1 e0 02	 shl	 eax, 2
  000cb	ff 34 08	 push	 DWORD PTR [eax+ecx]
  000ce	8b 4d 08	 mov	 ecx, DWORD PTR _X$[ebp]
  000d1	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  000d4	50		 push	 eax
  000d5	8b 45 0c	 mov	 eax, DWORD PTR _A$[ebp]
  000d8	ff 70 08	 push	 DWORD PTR [eax+8]
  000db	57		 push	 edi
  000dc	e8 00 00 00 00	 call	 _mpi_mul_hlp
  000e1	83 c4 10	 add	 esp, 16			; 00000010H
  000e4	4e		 dec	 esi
  000e5	79 dc		 jns	 SHORT $L1791
$L1793:

; 925  : 
; 926  :     X->s = A->s * B->s;

  000e7	8b 45 0c	 mov	 eax, DWORD PTR _A$[ebp]
  000ea	8b 4d 08	 mov	 ecx, DWORD PTR _X$[ebp]
  000ed	8b 00		 mov	 eax, DWORD PTR [eax]
  000ef	0f af 03	 imul	 eax, DWORD PTR [ebx]
  000f2	89 01		 mov	 DWORD PTR [ecx], eax
$cleanup$1778:

; 927  : 
; 928  : cleanup:
; 929  : 
; 930  :     mpi_free( &TB, &TA, NULL );

  000f4	8d 45 f0	 lea	 eax, DWORD PTR _TA$[ebp]
  000f7	6a 00		 push	 0
  000f9	50		 push	 eax
  000fa	8d 45 e4	 lea	 eax, DWORD PTR _TB$[ebp]
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 _mpi_free

; 931  :     return( ret );

  00103	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH
  00109	5f		 pop	 edi
  0010a	5e		 pop	 esi
  0010b	5b		 pop	 ebx

; 932  : }

  0010c	c9		 leave
  0010d	c3		 ret	 0
_mpi_mul_mpi ENDP
_TEXT	ENDS
;	COMDAT _mpi_mul_hlp
_TEXT	SEGMENT
_i$ = 8
_s$ = 12
_d$ = 16
_b$ = 20
_c$ = -4
_mpi_mul_hlp PROC NEAR					; COMDAT

; 839  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 840  :     t_int c = 0, t = 0;

  00005	83 65 fc 00	 and	 DWORD PTR _c$[ebp], 0

; 841  : 
; 842  : #if defined(MULADDC_HUIT)
; 843  :     for( ; i >= 8; i -= 8 )
; 844  :     {
; 845  :         MULADDC_INIT
; 846  :         MULADDC_HUIT
; 847  :         MULADDC_STOP
; 848  :     }
; 849  : 
; 850  :     for( ; i > 0; i-- )
; 851  :     {
; 852  :         MULADDC_INIT
; 853  :         MULADDC_CORE
; 854  :         MULADDC_STOP
; 855  :     }
; 856  : #else
; 857  :     for( ; i >= 16; i -= 16 )

  00009	83 7d 08 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	0f 8c 2f 01 00
	00		 jl	 $L1753
  00016	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00019	c1 e8 04	 shr	 eax, 4
  0001c	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  0001f	f7 d8		 neg	 eax
  00021	c1 e0 04	 shl	 eax, 4
  00024	01 45 08	 add	 DWORD PTR _i$[ebp], eax
$L1751:

; 858  :     {
; 859  :         MULADDC_INIT

  00027	8b 75 0c	 mov	 esi, DWORD PTR _s$[ebp]
  0002a	8b 7d 10	 mov	 edi, DWORD PTR _d$[ebp]
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  00030	8b 5d 14	 mov	 ebx, DWORD PTR _b$[ebp]

; 860  :         MULADDC_CORE   MULADDC_CORE

  00033	ad		 lodsd
  00034	f7 e3		 mul	 ebx
  00036	03 c1		 add	 eax, ecx
  00038	83 d2 00	 adc	 edx, 0
  0003b	03 07		 add	 eax, DWORD PTR [edi]
  0003d	83 d2 00	 adc	 edx, 0
  00040	8b ca		 mov	 ecx, edx
  00042	ab		 stosd
  00043	ad		 lodsd
  00044	f7 e3		 mul	 ebx
  00046	03 c1		 add	 eax, ecx
  00048	83 d2 00	 adc	 edx, 0
  0004b	03 07		 add	 eax, DWORD PTR [edi]
  0004d	83 d2 00	 adc	 edx, 0
  00050	8b ca		 mov	 ecx, edx
  00052	ab		 stosd

; 861  :         MULADDC_CORE   MULADDC_CORE

  00053	ad		 lodsd
  00054	f7 e3		 mul	 ebx
  00056	03 c1		 add	 eax, ecx
  00058	83 d2 00	 adc	 edx, 0
  0005b	03 07		 add	 eax, DWORD PTR [edi]
  0005d	83 d2 00	 adc	 edx, 0
  00060	8b ca		 mov	 ecx, edx
  00062	ab		 stosd
  00063	ad		 lodsd
  00064	f7 e3		 mul	 ebx
  00066	03 c1		 add	 eax, ecx
  00068	83 d2 00	 adc	 edx, 0
  0006b	03 07		 add	 eax, DWORD PTR [edi]
  0006d	83 d2 00	 adc	 edx, 0
  00070	8b ca		 mov	 ecx, edx
  00072	ab		 stosd

; 862  :         MULADDC_CORE   MULADDC_CORE

  00073	ad		 lodsd
  00074	f7 e3		 mul	 ebx
  00076	03 c1		 add	 eax, ecx
  00078	83 d2 00	 adc	 edx, 0
  0007b	03 07		 add	 eax, DWORD PTR [edi]
  0007d	83 d2 00	 adc	 edx, 0
  00080	8b ca		 mov	 ecx, edx
  00082	ab		 stosd
  00083	ad		 lodsd
  00084	f7 e3		 mul	 ebx
  00086	03 c1		 add	 eax, ecx
  00088	83 d2 00	 adc	 edx, 0
  0008b	03 07		 add	 eax, DWORD PTR [edi]
  0008d	83 d2 00	 adc	 edx, 0
  00090	8b ca		 mov	 ecx, edx
  00092	ab		 stosd

; 863  :         MULADDC_CORE   MULADDC_CORE

  00093	ad		 lodsd
  00094	f7 e3		 mul	 ebx
  00096	03 c1		 add	 eax, ecx
  00098	83 d2 00	 adc	 edx, 0
  0009b	03 07		 add	 eax, DWORD PTR [edi]
  0009d	83 d2 00	 adc	 edx, 0
  000a0	8b ca		 mov	 ecx, edx
  000a2	ab		 stosd
  000a3	ad		 lodsd
  000a4	f7 e3		 mul	 ebx
  000a6	03 c1		 add	 eax, ecx
  000a8	83 d2 00	 adc	 edx, 0
  000ab	03 07		 add	 eax, DWORD PTR [edi]
  000ad	83 d2 00	 adc	 edx, 0
  000b0	8b ca		 mov	 ecx, edx
  000b2	ab		 stosd

; 864  : 
; 865  :         MULADDC_CORE   MULADDC_CORE

  000b3	ad		 lodsd
  000b4	f7 e3		 mul	 ebx
  000b6	03 c1		 add	 eax, ecx
  000b8	83 d2 00	 adc	 edx, 0
  000bb	03 07		 add	 eax, DWORD PTR [edi]
  000bd	83 d2 00	 adc	 edx, 0
  000c0	8b ca		 mov	 ecx, edx
  000c2	ab		 stosd
  000c3	ad		 lodsd
  000c4	f7 e3		 mul	 ebx
  000c6	03 c1		 add	 eax, ecx
  000c8	83 d2 00	 adc	 edx, 0
  000cb	03 07		 add	 eax, DWORD PTR [edi]
  000cd	83 d2 00	 adc	 edx, 0
  000d0	8b ca		 mov	 ecx, edx
  000d2	ab		 stosd

; 866  :         MULADDC_CORE   MULADDC_CORE

  000d3	ad		 lodsd
  000d4	f7 e3		 mul	 ebx
  000d6	03 c1		 add	 eax, ecx
  000d8	83 d2 00	 adc	 edx, 0
  000db	03 07		 add	 eax, DWORD PTR [edi]
  000dd	83 d2 00	 adc	 edx, 0
  000e0	8b ca		 mov	 ecx, edx
  000e2	ab		 stosd
  000e3	ad		 lodsd
  000e4	f7 e3		 mul	 ebx
  000e6	03 c1		 add	 eax, ecx
  000e8	83 d2 00	 adc	 edx, 0
  000eb	03 07		 add	 eax, DWORD PTR [edi]
  000ed	83 d2 00	 adc	 edx, 0
  000f0	8b ca		 mov	 ecx, edx
  000f2	ab		 stosd

; 867  :         MULADDC_CORE   MULADDC_CORE

  000f3	ad		 lodsd
  000f4	f7 e3		 mul	 ebx
  000f6	03 c1		 add	 eax, ecx
  000f8	83 d2 00	 adc	 edx, 0
  000fb	03 07		 add	 eax, DWORD PTR [edi]
  000fd	83 d2 00	 adc	 edx, 0
  00100	8b ca		 mov	 ecx, edx
  00102	ab		 stosd
  00103	ad		 lodsd
  00104	f7 e3		 mul	 ebx
  00106	03 c1		 add	 eax, ecx
  00108	83 d2 00	 adc	 edx, 0
  0010b	03 07		 add	 eax, DWORD PTR [edi]
  0010d	83 d2 00	 adc	 edx, 0
  00110	8b ca		 mov	 ecx, edx
  00112	ab		 stosd

; 868  :         MULADDC_CORE   MULADDC_CORE

  00113	ad		 lodsd
  00114	f7 e3		 mul	 ebx
  00116	03 c1		 add	 eax, ecx
  00118	83 d2 00	 adc	 edx, 0
  0011b	03 07		 add	 eax, DWORD PTR [edi]
  0011d	83 d2 00	 adc	 edx, 0
  00120	8b ca		 mov	 ecx, edx
  00122	ab		 stosd
  00123	ad		 lodsd
  00124	f7 e3		 mul	 ebx
  00126	03 c1		 add	 eax, ecx
  00128	83 d2 00	 adc	 edx, 0
  0012b	03 07		 add	 eax, DWORD PTR [edi]
  0012d	83 d2 00	 adc	 edx, 0
  00130	8b ca		 mov	 ecx, edx
  00132	ab		 stosd

; 869  :         MULADDC_STOP

  00133	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
  00136	89 7d 10	 mov	 DWORD PTR _d$[ebp], edi
  00139	89 75 0c	 mov	 DWORD PTR _s$[ebp], esi

; 841  : 
; 842  : #if defined(MULADDC_HUIT)
; 843  :     for( ; i >= 8; i -= 8 )
; 844  :     {
; 845  :         MULADDC_INIT
; 846  :         MULADDC_HUIT
; 847  :         MULADDC_STOP
; 848  :     }
; 849  : 
; 850  :     for( ; i > 0; i-- )
; 851  :     {
; 852  :         MULADDC_INIT
; 853  :         MULADDC_CORE
; 854  :         MULADDC_STOP
; 855  :     }
; 856  : #else
; 857  :     for( ; i >= 16; i -= 16 )

  0013c	ff 4d f8	 dec	 DWORD PTR -8+[ebp]
  0013f	0f 85 e2 fe ff
	ff		 jne	 $L1751
$L1753:

; 870  :     }
; 871  : 
; 872  :     for( ; i >= 8; i -= 8 )

  00145	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00148	83 f9 08	 cmp	 ecx, 8
  0014b	0f 8c ae 00 00
	00		 jl	 $L1756
  00151	8b c1		 mov	 eax, ecx
  00153	c1 e8 03	 shr	 eax, 3
  00156	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  00159	f7 d8		 neg	 eax
  0015b	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0015e	89 45 08	 mov	 DWORD PTR _i$[ebp], eax
$L1754:

; 873  :     {
; 874  :         MULADDC_INIT

  00161	8b 75 0c	 mov	 esi, DWORD PTR _s$[ebp]
  00164	8b 7d 10	 mov	 edi, DWORD PTR _d$[ebp]
  00167	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  0016a	8b 5d 14	 mov	 ebx, DWORD PTR _b$[ebp]

; 875  :         MULADDC_CORE   MULADDC_CORE

  0016d	ad		 lodsd
  0016e	f7 e3		 mul	 ebx
  00170	03 c1		 add	 eax, ecx
  00172	83 d2 00	 adc	 edx, 0
  00175	03 07		 add	 eax, DWORD PTR [edi]
  00177	83 d2 00	 adc	 edx, 0
  0017a	8b ca		 mov	 ecx, edx
  0017c	ab		 stosd
  0017d	ad		 lodsd
  0017e	f7 e3		 mul	 ebx
  00180	03 c1		 add	 eax, ecx
  00182	83 d2 00	 adc	 edx, 0
  00185	03 07		 add	 eax, DWORD PTR [edi]
  00187	83 d2 00	 adc	 edx, 0
  0018a	8b ca		 mov	 ecx, edx
  0018c	ab		 stosd

; 876  :         MULADDC_CORE   MULADDC_CORE

  0018d	ad		 lodsd
  0018e	f7 e3		 mul	 ebx
  00190	03 c1		 add	 eax, ecx
  00192	83 d2 00	 adc	 edx, 0
  00195	03 07		 add	 eax, DWORD PTR [edi]
  00197	83 d2 00	 adc	 edx, 0
  0019a	8b ca		 mov	 ecx, edx
  0019c	ab		 stosd
  0019d	ad		 lodsd
  0019e	f7 e3		 mul	 ebx
  001a0	03 c1		 add	 eax, ecx
  001a2	83 d2 00	 adc	 edx, 0
  001a5	03 07		 add	 eax, DWORD PTR [edi]
  001a7	83 d2 00	 adc	 edx, 0
  001aa	8b ca		 mov	 ecx, edx
  001ac	ab		 stosd

; 877  : 
; 878  :         MULADDC_CORE   MULADDC_CORE

  001ad	ad		 lodsd
  001ae	f7 e3		 mul	 ebx
  001b0	03 c1		 add	 eax, ecx
  001b2	83 d2 00	 adc	 edx, 0
  001b5	03 07		 add	 eax, DWORD PTR [edi]
  001b7	83 d2 00	 adc	 edx, 0
  001ba	8b ca		 mov	 ecx, edx
  001bc	ab		 stosd
  001bd	ad		 lodsd
  001be	f7 e3		 mul	 ebx
  001c0	03 c1		 add	 eax, ecx
  001c2	83 d2 00	 adc	 edx, 0
  001c5	03 07		 add	 eax, DWORD PTR [edi]
  001c7	83 d2 00	 adc	 edx, 0
  001ca	8b ca		 mov	 ecx, edx
  001cc	ab		 stosd

; 879  :         MULADDC_CORE   MULADDC_CORE

  001cd	ad		 lodsd
  001ce	f7 e3		 mul	 ebx
  001d0	03 c1		 add	 eax, ecx
  001d2	83 d2 00	 adc	 edx, 0
  001d5	03 07		 add	 eax, DWORD PTR [edi]
  001d7	83 d2 00	 adc	 edx, 0
  001da	8b ca		 mov	 ecx, edx
  001dc	ab		 stosd
  001dd	ad		 lodsd
  001de	f7 e3		 mul	 ebx
  001e0	03 c1		 add	 eax, ecx
  001e2	83 d2 00	 adc	 edx, 0
  001e5	03 07		 add	 eax, DWORD PTR [edi]
  001e7	83 d2 00	 adc	 edx, 0
  001ea	8b ca		 mov	 ecx, edx
  001ec	ab		 stosd

; 880  :         MULADDC_STOP

  001ed	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
  001f0	89 7d 10	 mov	 DWORD PTR _d$[ebp], edi
  001f3	89 75 0c	 mov	 DWORD PTR _s$[ebp], esi

; 870  :     }
; 871  : 
; 872  :     for( ; i >= 8; i -= 8 )

  001f6	ff 4d f8	 dec	 DWORD PTR -8+[ebp]
  001f9	0f 85 62 ff ff
	ff		 jne	 $L1754
$L1756:

; 881  :     }
; 882  : 
; 883  :     for( ; i > 0; i-- )

  001ff	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00202	85 c0		 test	 eax, eax
  00204	7e 2d		 jle	 SHORT $L2582
  00206	89 45 08	 mov	 DWORD PTR 8+[ebp], eax
$L1757:

; 884  :     {
; 885  :         MULADDC_INIT

  00209	8b 75 0c	 mov	 esi, DWORD PTR _s$[ebp]
  0020c	8b 7d 10	 mov	 edi, DWORD PTR _d$[ebp]
  0020f	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  00212	8b 5d 14	 mov	 ebx, DWORD PTR _b$[ebp]

; 886  :         MULADDC_CORE

  00215	ad		 lodsd
  00216	f7 e3		 mul	 ebx
  00218	03 c1		 add	 eax, ecx
  0021a	83 d2 00	 adc	 edx, 0
  0021d	03 07		 add	 eax, DWORD PTR [edi]
  0021f	83 d2 00	 adc	 edx, 0
  00222	8b ca		 mov	 ecx, edx
  00224	ab		 stosd

; 887  :         MULADDC_STOP

  00225	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
  00228	89 7d 10	 mov	 DWORD PTR _d$[ebp], edi
  0022b	89 75 0c	 mov	 DWORD PTR _s$[ebp], esi

; 881  :     }
; 882  : 
; 883  :     for( ; i > 0; i-- )

  0022e	ff 4d 08	 dec	 DWORD PTR 8+[ebp]
  00231	75 d6		 jne	 SHORT $L1757
$L2582:
  00233	8b 45 10	 mov	 eax, DWORD PTR _d$[ebp]
  00236	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  00239	5f		 pop	 edi
  0023a	5e		 pop	 esi
  0023b	5b		 pop	 ebx
$L1760:

; 888  :     }
; 889  : #endif
; 890  : 
; 891  :     t++;
; 892  : 
; 893  :     do {
; 894  :         *d += c; c = ( *d < c ); d++;

  0023c	01 08		 add	 DWORD PTR [eax], ecx
  0023e	39 08		 cmp	 DWORD PTR [eax], ecx
  00240	1b c9		 sbb	 ecx, ecx
  00242	83 c0 04	 add	 eax, 4
  00245	f7 d9		 neg	 ecx

; 895  :     }
; 896  :     while( c != 0 );

  00247	85 c9		 test	 ecx, ecx
  00249	75 f1		 jne	 SHORT $L1760

; 897  : }

  0024b	c9		 leave
  0024c	c3		 ret	 0
_mpi_mul_hlp ENDP
_TEXT	ENDS
;	COMDAT _mpi_mul_int
_TEXT	SEGMENT
_X$ = 8
_A$ = 12
_b$ = 16
__B$ = -12
_p$ = 16
_mpi_mul_int PROC NEAR					; COMDAT

; 938  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 939  :     mpi _B;
; 940  :     t_int p[1];
; 941  : 
; 942  :     _B.s = 1;

  00006	6a 01		 push	 1
  00008	58		 pop	 eax
  00009	89 45 f4	 mov	 DWORD PTR __B$[ebp], eax

; 943  :     _B.n = 1;

  0000c	89 45 f8	 mov	 DWORD PTR __B$[ebp+4], eax

; 944  :     _B.p = p;

  0000f	8d 45 10	 lea	 eax, DWORD PTR _p$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __B$[ebp+8], eax

; 945  :     p[0] = b;

  00015	8b 45 10	 mov	 eax, DWORD PTR _b$[ebp]
  00018	89 45 10	 mov	 DWORD PTR _p$[ebp], eax

; 946  : 
; 947  :     return( mpi_mul_mpi( X, A, &_B ) );

  0001b	8d 45 f4	 lea	 eax, DWORD PTR __B$[ebp]
  0001e	50		 push	 eax
  0001f	ff 75 0c	 push	 DWORD PTR _A$[ebp]
  00022	ff 75 08	 push	 DWORD PTR _X$[ebp]
  00025	e8 00 00 00 00	 call	 _mpi_mul_mpi
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 948  : }

  0002d	c9		 leave
  0002e	c3		 ret	 0
_mpi_mul_int ENDP
_TEXT	ENDS
PUBLIC	_mpi_div_mpi
;	COMDAT _mpi_div_mpi
_TEXT	SEGMENT
_Q$ = 8
_R$ = 12
_A$ = 16
_B$ = 20
_i$ = -4
_n$ = -8
_t$ = -16
_k$ = -20
_X$ = -32
_Y$ = -44
_Z$ = -68
_T1$ = -56
_T2$ = -80
_q1$1863 = -12
_mpi_div_mpi PROC NEAR					; COMDAT

; 954  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 955  :     int ret, i, n, t, k;
; 956  :     mpi X, Y, Z, T1, T2;
; 957  : 
; 958  :     if( mpi_cmp_int( B, 0 ) == 0 )

  00008	33 db		 xor	 ebx, ebx
  0000a	57		 push	 edi
  0000b	53		 push	 ebx
  0000c	ff 75 14	 push	 DWORD PTR _B$[ebp]
  0000f	e8 00 00 00 00	 call	 _mpi_cmp_int
  00014	59		 pop	 ecx
  00015	85 c0		 test	 eax, eax
  00017	59		 pop	 ecx
  00018	75 08		 jne	 SHORT $L1823

; 959  :         return( ERR_MPI_DIVISION_BY_ZERO );

  0001a	6a 0c		 push	 12			; 0000000cH
  0001c	58		 pop	 eax
  0001d	e9 ad 04 00 00	 jmp	 $L1812
$L1823:

; 960  : 
; 961  :     mpi_init( &X, &Y, &Z, &T1, &T2, NULL );

  00022	8d 45 b0	 lea	 eax, DWORD PTR _T2$[ebp]
  00025	53		 push	 ebx
  00026	50		 push	 eax
  00027	8d 45 c8	 lea	 eax, DWORD PTR _T1$[ebp]
  0002a	50		 push	 eax
  0002b	8d 45 bc	 lea	 eax, DWORD PTR _Z$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 d4	 lea	 eax, DWORD PTR _Y$[ebp]
  00032	50		 push	 eax
  00033	8d 45 e0	 lea	 eax, DWORD PTR _X$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _mpi_init

; 962  : 
; 963  :     if( mpi_cmp_abs( A, B ) < 0 )

  0003c	ff 75 14	 push	 DWORD PTR _B$[ebp]
  0003f	8b 7d 10	 mov	 edi, DWORD PTR _A$[ebp]
  00042	57		 push	 edi
  00043	e8 00 00 00 00	 call	 _mpi_cmp_abs
  00048	83 c4 20	 add	 esp, 32			; 00000020H
  0004b	85 c0		 test	 eax, eax
  0004d	7d 3b		 jge	 SHORT $L1825

; 964  :     {
; 965  :         if( Q != NULL ) CHK( mpi_lset( Q, 0 ) );

  0004f	39 5d 08	 cmp	 DWORD PTR _Q$[ebp], ebx
  00052	74 15		 je	 SHORT $L1828
  00054	53		 push	 ebx
  00055	ff 75 08	 push	 DWORD PTR _Q$[ebp]
  00058	e8 00 00 00 00	 call	 _mpi_lset
  0005d	8b f0		 mov	 esi, eax
  0005f	59		 pop	 ecx
  00060	3b f3		 cmp	 esi, ebx
  00062	59		 pop	 ecx
  00063	0f 85 46 04 00
	00		 jne	 $cleanup$1829
$L1828:

; 966  :         if( R != NULL ) CHK( mpi_copy( R, A ) );

  00069	39 5d 0c	 cmp	 DWORD PTR _R$[ebp], ebx
  0006c	74 15		 je	 SHORT $L1832
  0006e	57		 push	 edi
  0006f	ff 75 0c	 push	 DWORD PTR _R$[ebp]
  00072	e8 00 00 00 00	 call	 _mpi_copy
  00077	8b f0		 mov	 esi, eax
  00079	59		 pop	 ecx
  0007a	3b f3		 cmp	 esi, ebx
  0007c	59		 pop	 ecx
  0007d	0f 85 2c 04 00
	00		 jne	 $cleanup$1829
$L1832:

; 967  :         return( 0 );

  00083	33 c0		 xor	 eax, eax
  00085	e9 45 04 00 00	 jmp	 $L1812
$L1825:

; 968  :     }
; 969  : 
; 970  :     CHK( mpi_copy( &X, A ) );

  0008a	8d 45 e0	 lea	 eax, DWORD PTR _X$[ebp]
  0008d	57		 push	 edi
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _mpi_copy
  00094	8b f0		 mov	 esi, eax
  00096	59		 pop	 ecx
  00097	3b f3		 cmp	 esi, ebx
  00099	59		 pop	 ecx
  0009a	0f 85 0f 04 00
	00		 jne	 $cleanup$1829

; 971  :     CHK( mpi_copy( &Y, B ) );

  000a0	ff 75 14	 push	 DWORD PTR _B$[ebp]
  000a3	8d 45 d4	 lea	 eax, DWORD PTR _Y$[ebp]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 _mpi_copy
  000ac	8b f0		 mov	 esi, eax
  000ae	59		 pop	 ecx
  000af	3b f3		 cmp	 esi, ebx
  000b1	59		 pop	 ecx
  000b2	0f 85 f7 03 00
	00		 jne	 $cleanup$1829

; 972  :     X.s = Y.s = 1;

  000b8	6a 01		 push	 1
  000ba	58		 pop	 eax
  000bb	89 45 d4	 mov	 DWORD PTR _Y$[ebp], eax
  000be	89 45 e0	 mov	 DWORD PTR _X$[ebp], eax

; 973  : 
; 974  :     CHK( mpi_grow( &Z, A->n + 2 ) );

  000c1	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000c4	40		 inc	 eax
  000c5	40		 inc	 eax
  000c6	50		 push	 eax
  000c7	8d 45 bc	 lea	 eax, DWORD PTR _Z$[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _mpi_grow
  000d0	8b f0		 mov	 esi, eax
  000d2	59		 pop	 ecx
  000d3	3b f3		 cmp	 esi, ebx
  000d5	59		 pop	 ecx
  000d6	0f 85 d3 03 00
	00		 jne	 $cleanup$1829

; 975  :     CHK( mpi_lset( &Z,  0 ) );

  000dc	8d 45 bc	 lea	 eax, DWORD PTR _Z$[ebp]
  000df	53		 push	 ebx
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _mpi_lset
  000e6	8b f0		 mov	 esi, eax
  000e8	59		 pop	 ecx
  000e9	3b f3		 cmp	 esi, ebx
  000eb	59		 pop	 ecx
  000ec	0f 85 bd 03 00
	00		 jne	 $cleanup$1829

; 976  :     CHK( mpi_grow( &T1, 2 ) );

  000f2	8d 45 c8	 lea	 eax, DWORD PTR _T1$[ebp]
  000f5	6a 02		 push	 2
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 _mpi_grow
  000fd	8b f0		 mov	 esi, eax
  000ff	59		 pop	 ecx
  00100	3b f3		 cmp	 esi, ebx
  00102	59		 pop	 ecx
  00103	0f 85 a6 03 00
	00		 jne	 $cleanup$1829

; 977  :     CHK( mpi_grow( &T2, 3 ) );

  00109	8d 45 b0	 lea	 eax, DWORD PTR _T2$[ebp]
  0010c	6a 03		 push	 3
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _mpi_grow
  00114	8b f0		 mov	 esi, eax
  00116	59		 pop	 ecx
  00117	3b f3		 cmp	 esi, ebx
  00119	59		 pop	 ecx
  0011a	0f 85 8f 03 00
	00		 jne	 $cleanup$1829

; 978  : 
; 979  :     k = mpi_msb( &Y ) % biL;

  00120	8d 45 d4	 lea	 eax, DWORD PTR _Y$[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _mpi_msb
  00129	59		 pop	 ecx
  0012a	6a 20		 push	 32			; 00000020H
  0012c	99		 cdq
  0012d	59		 pop	 ecx
  0012e	f7 f9		 idiv	 ecx

; 980  :     if( k < (int) biL - 1 )

  00130	6a 1f		 push	 31			; 0000001fH
  00132	5f		 pop	 edi
  00133	3b d7		 cmp	 edx, edi
  00135	7d 33		 jge	 SHORT $L1844

; 981  :     {
; 982  :         k = biL - 1 - k;

  00137	2b fa		 sub	 edi, edx

; 983  :         CHK( mpi_shift_l( &X, k ) );

  00139	8d 45 e0	 lea	 eax, DWORD PTR _X$[ebp]
  0013c	57		 push	 edi
  0013d	50		 push	 eax
  0013e	89 7d ec	 mov	 DWORD PTR _k$[ebp], edi
  00141	e8 00 00 00 00	 call	 _mpi_shift_l
  00146	8b f0		 mov	 esi, eax
  00148	59		 pop	 ecx
  00149	3b f3		 cmp	 esi, ebx
  0014b	59		 pop	 ecx
  0014c	0f 85 5d 03 00
	00		 jne	 $cleanup$1829

; 984  :         CHK( mpi_shift_l( &Y, k ) );

  00152	8d 45 d4	 lea	 eax, DWORD PTR _Y$[ebp]
  00155	57		 push	 edi
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 _mpi_shift_l
  0015c	8b f0		 mov	 esi, eax
  0015e	59		 pop	 ecx
  0015f	3b f3		 cmp	 esi, ebx
  00161	59		 pop	 ecx
  00162	0f 85 47 03 00
	00		 jne	 $cleanup$1829

; 985  :     }
; 986  :     else k = 0;

  00168	eb 03		 jmp	 SHORT $L1849
$L1844:
  0016a	89 5d ec	 mov	 DWORD PTR _k$[ebp], ebx
$L1849:

; 987  : 
; 988  :     n = X.n - 1;

  0016d	8b 45 e4	 mov	 eax, DWORD PTR _X$[ebp+4]

; 989  :     t = Y.n - 1;

  00170	8b 4d d8	 mov	 ecx, DWORD PTR _Y$[ebp+4]
  00173	48		 dec	 eax
  00174	8d 59 ff	 lea	 ebx, DWORD PTR [ecx-1]
  00177	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 990  :     mpi_shift_l( &Y, biL * (n - t) );

  0017a	2b c3		 sub	 eax, ebx
  0017c	89 5d f0	 mov	 DWORD PTR _t$[ebp], ebx
  0017f	8b f8		 mov	 edi, eax
  00181	89 45 f4	 mov	 DWORD PTR -12+[ebp], eax
  00184	c1 e7 05	 shl	 edi, 5
  00187	8d 45 d4	 lea	 eax, DWORD PTR _Y$[ebp]
  0018a	57		 push	 edi
  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 _mpi_shift_l

; 991  : 
; 992  :     while( mpi_cmp_mpi( &X, &Y ) >= 0 )

  00191	8d 45 d4	 lea	 eax, DWORD PTR _Y$[ebp]
  00194	50		 push	 eax
  00195	8d 45 e0	 lea	 eax, DWORD PTR _X$[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _mpi_cmp_mpi
  0019e	83 c4 10	 add	 esp, 16			; 00000010H
  001a1	85 c0		 test	 eax, eax
  001a3	7c 38		 jl	 SHORT $L1854

; 993  :     {
; 994  :         Z.p[n - t]++;

  001a5	8b 45 f4	 mov	 eax, DWORD PTR -12+[ebp]
  001a8	c1 e0 02	 shl	 eax, 2
  001ab	89 45 f4	 mov	 DWORD PTR -12+[ebp], eax
$L1853:
  001ae	8b 45 c4	 mov	 eax, DWORD PTR _Z$[ebp+8]
  001b1	8b 4d f4	 mov	 ecx, DWORD PTR -12+[ebp]
  001b4	03 c1		 add	 eax, ecx
  001b6	ff 00		 inc	 DWORD PTR [eax]

; 995  :         mpi_sub_mpi( &X, &X, &Y );

  001b8	8d 45 d4	 lea	 eax, DWORD PTR _Y$[ebp]
  001bb	50		 push	 eax
  001bc	8d 45 e0	 lea	 eax, DWORD PTR _X$[ebp]
  001bf	50		 push	 eax
  001c0	8d 45 e0	 lea	 eax, DWORD PTR _X$[ebp]
  001c3	50		 push	 eax
  001c4	e8 00 00 00 00	 call	 _mpi_sub_mpi
  001c9	8d 45 d4	 lea	 eax, DWORD PTR _Y$[ebp]
  001cc	50		 push	 eax
  001cd	8d 45 e0	 lea	 eax, DWORD PTR _X$[ebp]
  001d0	50		 push	 eax
  001d1	e8 00 00 00 00	 call	 _mpi_cmp_mpi
  001d6	83 c4 14	 add	 esp, 20			; 00000014H
  001d9	85 c0		 test	 eax, eax
  001db	7d d1		 jge	 SHORT $L1853
$L1854:

; 996  :     }
; 997  :     mpi_shift_r( &Y, biL * (n - t) );

  001dd	8d 45 d4	 lea	 eax, DWORD PTR _Y$[ebp]
  001e0	57		 push	 edi
  001e1	50		 push	 eax
  001e2	e8 00 00 00 00	 call	 _mpi_shift_r

; 998  : 
; 999  :     for( i = n; i > t ; i-- )

  001e7	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  001ea	59		 pop	 ecx
  001eb	3b c3		 cmp	 eax, ebx
  001ed	59		 pop	 ecx
  001ee	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  001f1	0f 8e 5f 02 00
	00		 jle	 $L1859
  001f7	eb 03		 jmp	 SHORT $L1857
$L2610:
  001f9	8b 5d f0	 mov	 ebx, DWORD PTR _t$[ebp]
$L1857:
  001fc	8b 4d e8	 mov	 ecx, DWORD PTR _X$[ebp+8]
  001ff	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]

; 1000 :     {
; 1001 :         if( X.p[i] >= Y.p[t] )

  00202	8b 55 dc	 mov	 edx, DWORD PTR _Y$[ebp+8]
  00205	8d 3c 81	 lea	 edi, DWORD PTR [ecx+eax*4]
  00208	8b 34 9a	 mov	 esi, DWORD PTR [edx+ebx*4]
  0020b	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0020d	89 75 f8	 mov	 DWORD PTR -8+[ebp], esi
  00210	3b ce		 cmp	 ecx, esi
  00212	72 16		 jb	 SHORT $L1860

; 1002 :             Z.p[i - t - 1] = ~0;

  00214	2b c3		 sub	 eax, ebx
  00216	8d 58 ff	 lea	 ebx, DWORD PTR [eax-1]
  00219	8b 45 c4	 mov	 eax, DWORD PTR _Z$[ebp+8]
  0021c	8b fb		 mov	 edi, ebx
  0021e	c1 e7 02	 shl	 edi, 2
  00221	83 0c 07 ff	 or	 DWORD PTR [edi+eax], -1

; 1003 :         else

  00225	e9 9a 00 00 00	 jmp	 $L1861
$L1860:

; 1004 :         {
; 1005 : #if defined(HAVE_LONGLONG)
; 1006 :             t_dbl r;
; 1007 : 
; 1008 :             r  = (t_dbl) X.p[i] << biL;
; 1009 :             r |= (t_dbl) X.p[i - 1];
; 1010 :             r /= Y.p[t];
; 1011 :             if( r > ((t_dbl) 1 << biL) - 1)
; 1012 :                 r = ((t_dbl) 1 << biL) - 1;
; 1013 : 
; 1014 :             Z.p[i - t - 1] = (t_int) r;
; 1015 : #else
; 1016 :             /*
; 1017 :              * __udiv_qrnnd_c, from GMP/longlong.h
; 1018 :              */
; 1019 :             t_int q0, q1, r0, r1;
; 1020 :             t_int d0, d1, d, m;
; 1021 : 
; 1022 :             d  = Y.p[t];
; 1023 :             d0 = ( d << biH ) >> biH;

  0022a	8b de		 mov	 ebx, esi

; 1024 :             d1 = ( d >> biH );
; 1025 : 
; 1026 :             q1 = X.p[i] / d1;

  0022c	8b c1		 mov	 eax, ecx
  0022e	c1 ee 10	 shr	 esi, 16			; 00000010H
  00231	33 d2		 xor	 edx, edx

; 1027 :             r1 = X.p[i] - d1 * q1;
; 1028 :             r1 <<= biH;
; 1029 :             r1 |= ( X.p[i - 1] >> biH );

  00233	8b 7f fc	 mov	 edi, DWORD PTR [edi-4]
  00236	f7 f6		 div	 esi
  00238	81 e3 ff ff 00
	00		 and	 ebx, 65535		; 0000ffffH
  0023e	8b d0		 mov	 edx, eax
  00240	89 45 f4	 mov	 DWORD PTR _q1$1863[ebp], eax
  00243	0f af d6	 imul	 edx, esi
  00246	69 d2 ff ff 00
	00		 imul	 edx, 65535		; 0000ffffH
  0024c	03 d1		 add	 edx, ecx
  0024e	c1 e2 10	 shl	 edx, 16			; 00000010H
  00251	8b ca		 mov	 ecx, edx
  00253	8b d7		 mov	 edx, edi
  00255	c1 ea 10	 shr	 edx, 16			; 00000010H
  00258	0b ca		 or	 ecx, edx

; 1030 : 
; 1031 :             m = q1 * d0;

  0025a	0f af c3	 imul	 eax, ebx
$L2615:

; 1032 :             if( r1 < m )

  0025d	3b c8		 cmp	 ecx, eax
  0025f	73 0b		 jae	 SHORT $L1883

; 1033 :             {
; 1034 :                 q1--, r1 += d;

  00261	03 4d f8	 add	 ecx, DWORD PTR -8+[ebp]
  00264	ff 4d f4	 dec	 DWORD PTR _q1$1863[ebp]

; 1035 :                 while( r1 >= d && r1 < m )

  00267	3b 4d f8	 cmp	 ecx, DWORD PTR -8+[ebp]
  0026a	73 f1		 jae	 SHORT $L2615
$L1883:

; 1036 :                     q1--, r1 += d;
; 1037 :             }
; 1038 :             r1 -= m;

  0026c	2b c8		 sub	 ecx, eax

; 1039 : 
; 1040 :             q0 = r1 / d1;

  0026e	33 d2		 xor	 edx, edx
  00270	8b c1		 mov	 eax, ecx

; 1041 :             r0 = r1 - d1 * q0;
; 1042 :             r0 <<= biH;
; 1043 :             r0 |= ( X.p[i - 1] << biH ) >> biH;

  00272	81 e7 ff ff 00
	00		 and	 edi, 65535		; 0000ffffH
  00278	f7 f6		 div	 esi
  0027a	8b d0		 mov	 edx, eax
  0027c	0f af d6	 imul	 edx, esi
  0027f	69 d2 ff ff 00
	00		 imul	 edx, 65535		; 0000ffffH
  00285	03 d1		 add	 edx, ecx
  00287	c1 e2 10	 shl	 edx, 16			; 00000010H
  0028a	8b ca		 mov	 ecx, edx

; 1044 : 
; 1045 :             m = q0 * d0;

  0028c	8b d0		 mov	 edx, eax
  0028e	0f af d3	 imul	 edx, ebx
  00291	0b cf		 or	 ecx, edi

; 1046 :             if( r0 < m )

  00293	3b ca		 cmp	 ecx, edx
  00295	73 11		 jae	 SHORT $L1893

; 1047 :             {
; 1048 :                 q0--, r0 += d;

  00297	8b 75 f8	 mov	 esi, DWORD PTR -8+[ebp]
  0029a	48		 dec	 eax
$L2616:
  0029b	03 ce		 add	 ecx, esi

; 1049 :                 while( r0 >= d && r0 < m )

  0029d	3b ce		 cmp	 ecx, esi
  0029f	72 07		 jb	 SHORT $L1893
  002a1	3b ca		 cmp	 ecx, edx
  002a3	73 03		 jae	 SHORT $L1893

; 1050 :                     q0--, r0 += d;

  002a5	48		 dec	 eax

; 1049 :                 while( r0 >= d && r0 < m )

  002a6	eb f3		 jmp	 SHORT $L2616
$L1893:

; 1051 :             }
; 1052 :             r0 -= m;
; 1053 : 
; 1054 :             Z.p[i - t - 1] = ( q1 << biH ) | q0;

  002a8	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  002ab	2b 4d f0	 sub	 ecx, DWORD PTR _t$[ebp]
  002ae	8d 59 ff	 lea	 ebx, DWORD PTR [ecx-1]
  002b1	8b 4d f4	 mov	 ecx, DWORD PTR _q1$1863[ebp]
  002b4	8b fb		 mov	 edi, ebx
  002b6	c1 e1 10	 shl	 ecx, 16			; 00000010H
  002b9	c1 e7 02	 shl	 edi, 2
  002bc	0b c8		 or	 ecx, eax
  002be	8b 45 c4	 mov	 eax, DWORD PTR _Z$[ebp+8]
  002c1	89 0c 07	 mov	 DWORD PTR [edi+eax], ecx
$L1861:

; 1055 : #endif
; 1056 :         }
; 1057 : 
; 1058 :         Z.p[i - t - 1]++;

  002c4	8b 45 c4	 mov	 eax, DWORD PTR _Z$[ebp+8]
  002c7	03 c7		 add	 eax, edi
  002c9	ff 00		 inc	 DWORD PTR [eax]
$L1896:

; 1059 :         do
; 1060 :         {
; 1061 :             Z.p[i - t - 1]--;

  002cb	8b 45 c4	 mov	 eax, DWORD PTR _Z$[ebp+8]

; 1062 : 
; 1063 :             CHK( mpi_lset( &T1, 0 ) );

  002ce	6a 00		 push	 0
  002d0	03 c7		 add	 eax, edi
  002d2	ff 08		 dec	 DWORD PTR [eax]
  002d4	8d 45 c8	 lea	 eax, DWORD PTR _T1$[ebp]
  002d7	50		 push	 eax
  002d8	e8 00 00 00 00	 call	 _mpi_lset
  002dd	8b f0		 mov	 esi, eax
  002df	59		 pop	 ecx
  002e0	85 f6		 test	 esi, esi
  002e2	59		 pop	 ecx
  002e3	0f 85 c6 01 00
	00		 jne	 $cleanup$1829

; 1064 :             T1.p[0] = (t < 1) ? 0 : Y.p[t - 1];

  002e9	8b 4d f0	 mov	 ecx, DWORD PTR _t$[ebp]
  002ec	83 f9 01	 cmp	 ecx, 1
  002ef	7c 07		 jl	 SHORT $L2586
$L2585:
  002f1	8b 45 dc	 mov	 eax, DWORD PTR _Y$[ebp+8]
  002f4	8b 44 88 fc	 mov	 eax, DWORD PTR [eax+ecx*4-4]
$L2586:
  002f8	8b 55 d0	 mov	 edx, DWORD PTR _T1$[ebp+8]
  002fb	89 02		 mov	 DWORD PTR [edx], eax

; 1065 :             T1.p[1] = Y.p[t];

  002fd	8b 45 dc	 mov	 eax, DWORD PTR _Y$[ebp+8]
  00300	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00303	8b 4d d0	 mov	 ecx, DWORD PTR _T1$[ebp+8]
  00306	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1066 :             CHK( mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );

  00309	8b 45 c4	 mov	 eax, DWORD PTR _Z$[ebp+8]
  0030c	ff 34 07	 push	 DWORD PTR [edi+eax]
  0030f	8d 45 c8	 lea	 eax, DWORD PTR _T1$[ebp]
  00312	50		 push	 eax
  00313	8d 45 c8	 lea	 eax, DWORD PTR _T1$[ebp]
  00316	50		 push	 eax
  00317	e8 00 00 00 00	 call	 _mpi_mul_int
  0031c	8b f0		 mov	 esi, eax
  0031e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00321	85 f6		 test	 esi, esi
  00323	0f 85 86 01 00
	00		 jne	 $cleanup$1829

; 1067 : 
; 1068 :             CHK( mpi_lset( &T2, 0 ) );

  00329	50		 push	 eax
  0032a	8d 45 b0	 lea	 eax, DWORD PTR _T2$[ebp]
  0032d	50		 push	 eax
  0032e	e8 00 00 00 00	 call	 _mpi_lset
  00333	8b f0		 mov	 esi, eax
  00335	59		 pop	 ecx
  00336	85 f6		 test	 esi, esi
  00338	59		 pop	 ecx
  00339	0f 85 70 01 00
	00		 jne	 $cleanup$1829

; 1069 :             T2.p[0] = (i < 2) ? 0 : X.p[i - 2];

  0033f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00342	83 f8 02	 cmp	 eax, 2
  00345	7d 04		 jge	 SHORT $L2587
  00347	33 c9		 xor	 ecx, ecx
  00349	eb 07		 jmp	 SHORT $L2588
$L2587:
  0034b	8b 4d e8	 mov	 ecx, DWORD PTR _X$[ebp+8]
  0034e	8b 4c 81 f8	 mov	 ecx, DWORD PTR [ecx+eax*4-8]
$L2588:
  00352	8b 55 b8	 mov	 edx, DWORD PTR _T2$[ebp+8]

; 1070 :             T2.p[1] = (i < 1) ? 0 : X.p[i - 1];

  00355	83 f8 01	 cmp	 eax, 1
  00358	89 0a		 mov	 DWORD PTR [edx], ecx
  0035a	7d 04		 jge	 SHORT $L2589
  0035c	33 c9		 xor	 ecx, ecx
  0035e	eb 07		 jmp	 SHORT $L2590
$L2589:
  00360	8b 4d e8	 mov	 ecx, DWORD PTR _X$[ebp+8]
  00363	8b 4c 81 fc	 mov	 ecx, DWORD PTR [ecx+eax*4-4]
$L2590:
  00367	8b 55 b8	 mov	 edx, DWORD PTR _T2$[ebp+8]
  0036a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1071 :             T2.p[2] = X.p[i];

  0036d	8b 4d e8	 mov	 ecx, DWORD PTR _X$[ebp+8]
  00370	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00373	8b 4d b8	 mov	 ecx, DWORD PTR _T2$[ebp+8]
  00376	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1072 :         }
; 1073 :         while( mpi_cmp_mpi( &T1, &T2 ) > 0 );

  00379	8d 45 b0	 lea	 eax, DWORD PTR _T2$[ebp]
  0037c	50		 push	 eax
  0037d	8d 45 c8	 lea	 eax, DWORD PTR _T1$[ebp]
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 _mpi_cmp_mpi
  00386	59		 pop	 ecx
  00387	85 c0		 test	 eax, eax
  00389	59		 pop	 ecx
  0038a	0f 8f 3b ff ff
	ff		 jg	 $L1896

; 1074 : 
; 1075 :         CHK( mpi_mul_int( &T1, &Y, Z.p[i - t - 1] ) );

  00390	8b 45 c4	 mov	 eax, DWORD PTR _Z$[ebp+8]
  00393	ff 34 07	 push	 DWORD PTR [edi+eax]
  00396	8d 45 d4	 lea	 eax, DWORD PTR _Y$[ebp]
  00399	50		 push	 eax
  0039a	8d 45 c8	 lea	 eax, DWORD PTR _T1$[ebp]
  0039d	50		 push	 eax
  0039e	e8 00 00 00 00	 call	 _mpi_mul_int
  003a3	8b f0		 mov	 esi, eax
  003a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a8	85 f6		 test	 esi, esi
  003aa	0f 85 ff 00 00
	00		 jne	 $cleanup$1829

; 1076 :         CHK( mpi_shift_l( &T1,  biL * (i - t - 1) ) );

  003b0	c1 e3 05	 shl	 ebx, 5
  003b3	8d 45 c8	 lea	 eax, DWORD PTR _T1$[ebp]
  003b6	53		 push	 ebx
  003b7	50		 push	 eax
  003b8	e8 00 00 00 00	 call	 _mpi_shift_l
  003bd	8b f0		 mov	 esi, eax
  003bf	59		 pop	 ecx
  003c0	85 f6		 test	 esi, esi
  003c2	59		 pop	 ecx
  003c3	0f 85 e6 00 00
	00		 jne	 $cleanup$1829

; 1077 :         CHK( mpi_sub_mpi( &X, &X, &T1 ) );

  003c9	8d 45 c8	 lea	 eax, DWORD PTR _T1$[ebp]
  003cc	50		 push	 eax
  003cd	8d 45 e0	 lea	 eax, DWORD PTR _X$[ebp]
  003d0	50		 push	 eax
  003d1	8d 45 e0	 lea	 eax, DWORD PTR _X$[ebp]
  003d4	50		 push	 eax
  003d5	e8 00 00 00 00	 call	 _mpi_sub_mpi
  003da	8b f0		 mov	 esi, eax
  003dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  003df	85 f6		 test	 esi, esi
  003e1	0f 85 c8 00 00
	00		 jne	 $cleanup$1829

; 1078 : 
; 1079 :         if( mpi_cmp_int( &X, 0 ) < 0 )

  003e7	50		 push	 eax
  003e8	8d 45 e0	 lea	 eax, DWORD PTR _X$[ebp]
  003eb	50		 push	 eax
  003ec	e8 00 00 00 00	 call	 _mpi_cmp_int
  003f1	59		 pop	 ecx
  003f2	85 c0		 test	 eax, eax
  003f4	59		 pop	 ecx
  003f5	7d 50		 jge	 SHORT $L1858

; 1080 :         {
; 1081 :             CHK( mpi_copy( &T1, &Y ) );

  003f7	8d 45 d4	 lea	 eax, DWORD PTR _Y$[ebp]
  003fa	50		 push	 eax
  003fb	8d 45 c8	 lea	 eax, DWORD PTR _T1$[ebp]
  003fe	50		 push	 eax
  003ff	e8 00 00 00 00	 call	 _mpi_copy
  00404	8b f0		 mov	 esi, eax
  00406	59		 pop	 ecx
  00407	85 f6		 test	 esi, esi
  00409	59		 pop	 ecx
  0040a	0f 85 9f 00 00
	00		 jne	 $cleanup$1829

; 1082 :             CHK( mpi_shift_l( &T1, biL * (i - t - 1) ) );

  00410	8d 45 c8	 lea	 eax, DWORD PTR _T1$[ebp]
  00413	53		 push	 ebx
  00414	50		 push	 eax
  00415	e8 00 00 00 00	 call	 _mpi_shift_l
  0041a	8b f0		 mov	 esi, eax
  0041c	59		 pop	 ecx
  0041d	85 f6		 test	 esi, esi
  0041f	59		 pop	 ecx
  00420	0f 85 89 00 00
	00		 jne	 $cleanup$1829

; 1083 :             CHK( mpi_add_mpi( &X, &X, &T1 ) );

  00426	8d 45 c8	 lea	 eax, DWORD PTR _T1$[ebp]
  00429	50		 push	 eax
  0042a	8d 45 e0	 lea	 eax, DWORD PTR _X$[ebp]
  0042d	50		 push	 eax
  0042e	8d 45 e0	 lea	 eax, DWORD PTR _X$[ebp]
  00431	50		 push	 eax
  00432	e8 00 00 00 00	 call	 _mpi_add_mpi
  00437	8b f0		 mov	 esi, eax
  00439	83 c4 0c	 add	 esp, 12			; 0000000cH
  0043c	85 f6		 test	 esi, esi
  0043e	75 6f		 jne	 SHORT $cleanup$1829

; 1084 :             Z.p[i - t - 1]--;

  00440	8b 45 c4	 mov	 eax, DWORD PTR _Z$[ebp+8]
  00443	03 c7		 add	 eax, edi
  00445	ff 08		 dec	 DWORD PTR [eax]
$L1858:
  00447	ff 4d fc	 dec	 DWORD PTR _i$[ebp]
  0044a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0044d	3b 45 f0	 cmp	 eax, DWORD PTR _t$[ebp]
  00450	0f 8f a3 fd ff
	ff		 jg	 $L2610
$L1859:

; 1085 :         }
; 1086 :     }
; 1087 : 
; 1088 :     if( Q != NULL )

  00456	8b 7d 08	 mov	 edi, DWORD PTR _Q$[ebp]
  00459	85 ff		 test	 edi, edi
  0045b	74 19		 je	 SHORT $L1914

; 1089 :     {
; 1090 :         mpi_copy( Q, &Z );

  0045d	8d 45 bc	 lea	 eax, DWORD PTR _Z$[ebp]
  00460	50		 push	 eax
  00461	57		 push	 edi
  00462	e8 00 00 00 00	 call	 _mpi_copy

; 1091 :         Q->s = A->s * B->s;

  00467	8b 45 10	 mov	 eax, DWORD PTR _A$[ebp]
  0046a	59		 pop	 ecx
  0046b	59		 pop	 ecx
  0046c	8b 4d 14	 mov	 ecx, DWORD PTR _B$[ebp]
  0046f	8b 00		 mov	 eax, DWORD PTR [eax]
  00471	0f af 01	 imul	 eax, DWORD PTR [ecx]
  00474	89 07		 mov	 DWORD PTR [edi], eax
$L1914:

; 1092 :     }
; 1093 : 
; 1094 :     if( R != NULL )

  00476	8b 7d 0c	 mov	 edi, DWORD PTR _R$[ebp]
  00479	85 ff		 test	 edi, edi
  0047b	74 32		 je	 SHORT $cleanup$1829

; 1095 :     {
; 1096 :         mpi_shift_r( &X, k );

  0047d	ff 75 ec	 push	 DWORD PTR _k$[ebp]
  00480	8d 45 e0	 lea	 eax, DWORD PTR _X$[ebp]
  00483	50		 push	 eax
  00484	e8 00 00 00 00	 call	 _mpi_shift_r

; 1097 :         mpi_copy( R, &X );

  00489	8d 45 e0	 lea	 eax, DWORD PTR _X$[ebp]
  0048c	50		 push	 eax
  0048d	57		 push	 edi
  0048e	e8 00 00 00 00	 call	 _mpi_copy

; 1098 : 
; 1099 :         R->s = A->s;

  00493	8b 45 10	 mov	 eax, DWORD PTR _A$[ebp]

; 1100 :         if( mpi_cmp_int( R, 0 ) == 0 )

  00496	6a 00		 push	 0
  00498	57		 push	 edi
  00499	8b 00		 mov	 eax, DWORD PTR [eax]
  0049b	89 07		 mov	 DWORD PTR [edi], eax
  0049d	e8 00 00 00 00	 call	 _mpi_cmp_int
  004a2	83 c4 18	 add	 esp, 24			; 00000018H
  004a5	85 c0		 test	 eax, eax
  004a7	75 06		 jne	 SHORT $cleanup$1829

; 1101 :             R->s = 1;

  004a9	c7 07 01 00 00
	00		 mov	 DWORD PTR [edi], 1
$cleanup$1829:

; 1102 :     }
; 1103 : 
; 1104 : cleanup:
; 1105 : 
; 1106 :     mpi_free( &X, &Y, &Z, &T1, &T2, NULL );

  004af	8d 45 b0	 lea	 eax, DWORD PTR _T2$[ebp]
  004b2	6a 00		 push	 0
  004b4	50		 push	 eax
  004b5	8d 45 c8	 lea	 eax, DWORD PTR _T1$[ebp]
  004b8	50		 push	 eax
  004b9	8d 45 bc	 lea	 eax, DWORD PTR _Z$[ebp]
  004bc	50		 push	 eax
  004bd	8d 45 d4	 lea	 eax, DWORD PTR _Y$[ebp]
  004c0	50		 push	 eax
  004c1	8d 45 e0	 lea	 eax, DWORD PTR _X$[ebp]
  004c4	50		 push	 eax
  004c5	e8 00 00 00 00	 call	 _mpi_free
  004ca	83 c4 18	 add	 esp, 24			; 00000018H

; 1107 :     return( ret );

  004cd	8b c6		 mov	 eax, esi
$L1812:
  004cf	5f		 pop	 edi
  004d0	5e		 pop	 esi
  004d1	5b		 pop	 ebx

; 1108 : }

  004d2	c9		 leave
  004d3	c3		 ret	 0
_mpi_div_mpi ENDP
_TEXT	ENDS
;	COMDAT _mpi_div_int
_TEXT	SEGMENT
_Q$ = 8
_R$ = 12
_A$ = 16
_b$ = 20
__B$ = -12
_p$ = 20
_mpi_div_int PROC NEAR					; COMDAT

; 1118 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1119 :     mpi _B;
; 1120 :     t_int p[1];
; 1121 : 
; 1122 :     p[0] = ( b < 0 ) ? -b : b;

  00006	8b 45 14	 mov	 eax, DWORD PTR _b$[ebp]
  00009	85 c0		 test	 eax, eax
  0000b	7d 09		 jge	 SHORT $L2618
  0000d	8b c8		 mov	 ecx, eax
  0000f	f7 d9		 neg	 ecx
  00011	89 4d 14	 mov	 DWORD PTR _p$[ebp], ecx
  00014	eb 03		 jmp	 SHORT $L2619
$L2618:
  00016	89 45 14	 mov	 DWORD PTR _p$[ebp], eax
$L2619:

; 1123 :     _B.s = ( b < 0 ) ? -1 : 1;

  00019	33 c9		 xor	 ecx, ecx

; 1124 :     _B.n = 1;

  0001b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR __B$[ebp+4], 1
  00022	85 c0		 test	 eax, eax

; 1125 :     _B.p = p;

  00024	8d 45 14	 lea	 eax, DWORD PTR _p$[ebp]
  00027	89 45 fc	 mov	 DWORD PTR __B$[ebp+8], eax

; 1126 : 
; 1127 :     return( mpi_div_mpi( Q, R, A, &_B ) );

  0002a	8d 45 f4	 lea	 eax, DWORD PTR __B$[ebp]
  0002d	50		 push	 eax
  0002e	ff 75 10	 push	 DWORD PTR _A$[ebp]
  00031	0f 9d c1	 setge	 cl
  00034	ff 75 0c	 push	 DWORD PTR _R$[ebp]
  00037	49		 dec	 ecx
  00038	83 e1 fe	 and	 ecx, -2			; fffffffeH
  0003b	ff 75 08	 push	 DWORD PTR _Q$[ebp]
  0003e	41		 inc	 ecx
  0003f	89 4d f4	 mov	 DWORD PTR __B$[ebp], ecx
  00042	e8 00 00 00 00	 call	 _mpi_div_mpi
  00047	83 c4 10	 add	 esp, 16			; 00000010H

; 1128 : }

  0004a	c9		 leave
  0004b	c3		 ret	 0
_mpi_div_int ENDP
_TEXT	ENDS
PUBLIC	_mpi_mod_mpi
;	COMDAT _mpi_mod_mpi
_TEXT	SEGMENT
_R$ = 8
_A$ = 12
_B$ = 16
_mpi_mod_mpi PROC NEAR					; COMDAT

; 1134 : {

  00000	53		 push	 ebx

; 1135 :     int ret;
; 1136 : 
; 1137 :     CHK( mpi_div_mpi( NULL, R, A, B ) );

  00001	8b 5c 24 10	 mov	 ebx, DWORD PTR _B$[esp]
  00005	56		 push	 esi
  00006	8b 74 24 0c	 mov	 esi, DWORD PTR _R$[esp+4]
  0000a	57		 push	 edi
  0000b	53		 push	 ebx
  0000c	ff 74 24 18	 push	 DWORD PTR _A$[esp+12]
  00010	56		 push	 esi
  00011	6a 00		 push	 0
  00013	e8 00 00 00 00	 call	 _mpi_div_mpi
  00018	83 c4 10	 add	 esp, 16			; 00000010H
$L2625:
  0001b	8b f8		 mov	 edi, eax
  0001d	85 ff		 test	 edi, edi
  0001f	75 3a		 jne	 SHORT $cleanup$1940

; 1138 : 
; 1139 :     while( mpi_cmp_int( R, 0 ) < 0 )

  00021	50		 push	 eax
  00022	56		 push	 esi
  00023	e8 00 00 00 00	 call	 _mpi_cmp_int
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx
  0002a	85 c0		 test	 eax, eax

; 1140 :       CHK( mpi_add_mpi( R, R, B ) );

  0002c	53		 push	 ebx
  0002d	56		 push	 esi
  0002e	7d 0b		 jge	 SHORT $L2626
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 _mpi_add_mpi
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	eb e0		 jmp	 SHORT $L2625
$L2626:

; 1141 : 
; 1142 :     while( mpi_cmp_mpi( R, B ) >= 0 )

  0003b	e8 00 00 00 00	 call	 _mpi_cmp_mpi
  00040	59		 pop	 ecx
  00041	85 c0		 test	 eax, eax
  00043	59		 pop	 ecx
  00044	7c 15		 jl	 SHORT $cleanup$1940

; 1143 :       CHK( mpi_sub_mpi( R, R, B ) );

  00046	53		 push	 ebx
  00047	56		 push	 esi
  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 _mpi_sub_mpi
  0004e	8b f8		 mov	 edi, eax
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	85 ff		 test	 edi, edi
  00055	75 04		 jne	 SHORT $cleanup$1940
  00057	53		 push	 ebx
  00058	56		 push	 esi
  00059	eb e0		 jmp	 SHORT $L2626
$cleanup$1940:

; 1144 : 
; 1145 : cleanup:
; 1146 : 
; 1147 :     return( ret );

  0005b	8b c7		 mov	 eax, edi
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 1148 : }

  00060	c3		 ret	 0
_mpi_mod_mpi ENDP
_TEXT	ENDS
;	COMDAT _mpi_mod_int
_TEXT	SEGMENT
_r$ = 8
_A$ = 12
_b$ = 16
_mpi_mod_int PROC NEAR					; COMDAT

; 1154 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1155 :     int i;
; 1156 :     t_int x, y, z;
; 1157 : 
; 1158 :     if( b == 0 )

  00004	33 db		 xor	 ebx, ebx
  00006	39 5d 10	 cmp	 DWORD PTR _b$[ebp], ebx
  00009	75 08		 jne	 SHORT $L2631

; 1159 :         return( ERR_MPI_DIVISION_BY_ZERO );

  0000b	6a 0c		 push	 12			; 0000000cH
  0000d	58		 pop	 eax
  0000e	e9 87 00 00 00	 jmp	 $L1955
$L2631:

; 1160 : 
; 1161 :     if( b < 0 )

  00013	7d 08		 jge	 SHORT $L1961

; 1162 :         b = -b;

  00015	8b 45 10	 mov	 eax, DWORD PTR _b$[ebp]
  00018	f7 d8		 neg	 eax
  0001a	89 45 10	 mov	 DWORD PTR _b$[ebp], eax
$L1961:

; 1163 : 
; 1164 :     /*
; 1165 :      * handle trivial cases
; 1166 :      */
; 1167 :     if( b == 1 ) { *r = 0;           return( 0 ); }

  0001d	83 7d 10 01	 cmp	 DWORD PTR _b$[ebp], 1
  00021	74 70		 je	 SHORT $L1966

; 1168 :     if( b == 2 ) { *r = A->p[0] & 1; return( 0 ); }

  00023	83 7d 10 02	 cmp	 DWORD PTR _b$[ebp], 2
  00027	75 12		 jne	 SHORT $L1963
  00029	8b 45 0c	 mov	 eax, DWORD PTR _A$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  0002f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	83 e0 01	 and	 eax, 1
  00037	89 01		 mov	 DWORD PTR [ecx], eax
  00039	eb 5d		 jmp	 SHORT $L2632
$L1963:

; 1169 : 
; 1170 :     /*
; 1171 :      * general case
; 1172 :      */
; 1173 :     for( i = A->n - 1, y = 0; i >= 0; i-- )

  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _A$[ebp]
  0003e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00041	48		 dec	 eax
  00042	78 4f		 js	 SHORT $L1966
  00044	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00047	56		 push	 esi
  00048	57		 push	 edi
  00049	8d 3c 81	 lea	 edi, DWORD PTR [ecx+eax*4]
  0004c	40		 inc	 eax
  0004d	89 45 0c	 mov	 DWORD PTR 12+[ebp], eax
$L1964:

; 1174 :     {
; 1175 :         x  = A->p[i];

  00050	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1176 :         y  = ( y << biH ) | ( x >> biH );
; 1177 :         z  = y / b;

  00052	33 d2		 xor	 edx, edx
  00054	8b f1		 mov	 esi, ecx

; 1178 :         y -= z * b;
; 1179 : 
; 1180 :         x <<= biH;

  00056	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0005c	c1 ee 10	 shr	 esi, 16			; 00000010H
  0005f	c1 e3 10	 shl	 ebx, 16			; 00000010H
  00062	0b f3		 or	 esi, ebx
  00064	83 ef 04	 sub	 edi, 4
  00067	8b c6		 mov	 eax, esi
  00069	f7 75 10	 div	 DWORD PTR _b$[ebp]

; 1181 :         y  = ( y << biH ) | ( x >> biH );
; 1182 :         z  = y / b;

  0006c	33 d2		 xor	 edx, edx
  0006e	0f af 45 10	 imul	 eax, DWORD PTR _b$[ebp]
  00072	69 c0 ff ff 00
	00		 imul	 eax, 65535		; 0000ffffH
  00078	03 c6		 add	 eax, esi
  0007a	c1 e0 10	 shl	 eax, 16			; 00000010H
  0007d	8b d8		 mov	 ebx, eax
  0007f	0b d9		 or	 ebx, ecx
  00081	8b c3		 mov	 eax, ebx
  00083	f7 75 10	 div	 DWORD PTR _b$[ebp]

; 1183 :         y -= z * b;

  00086	0f af 45 10	 imul	 eax, DWORD PTR _b$[ebp]
  0008a	2b d8		 sub	 ebx, eax
  0008c	ff 4d 0c	 dec	 DWORD PTR 12+[ebp]
  0008f	75 bf		 jne	 SHORT $L1964
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
$L1966:

; 1184 :     }
; 1185 : 
; 1186 :     *r = y;

  00093	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  00096	89 18		 mov	 DWORD PTR [eax], ebx
$L2632:

; 1187 : 
; 1188 :     return( 0 );

  00098	33 c0		 xor	 eax, eax
$L1955:
  0009a	5b		 pop	 ebx

; 1189 : }

  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_mpi_mod_int ENDP
_TEXT	ENDS
PUBLIC	_mpi_exp_mod
;	COMDAT _mpi_exp_mod
_TEXT	SEGMENT
_bufsize$ = 12
_nblimbs$ = -16
_mm$ = -8
_state$ = -12
_RR$ = -40
_T$ = -28
_W$ = -808
_X$ = 8
_A$ = 12
_E$ = 16
_N$ = 20
__RR$ = 24
_ret$ = -4
_wsize$ = 20
_mpi_exp_mod PROC NEAR					; COMDAT

; 1264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 03 00
	00		 sub	 esp, 808		; 00000328H
  00009	53		 push	 ebx
  0000a	57		 push	 edi

; 1265 :     int ret, i, j, wsize, wbits;
; 1266 :     int bufsize, nblimbs, nbits;
; 1267 :     t_int ei, mm, state;
; 1268 :     mpi RR, T, W[64];
; 1269 : 
; 1270 :     if( mpi_cmp_int( N, 0 ) < 0 || ( N->p[0] & 1 ) == 0 )

  0000b	8b 7d 14	 mov	 edi, DWORD PTR _N$[ebp]
  0000e	33 db		 xor	 ebx, ebx
  00010	53		 push	 ebx
  00011	57		 push	 edi
  00012	e8 00 00 00 00	 call	 _mpi_cmp_int
  00017	59		 pop	 ecx
  00018	85 c0		 test	 eax, eax
  0001a	59		 pop	 ecx
  0001b	0f 8c 36 04 00
	00		 jl	 $L2059
  00021	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00024	f6 00 01	 test	 BYTE PTR [eax], 1
  00027	0f 84 2a 04 00
	00		 je	 $L2059

; 1272 : 
; 1273 :     /*
; 1274 :      * Init temps and window size
; 1275 :      */
; 1276 :     mpi_montg_init( &mm, N );

  0002d	8d 45 f8	 lea	 eax, DWORD PTR _mm$[ebp]
  00030	57		 push	 edi
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _mpi_montg_init

; 1277 :     mpi_init( &RR, &T, NULL );

  00037	8d 45 e4	 lea	 eax, DWORD PTR _T$[ebp]
  0003a	53		 push	 ebx
  0003b	50		 push	 eax
  0003c	8d 45 d8	 lea	 eax, DWORD PTR _RR$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _mpi_init

; 1278 :     memset( W, 0, sizeof( W ) );

  00045	68 00 03 00 00	 push	 768			; 00000300H
  0004a	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR _W$[ebp]
  00050	53		 push	 ebx
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _memset

; 1279 : 
; 1280 :     i = mpi_msb( E );

  00057	ff 75 10	 push	 DWORD PTR _E$[ebp]
  0005a	e8 00 00 00 00	 call	 _mpi_msb
  0005f	83 c4 24	 add	 esp, 36			; 00000024H

; 1281 : 
; 1282 :     wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
; 1283 :             ( i >  79 ) ? 4 : ( i >  23 ) ? 3 : 1;

  00062	3d 9f 02 00 00	 cmp	 eax, 671		; 0000029fH
  00067	7e 09		 jle	 SHORT $L2638
  00069	c7 45 14 06 00
	00 00		 mov	 DWORD PTR _wsize$[ebp], 6
  00070	eb 2e		 jmp	 SHORT $L2635
$L2638:
  00072	3d ef 00 00 00	 cmp	 eax, 239		; 000000efH
  00077	7e 09		 jle	 SHORT $L2636
  00079	c7 45 14 05 00
	00 00		 mov	 DWORD PTR _wsize$[ebp], 5
  00080	eb 1e		 jmp	 SHORT $L2635
$L2636:
  00082	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  00085	7e 09		 jle	 SHORT $L2634
  00087	c7 45 14 04 00
	00 00		 mov	 DWORD PTR _wsize$[ebp], 4
  0008e	eb 10		 jmp	 SHORT $L2635
$L2634:
  00090	33 c9		 xor	 ecx, ecx
  00092	83 f8 17	 cmp	 eax, 23			; 00000017H
  00095	0f 9e c1	 setle	 cl
  00098	49		 dec	 ecx
  00099	83 e1 02	 and	 ecx, 2
  0009c	41		 inc	 ecx
  0009d	89 4d 14	 mov	 DWORD PTR _wsize$[ebp], ecx
$L2635:
  000a0	56		 push	 esi

; 1284 : 
; 1285 :     j = N->n + 1;

  000a1	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  000a4	46		 inc	 esi

; 1286 :     CHK( mpi_grow( X, j ) );

  000a5	56		 push	 esi
  000a6	ff 75 08	 push	 DWORD PTR _X$[ebp]
  000a9	e8 00 00 00 00	 call	 _mpi_grow
  000ae	59		 pop	 ecx
  000af	3b c3		 cmp	 eax, ebx
  000b1	59		 pop	 ecx
  000b2	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  000b5	0f 85 32 03 00
	00		 jne	 $cleanup$2062

; 1287 :     CHK( mpi_grow( &W[1],  j ) );

  000bb	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR _W$[ebp+12]
  000c1	56		 push	 esi
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 _mpi_grow
  000c8	59		 pop	 ecx
  000c9	3b c3		 cmp	 eax, ebx
  000cb	59		 pop	 ecx
  000cc	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  000cf	0f 85 18 03 00
	00		 jne	 $cleanup$2062

; 1288 :     CHK( mpi_grow( &T, j * 2 ) );

  000d5	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  000d8	50		 push	 eax
  000d9	8d 45 e4	 lea	 eax, DWORD PTR _T$[ebp]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _mpi_grow
  000e2	59		 pop	 ecx
  000e3	3b c3		 cmp	 eax, ebx
  000e5	59		 pop	 ecx
  000e6	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  000e9	0f 85 fe 02 00
	00		 jne	 $cleanup$2062

; 1289 : 
; 1290 :     /*
; 1291 :      * If 1st call, pre-compute R^2 mod N
; 1292 :      */
; 1293 :     if( _RR == NULL || _RR->p == NULL )

  000ef	8b 75 18	 mov	 esi, DWORD PTR __RR$[ebp]
  000f2	3b f3		 cmp	 esi, ebx
  000f4	74 0e		 je	 SHORT $L2068
  000f6	39 5e 08	 cmp	 DWORD PTR [esi+8], ebx
  000f9	74 09		 je	 SHORT $L2068

; 1301 :     }
; 1302 :     else
; 1303 :         memcpy( &RR, _RR, sizeof( mpi ) );

  000fb	6a 0c		 push	 12			; 0000000cH
  000fd	8d 45 d8	 lea	 eax, DWORD PTR _RR$[ebp]
  00100	56		 push	 esi
  00101	50		 push	 eax
  00102	eb 5c		 jmp	 SHORT $L2668
$L2068:

; 1294 :     {
; 1295 :         CHK( mpi_lset( &RR, 1 ) );

  00104	8d 45 d8	 lea	 eax, DWORD PTR _RR$[ebp]
  00107	6a 01		 push	 1
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 _mpi_lset
  0010f	59		 pop	 ecx
  00110	3b c3		 cmp	 eax, ebx
  00112	59		 pop	 ecx
  00113	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  00116	0f 85 d1 02 00
	00		 jne	 $cleanup$2062

; 1296 :         CHK( mpi_shift_l( &RR, N->n * 2 * biL ) );

  0011c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0011f	c1 e0 06	 shl	 eax, 6
  00122	50		 push	 eax
  00123	8d 45 d8	 lea	 eax, DWORD PTR _RR$[ebp]
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 _mpi_shift_l
  0012c	59		 pop	 ecx
  0012d	3b c3		 cmp	 eax, ebx
  0012f	59		 pop	 ecx
  00130	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  00133	0f 85 b4 02 00
	00		 jne	 $cleanup$2062

; 1297 :         CHK( mpi_mod_mpi( &RR, &RR, N ) );

  00139	8d 45 d8	 lea	 eax, DWORD PTR _RR$[ebp]
  0013c	57		 push	 edi
  0013d	50		 push	 eax
  0013e	8d 45 d8	 lea	 eax, DWORD PTR _RR$[ebp]
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 _mpi_mod_mpi
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014a	3b c3		 cmp	 eax, ebx
  0014c	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  0014f	0f 85 98 02 00
	00		 jne	 $cleanup$2062

; 1298 : 
; 1299 :         if( _RR != NULL )

  00155	3b f3		 cmp	 esi, ebx
  00157	74 0f		 je	 SHORT $L2075

; 1300 :             memcpy( _RR, &RR, sizeof( mpi ) );

  00159	8d 45 d8	 lea	 eax, DWORD PTR _RR$[ebp]
  0015c	6a 0c		 push	 12			; 0000000cH
  0015e	50		 push	 eax
  0015f	56		 push	 esi
$L2668:
  00160	e8 00 00 00 00	 call	 _memcpy
  00165	83 c4 0c	 add	 esp, 12			; 0000000cH
$L2075:

; 1304 : 
; 1305 :     /*
; 1306 :      * W[1] = A * R^2 * R^-1 mod N = A * R mod N
; 1307 :      */
; 1308 :     if( mpi_cmp_mpi( A, N ) >= 0 )

  00168	57		 push	 edi
  00169	ff 75 0c	 push	 DWORD PTR _A$[ebp]
  0016c	e8 00 00 00 00	 call	 _mpi_cmp_mpi
  00171	59		 pop	 ecx
  00172	85 c0		 test	 eax, eax
  00174	59		 pop	 ecx
  00175	7c 15		 jl	 SHORT $L2079

; 1309 :         mpi_mod_mpi( &W[1], A, N );

  00177	57		 push	 edi
  00178	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR _W$[ebp+12]
  0017e	ff 75 0c	 push	 DWORD PTR _A$[ebp]
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 _mpi_mod_mpi
  00187	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1310 :     else   mpi_copy( &W[1], A );

  0018a	eb 11		 jmp	 SHORT $L2080
$L2079:
  0018c	ff 75 0c	 push	 DWORD PTR _A$[ebp]
  0018f	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR _W$[ebp+12]
  00195	50		 push	 eax
  00196	e8 00 00 00 00	 call	 _mpi_copy
  0019b	59		 pop	 ecx
  0019c	59		 pop	 ecx
$L2080:

; 1311 : 
; 1312 :     mpi_montmul( &W[1], &RR, N, mm, &T );

  0019d	8d 45 e4	 lea	 eax, DWORD PTR _T$[ebp]
  001a0	50		 push	 eax
  001a1	8d 45 d8	 lea	 eax, DWORD PTR _RR$[ebp]
  001a4	ff 75 f8	 push	 DWORD PTR _mm$[ebp]
  001a7	57		 push	 edi
  001a8	50		 push	 eax
  001a9	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR _W$[ebp+12]
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 _mpi_montmul

; 1313 : 
; 1314 :     /*
; 1315 :      * X = R^2 * R^-1 mod N = R mod N
; 1316 :      */
; 1317 :     CHK( mpi_copy( X, &RR ) );

  001b5	8d 45 d8	 lea	 eax, DWORD PTR _RR$[ebp]
  001b8	50		 push	 eax
  001b9	ff 75 08	 push	 DWORD PTR _X$[ebp]
  001bc	e8 00 00 00 00	 call	 _mpi_copy
  001c1	83 c4 1c	 add	 esp, 28			; 0000001cH
  001c4	3b c3		 cmp	 eax, ebx
  001c6	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  001c9	0f 85 1e 02 00
	00		 jne	 $cleanup$2062

; 1318 :     mpi_montred( X, N, mm, &T );

  001cf	8d 45 e4	 lea	 eax, DWORD PTR _T$[ebp]
  001d2	50		 push	 eax
  001d3	ff 75 f8	 push	 DWORD PTR _mm$[ebp]
  001d6	57		 push	 edi
  001d7	ff 75 08	 push	 DWORD PTR _X$[ebp]
  001da	e8 00 00 00 00	 call	 _mpi_montred

; 1319 : 
; 1320 :     if( wsize > 1 )

  001df	8b 4d 14	 mov	 ecx, DWORD PTR _wsize$[ebp]
  001e2	83 c4 10	 add	 esp, 16			; 00000010H
  001e5	6a 01		 push	 1
  001e7	5e		 pop	 esi
  001e8	3b ce		 cmp	 ecx, esi
  001ea	0f 8e d0 00 00
	00		 jle	 $L2090

; 1321 :     {
; 1322 :         /*
; 1323 :          * W[1 << (wsize - 1)] = W[1] ^ (wsize - 1)
; 1324 :          */
; 1325 :         j =  1 << (wsize - 1);

  001f0	49		 dec	 ecx
  001f1	d3 e6		 shl	 esi, cl

; 1326 : 
; 1327 :         CHK( mpi_grow( &W[j], N->n + 1 ) );

  001f3	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  001f6	8d 9c 85 d8 fc
	ff ff		 lea	 ebx, DWORD PTR _W$[ebp+eax*4]
  001fd	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00200	40		 inc	 eax
  00201	50		 push	 eax
  00202	53		 push	 ebx
  00203	e8 00 00 00 00	 call	 _mpi_grow
  00208	59		 pop	 ecx
  00209	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  0020c	85 c0		 test	 eax, eax
  0020e	59		 pop	 ecx
  0020f	0f 85 d6 01 00
	00		 jne	 $L2660

; 1328 :         CHK( mpi_copy( &W[j], &W[1]    ) );

  00215	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR _W$[ebp+12]
  0021b	50		 push	 eax
  0021c	53		 push	 ebx
  0021d	e8 00 00 00 00	 call	 _mpi_copy
  00222	59		 pop	 ecx
  00223	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  00226	85 c0		 test	 eax, eax
  00228	59		 pop	 ecx
  00229	0f 85 bc 01 00
	00		 jne	 $L2660

; 1329 : 
; 1330 :         for( i = 0; i < wsize - 1; i++ )

  0022f	8b 45 14	 mov	 eax, DWORD PTR _wsize$[ebp]
  00232	48		 dec	 eax
  00233	85 c0		 test	 eax, eax
  00235	7e 1a		 jle	 SHORT $L2087
  00237	89 45 0c	 mov	 DWORD PTR 12+[ebp], eax
$L2085:

; 1331 :             mpi_montmul( &W[j], &W[j], N, mm, &T );

  0023a	8d 45 e4	 lea	 eax, DWORD PTR _T$[ebp]
  0023d	50		 push	 eax
  0023e	ff 75 f8	 push	 DWORD PTR _mm$[ebp]
  00241	57		 push	 edi
  00242	53		 push	 ebx
  00243	53		 push	 ebx
  00244	e8 00 00 00 00	 call	 _mpi_montmul
  00249	83 c4 14	 add	 esp, 20			; 00000014H
  0024c	ff 4d 0c	 dec	 DWORD PTR 12+[ebp]
  0024f	75 e9		 jne	 SHORT $L2085
$L2087:

; 1332 :     
; 1333 :         /*
; 1334 :          * W[i] = W[i - 1] * W[1]
; 1335 :          */
; 1336 :         for( i = j + 1; i < (1 << wsize); i++ )

  00251	8b 4d 14	 mov	 ecx, DWORD PTR _wsize$[ebp]
  00254	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR 12+[ebp], 1
  0025b	d3 65 0c	 shl	 DWORD PTR 12+[ebp], cl
  0025e	46		 inc	 esi
  0025f	3b 75 0c	 cmp	 esi, DWORD PTR 12+[ebp]
  00262	7d 5a		 jge	 SHORT $L2655
  00264	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00267	8d 9c 85 d8 fc
	ff ff		 lea	 ebx, DWORD PTR _W$[ebp+eax*4]
$L2088:

; 1337 :         {
; 1338 :             CHK( mpi_grow( &W[i], N->n + 1 ) );

  0026e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00271	40		 inc	 eax
  00272	50		 push	 eax
  00273	53		 push	 ebx
  00274	e8 00 00 00 00	 call	 _mpi_grow
  00279	59		 pop	 ecx
  0027a	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  0027d	85 c0		 test	 eax, eax
  0027f	59		 pop	 ecx
  00280	0f 85 65 01 00
	00		 jne	 $L2660

; 1339 :             CHK( mpi_copy( &W[i], &W[i - 1] ) );

  00286	8d 43 f4	 lea	 eax, DWORD PTR [ebx-12]
  00289	50		 push	 eax
  0028a	53		 push	 ebx
  0028b	e8 00 00 00 00	 call	 _mpi_copy
  00290	59		 pop	 ecx
  00291	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
  00294	85 c0		 test	 eax, eax
  00296	59		 pop	 ecx
  00297	0f 85 4e 01 00
	00		 jne	 $L2660

; 1340 : 
; 1341 :             mpi_montmul( &W[i], &W[1], N, mm, &T );

  0029d	8d 45 e4	 lea	 eax, DWORD PTR _T$[ebp]
  002a0	50		 push	 eax
  002a1	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR _W$[ebp+12]
  002a7	ff 75 f8	 push	 DWORD PTR _mm$[ebp]
  002aa	57		 push	 edi
  002ab	50		 push	 eax
  002ac	53		 push	 ebx
  002ad	e8 00 00 00 00	 call	 _mpi_montmul
  002b2	83 c4 14	 add	 esp, 20			; 00000014H
  002b5	46		 inc	 esi
  002b6	83 c3 0c	 add	 ebx, 12			; 0000000cH
  002b9	3b 75 0c	 cmp	 esi, DWORD PTR 12+[ebp]
  002bc	7c b0		 jl	 SHORT $L2088
$L2655:

; 1332 :     
; 1333 :         /*
; 1334 :          * W[i] = W[i - 1] * W[1]
; 1335 :          */
; 1336 :         for( i = j + 1; i < (1 << wsize); i++ )

  002be	33 db		 xor	 ebx, ebx
$L2090:

; 1342 :         }
; 1343 :     }
; 1344 : 
; 1345 :     nblimbs = E->n;

  002c0	8b 45 10	 mov	 eax, DWORD PTR _E$[ebp]

; 1346 :     bufsize = 0;
; 1347 :     nbits   = 0;
; 1348 :     wbits   = 0;

  002c3	33 f6		 xor	 esi, esi
  002c5	89 5d 0c	 mov	 DWORD PTR _bufsize$[ebp], ebx

; 1349 :     state   = 0;

  002c8	89 75 f4	 mov	 DWORD PTR _state$[ebp], esi
  002cb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002ce	89 45 f0	 mov	 DWORD PTR _nblimbs$[ebp], eax
$L2094:

; 1350 : 
; 1351 :     while( 1 )
; 1352 :     {
; 1353 :         if( bufsize == 0 )

  002d1	83 7d 0c 00	 cmp	 DWORD PTR _bufsize$[ebp], 0
  002d5	75 15		 jne	 SHORT $L2096

; 1354 :         {
; 1355 :             if( nblimbs-- == 0 )

  002d7	8b 45 f0	 mov	 eax, DWORD PTR _nblimbs$[ebp]
  002da	ff 4d f0	 dec	 DWORD PTR _nblimbs$[ebp]
  002dd	85 c0		 test	 eax, eax
  002df	0f 84 a8 00 00
	00		 je	 $L2648

; 1356 :                 break;
; 1357 : 
; 1358 :             bufsize = sizeof( t_int ) << 3;

  002e5	c7 45 0c 20 00
	00 00		 mov	 DWORD PTR _bufsize$[ebp], 32 ; 00000020H
$L2096:

; 1359 :         }
; 1360 : 
; 1361 :         bufsize--;
; 1362 : 
; 1363 :         ei = (E->p[nblimbs] >> bufsize) & 1;

  002ec	8b 45 10	 mov	 eax, DWORD PTR _E$[ebp]
  002ef	8b 4d f0	 mov	 ecx, DWORD PTR _nblimbs$[ebp]
  002f2	ff 4d 0c	 dec	 DWORD PTR _bufsize$[ebp]
  002f5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  002f8	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  002fb	8b 4d 0c	 mov	 ecx, DWORD PTR _bufsize$[ebp]
  002fe	d3 e8		 shr	 eax, cl
  00300	83 e0 01	 and	 eax, 1

; 1364 : 
; 1365 :         /*
; 1366 :          * skip leading 0s
; 1367 :          */
; 1368 :         if( ei == 0 && state == 0 )

  00303	75 24		 jne	 SHORT $L2100
  00305	83 7d f4 00	 cmp	 DWORD PTR _state$[ebp], 0
  00309	74 c6		 je	 SHORT $L2094

; 1369 :             continue;
; 1370 : 
; 1371 :         if( ei == 0 && state == 1 )

  0030b	83 7d f4 01	 cmp	 DWORD PTR _state$[ebp], 1
  0030f	75 18		 jne	 SHORT $L2100

; 1372 :         {
; 1373 :             /*
; 1374 :              * out of window, square X
; 1375 :              */
; 1376 :             mpi_montmul( X, X, N, mm, &T );

  00311	8d 45 e4	 lea	 eax, DWORD PTR _T$[ebp]
  00314	50		 push	 eax
  00315	ff 75 f8	 push	 DWORD PTR _mm$[ebp]
  00318	57		 push	 edi
  00319	ff 75 08	 push	 DWORD PTR _X$[ebp]
  0031c	ff 75 08	 push	 DWORD PTR _X$[ebp]
  0031f	e8 00 00 00 00	 call	 _mpi_montmul
  00324	83 c4 14	 add	 esp, 20			; 00000014H

; 1377 :             continue;

  00327	eb a8		 jmp	 SHORT $L2094
$L2100:

; 1378 :         }
; 1379 : 
; 1380 :         /*
; 1381 :          * add ei to current window
; 1382 :          */
; 1383 :         state = 2;
; 1384 : 
; 1385 :         nbits++;
; 1386 :         wbits |= (ei << (wsize - nbits));

  00329	8b 4d 14	 mov	 ecx, DWORD PTR _wsize$[ebp]
  0032c	43		 inc	 ebx
  0032d	2b cb		 sub	 ecx, ebx
  0032f	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _state$[ebp], 2
  00336	d3 e0		 shl	 eax, cl
  00338	0b f0		 or	 esi, eax

; 1387 : 
; 1388 :         if( nbits == wsize )

  0033a	3b 5d 14	 cmp	 ebx, DWORD PTR _wsize$[ebp]
  0033d	75 92		 jne	 SHORT $L2094

; 1389 :         {
; 1390 :             /*
; 1391 :              * X = X^wsize R^-1 mod N
; 1392 :              */
; 1393 :             for( i = 0; i < wsize; i++ )

  0033f	8b 5d 14	 mov	 ebx, DWORD PTR _wsize$[ebp]
  00342	85 db		 test	 ebx, ebx
  00344	7e 19		 jle	 SHORT $L2104
$L2102:

; 1394 :                 mpi_montmul( X, X, N, mm, &T );

  00346	8d 45 e4	 lea	 eax, DWORD PTR _T$[ebp]
  00349	50		 push	 eax
  0034a	ff 75 f8	 push	 DWORD PTR _mm$[ebp]
  0034d	57		 push	 edi
  0034e	ff 75 08	 push	 DWORD PTR _X$[ebp]
  00351	ff 75 08	 push	 DWORD PTR _X$[ebp]
  00354	e8 00 00 00 00	 call	 _mpi_montmul
  00359	83 c4 14	 add	 esp, 20			; 00000014H
  0035c	4b		 dec	 ebx
  0035d	75 e7		 jne	 SHORT $L2102
$L2104:

; 1395 : 
; 1396 :             /*
; 1397 :              * X = X * W[wbits] R^-1 mod N
; 1398 :              */
; 1399 :             mpi_montmul( X, &W[wbits], N, mm, &T );

  0035f	8d 45 e4	 lea	 eax, DWORD PTR _T$[ebp]
  00362	50		 push	 eax
  00363	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00366	ff 75 f8	 push	 DWORD PTR _mm$[ebp]
  00369	8d 84 85 d8 fc
	ff ff		 lea	 eax, DWORD PTR _W$[ebp+eax*4]
  00370	57		 push	 edi
  00371	50		 push	 eax
  00372	ff 75 08	 push	 DWORD PTR _X$[ebp]
  00375	e8 00 00 00 00	 call	 _mpi_montmul
  0037a	83 c4 14	 add	 esp, 20			; 00000014H

; 1400 : 
; 1401 :             state--;
; 1402 :             nbits = 0;

  0037d	33 db		 xor	 ebx, ebx
  0037f	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _state$[ebp], 1

; 1403 :             wbits = 0;

  00386	33 f6		 xor	 esi, esi
  00388	e9 44 ff ff ff	 jmp	 $L2094
$L2648:

; 1404 :         }
; 1405 :     }
; 1406 : 
; 1407 :     /*
; 1408 :      * process the remaining bits
; 1409 :      */
; 1410 :     for( i = 0; i < nbits; i++ )

  0038d	85 db		 test	 ebx, ebx
  0038f	7e 47		 jle	 SHORT $L2107

; 1411 :     {
; 1412 :         mpi_montmul( X, X, N, mm, &T );
; 1413 : 
; 1414 :         wbits <<= 1;
; 1415 : 
; 1416 :         if( (wbits & (1 << wsize)) != 0 )

  00391	8b 4d 14	 mov	 ecx, DWORD PTR _wsize$[ebp]
  00394	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR 12+[ebp], 1
  0039b	d3 65 0c	 shl	 DWORD PTR 12+[ebp], cl
$L2105:
  0039e	8d 45 e4	 lea	 eax, DWORD PTR _T$[ebp]
  003a1	50		 push	 eax
  003a2	ff 75 f8	 push	 DWORD PTR _mm$[ebp]
  003a5	57		 push	 edi
  003a6	ff 75 08	 push	 DWORD PTR _X$[ebp]
  003a9	ff 75 08	 push	 DWORD PTR _X$[ebp]
  003ac	e8 00 00 00 00	 call	 _mpi_montmul
  003b1	d1 e6		 shl	 esi, 1
  003b3	83 c4 14	 add	 esp, 20			; 00000014H
  003b6	85 75 0c	 test	 DWORD PTR 12+[ebp], esi
  003b9	74 1a		 je	 SHORT $L2106

; 1417 :             mpi_montmul( X, &W[1], N, mm, &T );

  003bb	8d 45 e4	 lea	 eax, DWORD PTR _T$[ebp]
  003be	50		 push	 eax
  003bf	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR _W$[ebp+12]
  003c5	ff 75 f8	 push	 DWORD PTR _mm$[ebp]
  003c8	57		 push	 edi
  003c9	50		 push	 eax
  003ca	ff 75 08	 push	 DWORD PTR _X$[ebp]
  003cd	e8 00 00 00 00	 call	 _mpi_montmul
  003d2	83 c4 14	 add	 esp, 20			; 00000014H
$L2106:

; 1404 :         }
; 1405 :     }
; 1406 : 
; 1407 :     /*
; 1408 :      * process the remaining bits
; 1409 :      */
; 1410 :     for( i = 0; i < nbits; i++ )

  003d5	4b		 dec	 ebx
  003d6	75 c6		 jne	 SHORT $L2105
$L2107:

; 1418 :     }
; 1419 : 
; 1420 :     /*
; 1421 :      * X = A^E * R * R^-1 mod N = A^E mod N
; 1422 :      */
; 1423 :     mpi_montred( X, N, mm, &T );

  003d8	8d 45 e4	 lea	 eax, DWORD PTR _T$[ebp]
  003db	50		 push	 eax
  003dc	ff 75 f8	 push	 DWORD PTR _mm$[ebp]
  003df	57		 push	 edi
  003e0	ff 75 08	 push	 DWORD PTR _X$[ebp]
  003e3	e8 00 00 00 00	 call	 _mpi_montred
  003e8	83 c4 10	 add	 esp, 16			; 00000010H
$L2660:
  003eb	33 db		 xor	 ebx, ebx
$cleanup$2062:

; 1424 : 
; 1425 : cleanup:
; 1426 : 
; 1427 :     for( i = (1 << (wsize - 1)); i < (1 << wsize); i++ )

  003ed	8b 75 14	 mov	 esi, DWORD PTR _wsize$[ebp]
  003f0	6a 01		 push	 1
  003f2	5a		 pop	 edx
  003f3	8d 4e ff	 lea	 ecx, DWORD PTR [esi-1]
  003f6	8b c2		 mov	 eax, edx
  003f8	d3 e0		 shl	 eax, cl
  003fa	8b ce		 mov	 ecx, esi
  003fc	d3 e2		 shl	 edx, cl
  003fe	3b c2		 cmp	 eax, edx
  00400	7d 1d		 jge	 SHORT $L2111
  00402	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00405	2b d0		 sub	 edx, eax
  00407	8b fa		 mov	 edi, edx
  00409	8d b4 8d d8 fc
	ff ff		 lea	 esi, DWORD PTR _W$[ebp+ecx*4]
$L2109:

; 1428 :         mpi_free( &W[i], NULL );

  00410	53		 push	 ebx
  00411	56		 push	 esi
  00412	e8 00 00 00 00	 call	 _mpi_free
  00417	59		 pop	 ecx
  00418	83 c6 0c	 add	 esi, 12			; 0000000cH
  0041b	4f		 dec	 edi
  0041c	59		 pop	 ecx
  0041d	75 f1		 jne	 SHORT $L2109
$L2111:

; 1429 : 
; 1430 :     if( _RR != NULL )

  0041f	39 5d 18	 cmp	 DWORD PTR __RR$[ebp], ebx
  00422	5e		 pop	 esi

; 1431 :          mpi_free( &W[1], &T, NULL );

  00423	53		 push	 ebx
  00424	74 15		 je	 SHORT $L2114
  00426	8d 45 e4	 lea	 eax, DWORD PTR _T$[ebp]
  00429	50		 push	 eax
  0042a	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR _W$[ebp+12]
  00430	50		 push	 eax
  00431	e8 00 00 00 00	 call	 _mpi_free
  00436	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1432 :     else mpi_free( &W[1], &T, &RR, NULL );

  00439	eb 17		 jmp	 SHORT $L2116
$L2114:
  0043b	8d 45 d8	 lea	 eax, DWORD PTR _RR$[ebp]
  0043e	50		 push	 eax
  0043f	8d 45 e4	 lea	 eax, DWORD PTR _T$[ebp]
  00442	50		 push	 eax
  00443	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR _W$[ebp+12]
  00449	50		 push	 eax
  0044a	e8 00 00 00 00	 call	 _mpi_free
  0044f	83 c4 10	 add	 esp, 16			; 00000010H
$L2116:

; 1433 : 
; 1434 :     return( ret );

  00452	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
  00455	eb 03		 jmp	 SHORT $L2043
$L2059:

; 1271 :         return( ERR_MPI_INVALID_PARAMETER );

  00457	6a 06		 push	 6
  00459	58		 pop	 eax
$L2043:
  0045a	5f		 pop	 edi
  0045b	5b		 pop	 ebx

; 1435 : }

  0045c	c9		 leave
  0045d	c3		 ret	 0
_mpi_exp_mod ENDP
_TEXT	ENDS
;	COMDAT _mpi_montg_init
_TEXT	SEGMENT
_mm$ = 8
_N$ = 12
_mpi_montg_init PROC NEAR				; COMDAT

; 1196 :     t_int x, m0 = N->p[0];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _N$[esp-4]
  00004	56		 push	 esi

; 1197 : 
; 1198 :     x  = m0;
; 1199 :     x += ((m0 + 2) & 4) << 1;
; 1200 :     x *= (2 - (m0 * x));

  00005	6a 02		 push	 2
  00007	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000a	5a		 pop	 edx

; 1201 : 
; 1202 :     if( biL >= 16 ) x *= (2 - (m0 * x));

  0000b	6a 02		 push	 2
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	8d 4c 00 04	 lea	 ecx, DWORD PTR [eax+eax+4]
  00013	83 e1 08	 and	 ecx, 8
  00016	03 c8		 add	 ecx, eax
  00018	8b f1		 mov	 esi, ecx
  0001a	0f af f0	 imul	 esi, eax
  0001d	2b d6		 sub	 edx, esi
  0001f	0f af d1	 imul	 edx, ecx
  00022	8b f2		 mov	 esi, edx
  00024	59		 pop	 ecx
  00025	0f af f0	 imul	 esi, eax
  00028	2b ce		 sub	 ecx, esi

; 1203 :     if( biL >= 32 ) x *= (2 - (m0 * x));

  0002a	6a 02		 push	 2
  0002c	0f af ca	 imul	 ecx, edx
  0002f	8b d1		 mov	 edx, ecx
  00031	0f af d0	 imul	 edx, eax
  00034	58		 pop	 eax
  00035	5e		 pop	 esi
  00036	2b c2		 sub	 eax, edx
  00038	0f af c1	 imul	 eax, ecx

; 1204 :     if( biL >= 64 ) x *= (2 - (m0 * x));
; 1205 : 
; 1206 :     *mm = ~x + 1;

  0003b	8b 4c 24 04	 mov	 ecx, DWORD PTR _mm$[esp-4]
  0003f	f7 d0		 not	 eax
  00041	40		 inc	 eax
  00042	89 01		 mov	 DWORD PTR [ecx], eax

; 1207 : }

  00044	c3		 ret	 0
_mpi_montg_init ENDP
_TEXT	ENDS
;	COMDAT _mpi_montmul
_TEXT	SEGMENT
_A$ = 8
_B$ = 12
_N$ = 16
_mm$ = 20
_T$ = 24
_i$ = -4
_n$ = -12
_m$ = -8
_mpi_montmul PROC NEAR					; COMDAT

; 1213 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1214 :     int i, n, m;
; 1215 :     t_int u0, u1, *d;
; 1216 : 
; 1217 :     memset( T->p, 0, ciL * T->n );

  00008	8b 75 18	 mov	 esi, DWORD PTR _T$[ebp]
  0000b	57		 push	 edi
  0000c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000f	c1 e0 02	 shl	 eax, 2
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	ff 76 08	 push	 DWORD PTR [esi+8]
  00018	e8 00 00 00 00	 call	 _memset

; 1218 : 
; 1219 :     d = T->p;
; 1220 :     n = N->n;

  0001d	8b 45 10	 mov	 eax, DWORD PTR _N$[ebp]
  00020	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]

; 1221 :     m = ( B->n < n ) ? B->n : n;

  00029	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  0002c	89 5d f4	 mov	 DWORD PTR _n$[ebp], ebx
  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	3b c3		 cmp	 eax, ebx
  00034	89 45 f8	 mov	 DWORD PTR _m$[ebp], eax
  00037	7c 03		 jl	 SHORT $L2673
  00039	89 5d f8	 mov	 DWORD PTR _m$[ebp], ebx
$L2673:

; 1222 : 
; 1223 :     for( i = 0; i < n; i++ )

  0003c	83 65 fc 00	 and	 DWORD PTR _i$[ebp], 0
  00040	85 db		 test	 ebx, ebx
  00042	7e 54		 jle	 SHORT $L2016
$L2014:

; 1224 :     {
; 1225 :         /*
; 1226 :          * T = (T + u0*B + u1*N) / 2^biL
; 1227 :          */
; 1228 :         u0 = A->p[i];

  00044	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0004a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0004d	8b 1c 88	 mov	 ebx, DWORD PTR [eax+ecx*4]

; 1229 :         u1 = ( d[0] + u0 * B->p[0] ) * mm;

  00050	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  00053	8b f3		 mov	 esi, ebx

; 1230 : 
; 1231 :         mpi_mul_hlp( m, B->p, d, u0 );

  00055	53		 push	 ebx
  00056	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00059	57		 push	 edi
  0005a	50		 push	 eax
  0005b	0f af 30	 imul	 esi, DWORD PTR [eax]
  0005e	03 37		 add	 esi, DWORD PTR [edi]
  00060	ff 75 f8	 push	 DWORD PTR _m$[ebp]
  00063	0f af 75 14	 imul	 esi, DWORD PTR _mm$[ebp]
  00067	e8 00 00 00 00	 call	 _mpi_mul_hlp

; 1232 :         mpi_mul_hlp( n, N->p, d, u1 );

  0006c	8b 45 10	 mov	 eax, DWORD PTR _N$[ebp]
  0006f	56		 push	 esi
  00070	8b 75 f4	 mov	 esi, DWORD PTR _n$[ebp]
  00073	57		 push	 edi
  00074	ff 70 08	 push	 DWORD PTR [eax+8]
  00077	56		 push	 esi
  00078	e8 00 00 00 00	 call	 _mpi_mul_hlp

; 1233 : 
; 1234 :         *d++ = u0; d[n + 1] = 0;

  0007d	89 1f		 mov	 DWORD PTR [edi], ebx
  0007f	83 64 b7 08 00	 and	 DWORD PTR [edi+esi*4+8], 0
  00084	83 c7 04	 add	 edi, 4
  00087	83 c4 20	 add	 esp, 32			; 00000020H
  0008a	ff 45 fc	 inc	 DWORD PTR _i$[ebp]
  0008d	39 75 fc	 cmp	 DWORD PTR _i$[ebp], esi
  00090	7c b2		 jl	 SHORT $L2014
  00092	8b 75 18	 mov	 esi, DWORD PTR _T$[ebp]
  00095	8b 5d f4	 mov	 ebx, DWORD PTR _n$[ebp]
$L2016:

; 1235 :     }
; 1236 : 
; 1237 :     memcpy( A->p, d, ciL * (n + 1) );

  00098	8d 04 9d 04 00
	00 00		 lea	 eax, DWORD PTR [ebx*4+4]
  0009f	50		 push	 eax
  000a0	57		 push	 edi
  000a1	8b 7d 08	 mov	 edi, DWORD PTR _A$[ebp]
  000a4	ff 77 08	 push	 DWORD PTR [edi+8]
  000a7	e8 00 00 00 00	 call	 _memcpy

; 1238 : 
; 1239 :     if( mpi_cmp_abs( A, N ) >= 0 )

  000ac	ff 75 10	 push	 DWORD PTR _N$[ebp]
  000af	57		 push	 edi
  000b0	e8 00 00 00 00	 call	 _mpi_cmp_abs
  000b5	83 c4 14	 add	 esp, 20			; 00000014H
  000b8	85 c0		 test	 eax, eax
  000ba	7c 0b		 jl	 SHORT $L2019

; 1240 :         mpi_sub_hlp( n, N->p, A->p );

  000bc	ff 77 08	 push	 DWORD PTR [edi+8]
  000bf	8b 45 10	 mov	 eax, DWORD PTR _N$[ebp]
  000c2	ff 70 08	 push	 DWORD PTR [eax+8]

; 1241 :     else

  000c5	eb 06		 jmp	 SHORT $L2677
$L2019:

; 1242 :         /* prevent timing attacks */
; 1243 :         mpi_sub_hlp( n, A->p, T->p );

  000c7	ff 76 08	 push	 DWORD PTR [esi+8]
  000ca	ff 77 08	 push	 DWORD PTR [edi+8]
$L2677:
  000cd	53		 push	 ebx
  000ce	e8 00 00 00 00	 call	 _mpi_sub_hlp
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx

; 1244 : }

  000d9	c9		 leave
  000da	c3		 ret	 0
_mpi_montmul ENDP
_TEXT	ENDS
;	COMDAT _mpi_montred
_TEXT	SEGMENT
_A$ = 8
_N$ = 12
_mm$ = 16
_T$ = 20
_z$ = -4
_U$ = -16
_mpi_montred PROC NEAR					; COMDAT

; 1250 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1251 :     t_int z = 1;

  00006	6a 01		 push	 1
  00008	58		 pop	 eax

; 1252 :     mpi U;
; 1253 : 
; 1254 :     U.n = U.s = z;
; 1255 :     U.p = &z;
; 1256 : 
; 1257 :     mpi_montmul( A, &U, N, mm, T );

  00009	ff 75 14	 push	 DWORD PTR _T$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _z$[ebp], eax
  0000f	89 45 f0	 mov	 DWORD PTR _U$[ebp], eax
  00012	89 45 f4	 mov	 DWORD PTR _U$[ebp+4], eax
  00015	ff 75 10	 push	 DWORD PTR _mm$[ebp]
  00018	8d 45 fc	 lea	 eax, DWORD PTR _z$[ebp]
  0001b	89 45 f8	 mov	 DWORD PTR _U$[ebp+8], eax
  0001e	8d 45 f0	 lea	 eax, DWORD PTR _U$[ebp]
  00021	ff 75 0c	 push	 DWORD PTR _N$[ebp]
  00024	50		 push	 eax
  00025	ff 75 08	 push	 DWORD PTR _A$[ebp]
  00028	e8 00 00 00 00	 call	 _mpi_montmul
  0002d	83 c4 14	 add	 esp, 20			; 00000014H

; 1258 : }

  00030	c9		 leave
  00031	c3		 ret	 0
_mpi_montred ENDP
_TEXT	ENDS
PUBLIC	_mpi_gcd
;	COMDAT _mpi_gcd
_TEXT	SEGMENT
_G$ = 8
_A$ = 12
_B$ = 16
_TG$ = -36
_TA$ = -12
_TB$ = -24
_mpi_gcd PROC NEAR					; COMDAT

; 1441 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1442 :     int ret, count;
; 1443 :     mpi TG, TA, TB;
; 1444 : 
; 1445 :     mpi_init( &TG, &TA, &TB, NULL );

  00009	8d 45 e8	 lea	 eax, DWORD PTR _TB$[ebp]
  0000c	6a 00		 push	 0
  0000e	50		 push	 eax
  0000f	8d 45 f4	 lea	 eax, DWORD PTR _TA$[ebp]
  00012	50		 push	 eax
  00013	8d 45 dc	 lea	 eax, DWORD PTR _TG$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _mpi_init

; 1446 : 
; 1447 :     CHK( mpi_lset( &TG, 1 ) );

  0001c	6a 01		 push	 1
  0001e	8d 45 dc	 lea	 eax, DWORD PTR _TG$[ebp]
  00021	5b		 pop	 ebx
  00022	53		 push	 ebx
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _mpi_lset
  00029	8b f0		 mov	 esi, eax
  0002b	83 c4 18	 add	 esp, 24			; 00000018H
  0002e	85 f6		 test	 esi, esi
  00030	0f 85 5a 01 00
	00		 jne	 $cleanup$2132

; 1448 :     CHK( mpi_copy( &TA, A ) );

  00036	ff 75 0c	 push	 DWORD PTR _A$[ebp]
  00039	8d 45 f4	 lea	 eax, DWORD PTR _TA$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _mpi_copy
  00042	8b f0		 mov	 esi, eax
  00044	59		 pop	 ecx
  00045	85 f6		 test	 esi, esi
  00047	59		 pop	 ecx
  00048	0f 85 42 01 00
	00		 jne	 $cleanup$2132

; 1449 :     CHK( mpi_copy( &TB, B ) );

  0004e	ff 75 10	 push	 DWORD PTR _B$[ebp]
  00051	8d 45 e8	 lea	 eax, DWORD PTR _TB$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _mpi_copy
  0005a	8b f0		 mov	 esi, eax
  0005c	59		 pop	 ecx
  0005d	85 f6		 test	 esi, esi
  0005f	59		 pop	 ecx
  00060	0f 85 2a 01 00
	00		 jne	 $cleanup$2132

; 1450 : 
; 1451 :     TA.s = TB.s = 1;
; 1452 : 
; 1453 :     count = ( mpi_lsb( &TA ) < mpi_lsb( &TB ) )
; 1454 :             ? mpi_lsb( &TA ) : mpi_lsb( &TB );

  00066	8d 45 f4	 lea	 eax, DWORD PTR _TA$[ebp]
  00069	89 5d e8	 mov	 DWORD PTR _TB$[ebp], ebx
  0006c	50		 push	 eax
  0006d	89 5d f4	 mov	 DWORD PTR _TA$[ebp], ebx
  00070	e8 00 00 00 00	 call	 _mpi_lsb
  00075	8b f0		 mov	 esi, eax
  00077	8d 45 e8	 lea	 eax, DWORD PTR _TB$[ebp]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _mpi_lsb
  00080	59		 pop	 ecx
  00081	3b f0		 cmp	 esi, eax
  00083	59		 pop	 ecx
  00084	8d 45 f4	 lea	 eax, DWORD PTR _TA$[ebp]
  00087	7c 03		 jl	 SHORT $L2695
  00089	8d 45 e8	 lea	 eax, DWORD PTR _TB$[ebp]
$L2695:
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _mpi_lsb
  00092	59		 pop	 ecx
  00093	8b f8		 mov	 edi, eax

; 1455 : 
; 1456 :     CHK( mpi_shift_l( &TG, count ) );

  00095	8d 45 dc	 lea	 eax, DWORD PTR _TG$[ebp]
  00098	57		 push	 edi
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _mpi_shift_l
  0009f	8b f0		 mov	 esi, eax
  000a1	59		 pop	 ecx
  000a2	85 f6		 test	 esi, esi
  000a4	59		 pop	 ecx
  000a5	0f 85 e5 00 00
	00		 jne	 $cleanup$2132

; 1457 :     CHK( mpi_shift_r( &TA, count ) );

  000ab	8d 45 f4	 lea	 eax, DWORD PTR _TA$[ebp]
  000ae	57		 push	 edi
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _mpi_shift_r
  000b5	8b f0		 mov	 esi, eax
  000b7	59		 pop	 ecx
  000b8	85 f6		 test	 esi, esi
  000ba	59		 pop	 ecx
  000bb	0f 85 cf 00 00
	00		 jne	 $cleanup$2132

; 1458 :     CHK( mpi_shift_r( &TB, count ) );

  000c1	57		 push	 edi
$L2700:
  000c2	8d 45 e8	 lea	 eax, DWORD PTR _TB$[ebp]
$L2699:
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _mpi_shift_r
  000cb	8b f0		 mov	 esi, eax
  000cd	59		 pop	 ecx
  000ce	85 f6		 test	 esi, esi
  000d0	59		 pop	 ecx
  000d1	0f 85 b9 00 00
	00		 jne	 $cleanup$2132

; 1459 : 
; 1460 :     while( mpi_cmp_int( &TA, 0 ) != 0 )

  000d7	50		 push	 eax
  000d8	8d 45 f4	 lea	 eax, DWORD PTR _TA$[ebp]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _mpi_cmp_int
  000e1	59		 pop	 ecx
  000e2	85 c0		 test	 eax, eax
  000e4	59		 pop	 ecx
  000e5	0f 84 90 00 00
	00		 je	 $L2140
$L2697:

; 1461 :     {
; 1462 :         while( ( TA.p[0] & 1 ) == 0 ) CHK( mpi_shift_r( &TA, 1 ) );

  000eb	8b 45 fc	 mov	 eax, DWORD PTR _TA$[ebp+8]
  000ee	84 18		 test	 BYTE PTR [eax], bl
  000f0	75 18		 jne	 SHORT $L2698
  000f2	8d 45 f4	 lea	 eax, DWORD PTR _TA$[ebp]
  000f5	53		 push	 ebx
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _mpi_shift_r
  000fc	8b f0		 mov	 esi, eax
  000fe	59		 pop	 ecx
  000ff	85 f6		 test	 esi, esi
  00101	59		 pop	 ecx
  00102	0f 85 88 00 00
	00		 jne	 $cleanup$2132
  00108	eb e1		 jmp	 SHORT $L2697
$L2698:

; 1463 :         while( ( TB.p[0] & 1 ) == 0 ) CHK( mpi_shift_r( &TB, 1 ) );

  0010a	8b 45 f0	 mov	 eax, DWORD PTR _TB$[ebp+8]
  0010d	84 18		 test	 BYTE PTR [eax], bl
  0010f	75 14		 jne	 SHORT $L2147
  00111	8d 45 e8	 lea	 eax, DWORD PTR _TB$[ebp]
  00114	53		 push	 ebx
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 _mpi_shift_r
  0011b	8b f0		 mov	 esi, eax
  0011d	59		 pop	 ecx
  0011e	85 f6		 test	 esi, esi
  00120	59		 pop	 ecx
  00121	75 6d		 jne	 SHORT $cleanup$2132
  00123	eb e5		 jmp	 SHORT $L2698
$L2147:

; 1464 : 
; 1465 :         if( mpi_cmp_mpi( &TA, &TB ) >= 0 )

  00125	8d 45 e8	 lea	 eax, DWORD PTR _TB$[ebp]
  00128	50		 push	 eax
  00129	8d 45 f4	 lea	 eax, DWORD PTR _TA$[ebp]
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 _mpi_cmp_mpi
  00132	59		 pop	 ecx
  00133	85 c0		 test	 eax, eax
  00135	59		 pop	 ecx
  00136	7c 23		 jl	 SHORT $L2149

; 1466 :         {
; 1467 :             CHK( mpi_sub_abs( &TA, &TA, &TB ) );

  00138	8d 45 e8	 lea	 eax, DWORD PTR _TB$[ebp]
  0013b	50		 push	 eax
  0013c	8d 45 f4	 lea	 eax, DWORD PTR _TA$[ebp]
  0013f	50		 push	 eax
  00140	8d 45 f4	 lea	 eax, DWORD PTR _TA$[ebp]
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 _mpi_sub_abs
  00149	8b f0		 mov	 esi, eax
  0014b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014e	85 f6		 test	 esi, esi
  00150	75 3e		 jne	 SHORT $cleanup$2132

; 1468 :             CHK( mpi_shift_r( &TA, 1 ) );

  00152	53		 push	 ebx
  00153	8d 45 f4	 lea	 eax, DWORD PTR _TA$[ebp]

; 1469 :         }
; 1470 :         else

  00156	e9 6a ff ff ff	 jmp	 $L2699
$L2149:

; 1471 :         {
; 1472 :             CHK( mpi_sub_abs( &TB, &TB, &TA ) );

  0015b	8d 45 f4	 lea	 eax, DWORD PTR _TA$[ebp]
  0015e	50		 push	 eax
  0015f	8d 45 e8	 lea	 eax, DWORD PTR _TB$[ebp]
  00162	50		 push	 eax
  00163	8d 45 e8	 lea	 eax, DWORD PTR _TB$[ebp]
  00166	50		 push	 eax
  00167	e8 00 00 00 00	 call	 _mpi_sub_abs
  0016c	8b f0		 mov	 esi, eax
  0016e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00171	85 f6		 test	 esi, esi
  00173	75 1b		 jne	 SHORT $cleanup$2132

; 1473 :             CHK( mpi_shift_r( &TB, 1 ) );

  00175	53		 push	 ebx

; 1459 : 
; 1460 :     while( mpi_cmp_int( &TA, 0 ) != 0 )

  00176	e9 47 ff ff ff	 jmp	 $L2700
$L2140:

; 1474 :         }
; 1475 :     }
; 1476 : 
; 1477 :     CHK( mpi_mul_mpi( G, &TG, &TB ) );

  0017b	8d 45 e8	 lea	 eax, DWORD PTR _TB$[ebp]
  0017e	50		 push	 eax
  0017f	8d 45 dc	 lea	 eax, DWORD PTR _TG$[ebp]
  00182	50		 push	 eax
  00183	ff 75 08	 push	 DWORD PTR _G$[ebp]
  00186	e8 00 00 00 00	 call	 _mpi_mul_mpi
  0018b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018e	8b f0		 mov	 esi, eax
$cleanup$2132:

; 1478 : 
; 1479 : cleanup:
; 1480 : 
; 1481 :     mpi_free( &TB, &TA, &TG, NULL );

  00190	8d 45 dc	 lea	 eax, DWORD PTR _TG$[ebp]
  00193	6a 00		 push	 0
  00195	50		 push	 eax
  00196	8d 45 f4	 lea	 eax, DWORD PTR _TA$[ebp]
  00199	50		 push	 eax
  0019a	8d 45 e8	 lea	 eax, DWORD PTR _TB$[ebp]
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 _mpi_free
  001a3	83 c4 10	 add	 esp, 16			; 00000010H

; 1482 :     return( ret );

  001a6	8b c6		 mov	 eax, esi
  001a8	5f		 pop	 edi
  001a9	5e		 pop	 esi
  001aa	5b		 pop	 ebx

; 1483 : }

  001ab	c9		 leave
  001ac	c3		 ret	 0
_mpi_gcd ENDP
_TEXT	ENDS
PUBLIC	_mpi_inv_mod
;	COMDAT _mpi_inv_mod
_TEXT	SEGMENT
_X$ = 8
_A$ = 12
_N$ = 16
_G$ = -108
_TA$ = -84
_TU$ = -24
_U1$ = -36
_U2$ = -48
_TB$ = -96
_TV$ = -60
_V1$ = -12
_V2$ = -72
_mpi_inv_mod PROC NEAR					; COMDAT

; 1489 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	57		 push	 edi

; 1490 :     int ret;
; 1491 :     mpi G, TA, TU, U1, U2, TB, TV, V1, V2;
; 1492 : 
; 1493 :     if( mpi_cmp_int( N, 0 ) <= 0 )

  00007	33 ff		 xor	 edi, edi
  00009	57		 push	 edi
  0000a	ff 75 10	 push	 DWORD PTR _N$[ebp]
  0000d	e8 00 00 00 00	 call	 _mpi_cmp_int
  00012	59		 pop	 ecx
  00013	85 c0		 test	 eax, eax
  00015	59		 pop	 ecx
  00016	7f 08		 jg	 SHORT $L2174

; 1494 :         return( ERR_MPI_INVALID_PARAMETER );

  00018	6a 06		 push	 6
  0001a	58		 pop	 eax
  0001b	e9 ab 03 00 00	 jmp	 $L2163
$L2174:
  00020	53		 push	 ebx
  00021	56		 push	 esi

; 1495 : 
; 1496 :     mpi_init( &TA, &TU, &U1, &U2, &G,
; 1497 :               &TB, &TV, &V1, &V2, NULL );

  00022	8d 45 b8	 lea	 eax, DWORD PTR _V2$[ebp]
  00025	57		 push	 edi
  00026	50		 push	 eax
  00027	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  0002a	50		 push	 eax
  0002b	8d 45 c4	 lea	 eax, DWORD PTR _TV$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 a0	 lea	 eax, DWORD PTR _TB$[ebp]
  00032	50		 push	 eax
  00033	8d 45 94	 lea	 eax, DWORD PTR _G$[ebp]
  00036	50		 push	 eax
  00037	8d 45 d0	 lea	 eax, DWORD PTR _U2$[ebp]
  0003a	50		 push	 eax
  0003b	8d 45 dc	 lea	 eax, DWORD PTR _U1$[ebp]
  0003e	50		 push	 eax
  0003f	8d 45 e8	 lea	 eax, DWORD PTR _TU$[ebp]
  00042	50		 push	 eax
  00043	8d 45 ac	 lea	 eax, DWORD PTR _TA$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _mpi_init

; 1498 : 
; 1499 :     CHK( mpi_gcd( &G, A, N ) );

  0004c	ff 75 10	 push	 DWORD PTR _N$[ebp]
  0004f	8d 45 94	 lea	 eax, DWORD PTR _G$[ebp]
  00052	ff 75 0c	 push	 DWORD PTR _A$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _mpi_gcd
  0005b	8b f0		 mov	 esi, eax
  0005d	83 c4 34	 add	 esp, 52			; 00000034H
  00060	3b f7		 cmp	 esi, edi
  00062	0f 85 32 03 00
	00		 jne	 $cleanup$2177

; 1500 : 
; 1501 :     if( mpi_cmp_int( &G, 1 ) != 0 )

  00068	6a 01		 push	 1
  0006a	8d 45 94	 lea	 eax, DWORD PTR _G$[ebp]
  0006d	5b		 pop	 ebx
  0006e	53		 push	 ebx
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _mpi_cmp_int
  00075	59		 pop	 ecx
  00076	85 c0		 test	 eax, eax
  00078	59		 pop	 ecx
  00079	74 08		 je	 SHORT $L2178

; 1502 :     {
; 1503 :         ret = ERR_MPI_NOT_ACCEPTABLE;

  0007b	6a 0e		 push	 14			; 0000000eH
  0007d	5e		 pop	 esi

; 1504 :         goto cleanup;

  0007e	e9 17 03 00 00	 jmp	 $cleanup$2177
$L2178:

; 1505 :     }
; 1506 : 
; 1507 :     CHK( mpi_mod_mpi( &TA, A, N ) );

  00083	ff 75 10	 push	 DWORD PTR _N$[ebp]
  00086	8d 45 ac	 lea	 eax, DWORD PTR _TA$[ebp]
  00089	ff 75 0c	 push	 DWORD PTR _A$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _mpi_mod_mpi
  00092	8b f0		 mov	 esi, eax
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
  00097	3b f7		 cmp	 esi, edi
  00099	0f 85 fb 02 00
	00		 jne	 $cleanup$2177

; 1508 :     CHK( mpi_copy( &TU, &TA ) );

  0009f	8d 45 ac	 lea	 eax, DWORD PTR _TA$[ebp]
  000a2	50		 push	 eax
  000a3	8d 45 e8	 lea	 eax, DWORD PTR _TU$[ebp]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 _mpi_copy
  000ac	8b f0		 mov	 esi, eax
  000ae	59		 pop	 ecx
  000af	3b f7		 cmp	 esi, edi
  000b1	59		 pop	 ecx
  000b2	0f 85 e2 02 00
	00		 jne	 $cleanup$2177

; 1509 :     CHK( mpi_copy( &TB, N ) );

  000b8	ff 75 10	 push	 DWORD PTR _N$[ebp]
  000bb	8d 45 a0	 lea	 eax, DWORD PTR _TB$[ebp]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _mpi_copy
  000c4	8b f0		 mov	 esi, eax
  000c6	59		 pop	 ecx
  000c7	3b f7		 cmp	 esi, edi
  000c9	59		 pop	 ecx
  000ca	0f 85 ca 02 00
	00		 jne	 $cleanup$2177

; 1510 :     CHK( mpi_copy( &TV, N ) );

  000d0	ff 75 10	 push	 DWORD PTR _N$[ebp]
  000d3	8d 45 c4	 lea	 eax, DWORD PTR _TV$[ebp]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _mpi_copy
  000dc	8b f0		 mov	 esi, eax
  000de	59		 pop	 ecx
  000df	3b f7		 cmp	 esi, edi
  000e1	59		 pop	 ecx
  000e2	0f 85 b2 02 00
	00		 jne	 $cleanup$2177

; 1511 : 
; 1512 :     CHK( mpi_lset( &U1, 1 ) );

  000e8	8d 45 dc	 lea	 eax, DWORD PTR _U1$[ebp]
  000eb	53		 push	 ebx
  000ec	50		 push	 eax
  000ed	e8 00 00 00 00	 call	 _mpi_lset
  000f2	8b f0		 mov	 esi, eax
  000f4	59		 pop	 ecx
  000f5	3b f7		 cmp	 esi, edi
  000f7	59		 pop	 ecx
  000f8	0f 85 9c 02 00
	00		 jne	 $cleanup$2177

; 1513 :     CHK( mpi_lset( &U2, 0 ) );

  000fe	8d 45 d0	 lea	 eax, DWORD PTR _U2$[ebp]
  00101	57		 push	 edi
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 _mpi_lset
  00108	8b f0		 mov	 esi, eax
  0010a	59		 pop	 ecx
  0010b	3b f7		 cmp	 esi, edi
  0010d	59		 pop	 ecx
  0010e	0f 85 86 02 00
	00		 jne	 $cleanup$2177

; 1514 :     CHK( mpi_lset( &V1, 0 ) );

  00114	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  00117	57		 push	 edi
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 _mpi_lset
  0011e	8b f0		 mov	 esi, eax
  00120	59		 pop	 ecx
  00121	3b f7		 cmp	 esi, edi
  00123	59		 pop	 ecx
  00124	0f 85 70 02 00
	00		 jne	 $cleanup$2177

; 1515 :     CHK( mpi_lset( &V2, 1 ) );

  0012a	8d 45 b8	 lea	 eax, DWORD PTR _V2$[ebp]
  0012d	53		 push	 ebx
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 _mpi_lset
$L2727:
  00134	8b f0		 mov	 esi, eax
  00136	59		 pop	 ecx
  00137	3b f7		 cmp	 esi, edi
  00139	59		 pop	 ecx
  0013a	0f 85 5a 02 00
	00		 jne	 $cleanup$2177
$L2726:

; 1516 : 
; 1517 :     do
; 1518 :     {
; 1519 :         while( ( TU.p[0] & 1 ) == 0 )

  00140	8b 45 f0	 mov	 eax, DWORD PTR _TU$[ebp+8]
  00143	84 18		 test	 BYTE PTR [eax], bl
  00145	0f 85 85 00 00
	00		 jne	 $L2728

; 1520 :         {
; 1521 :             CHK( mpi_shift_r( &TU, 1 ) );

  0014b	8d 45 e8	 lea	 eax, DWORD PTR _TU$[ebp]
  0014e	53		 push	 ebx
  0014f	50		 push	 eax
  00150	e8 00 00 00 00	 call	 _mpi_shift_r
  00155	8b f0		 mov	 esi, eax
  00157	59		 pop	 ecx
  00158	3b f7		 cmp	 esi, edi
  0015a	59		 pop	 ecx
  0015b	0f 85 39 02 00
	00		 jne	 $cleanup$2177

; 1522 : 
; 1523 :             if( ( U1.p[0] & 1 ) != 0 || ( U2.p[0] & 1 ) != 0 )

  00161	8b 45 e4	 mov	 eax, DWORD PTR _U1$[ebp+8]
  00164	84 18		 test	 BYTE PTR [eax], bl
  00166	75 07		 jne	 SHORT $L2195
  00168	8b 45 d8	 mov	 eax, DWORD PTR _U2$[ebp+8]
  0016b	84 18		 test	 BYTE PTR [eax], bl
  0016d	74 3c		 je	 SHORT $L2197
$L2195:

; 1524 :             {
; 1525 :                 CHK( mpi_add_mpi( &U1, &U1, &TB ) );

  0016f	8d 45 a0	 lea	 eax, DWORD PTR _TB$[ebp]
  00172	50		 push	 eax
  00173	8d 45 dc	 lea	 eax, DWORD PTR _U1$[ebp]
  00176	50		 push	 eax
  00177	8d 45 dc	 lea	 eax, DWORD PTR _U1$[ebp]
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 _mpi_add_mpi
  00180	8b f0		 mov	 esi, eax
  00182	83 c4 0c	 add	 esp, 12			; 0000000cH
  00185	3b f7		 cmp	 esi, edi
  00187	0f 85 0d 02 00
	00		 jne	 $cleanup$2177

; 1526 :                 CHK( mpi_sub_mpi( &U2, &U2, &TA ) );

  0018d	8d 45 ac	 lea	 eax, DWORD PTR _TA$[ebp]
  00190	50		 push	 eax
  00191	8d 45 d0	 lea	 eax, DWORD PTR _U2$[ebp]
  00194	50		 push	 eax
  00195	8d 45 d0	 lea	 eax, DWORD PTR _U2$[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _mpi_sub_mpi
  0019e	8b f0		 mov	 esi, eax
  001a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a3	3b f7		 cmp	 esi, edi
  001a5	0f 85 ef 01 00
	00		 jne	 $cleanup$2177
$L2197:

; 1527 :             }
; 1528 : 
; 1529 :             CHK( mpi_shift_r( &U1, 1 ) );

  001ab	8d 45 dc	 lea	 eax, DWORD PTR _U1$[ebp]
  001ae	53		 push	 ebx
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 _mpi_shift_r
  001b5	8b f0		 mov	 esi, eax
  001b7	59		 pop	 ecx
  001b8	3b f7		 cmp	 esi, edi
  001ba	59		 pop	 ecx
  001bb	0f 85 d9 01 00
	00		 jne	 $cleanup$2177

; 1530 :             CHK( mpi_shift_r( &U2, 1 ) );

  001c1	8d 45 d0	 lea	 eax, DWORD PTR _U2$[ebp]
  001c4	53		 push	 ebx
  001c5	50		 push	 eax
  001c6	e8 00 00 00 00	 call	 _mpi_shift_r
  001cb	e9 64 ff ff ff	 jmp	 $L2727
$L2728:

; 1531 :         }
; 1532 : 
; 1533 :         while( ( TV.p[0] & 1 ) == 0 )

  001d0	8b 45 cc	 mov	 eax, DWORD PTR _TV$[ebp+8]
  001d3	84 18		 test	 BYTE PTR [eax], bl
  001d5	0f 85 91 00 00
	00		 jne	 $L2202

; 1534 :         {
; 1535 :             CHK( mpi_shift_r( &TV, 1 ) );

  001db	8d 45 c4	 lea	 eax, DWORD PTR _TV$[ebp]
  001de	53		 push	 ebx
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 _mpi_shift_r
  001e5	8b f0		 mov	 esi, eax
  001e7	59		 pop	 ecx
  001e8	3b f7		 cmp	 esi, edi
  001ea	59		 pop	 ecx
  001eb	0f 85 a9 01 00
	00		 jne	 $cleanup$2177

; 1536 : 
; 1537 :             if( ( V1.p[0] & 1 ) != 0 || ( V2.p[0] & 1 ) != 0 )

  001f1	8b 45 fc	 mov	 eax, DWORD PTR _V1$[ebp+8]
  001f4	84 18		 test	 BYTE PTR [eax], bl
  001f6	75 07		 jne	 SHORT $L2205
  001f8	8b 45 c0	 mov	 eax, DWORD PTR _V2$[ebp+8]
  001fb	84 18		 test	 BYTE PTR [eax], bl
  001fd	74 3c		 je	 SHORT $L2207
$L2205:

; 1538 :             {
; 1539 :                 CHK( mpi_add_mpi( &V1, &V1, &TB ) );

  001ff	8d 45 a0	 lea	 eax, DWORD PTR _TB$[ebp]
  00202	50		 push	 eax
  00203	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  00206	50		 push	 eax
  00207	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  0020a	50		 push	 eax
  0020b	e8 00 00 00 00	 call	 _mpi_add_mpi
  00210	8b f0		 mov	 esi, eax
  00212	83 c4 0c	 add	 esp, 12			; 0000000cH
  00215	3b f7		 cmp	 esi, edi
  00217	0f 85 7d 01 00
	00		 jne	 $cleanup$2177

; 1540 :                 CHK( mpi_sub_mpi( &V2, &V2, &TA ) );

  0021d	8d 45 ac	 lea	 eax, DWORD PTR _TA$[ebp]
  00220	50		 push	 eax
  00221	8d 45 b8	 lea	 eax, DWORD PTR _V2$[ebp]
  00224	50		 push	 eax
  00225	8d 45 b8	 lea	 eax, DWORD PTR _V2$[ebp]
  00228	50		 push	 eax
  00229	e8 00 00 00 00	 call	 _mpi_sub_mpi
  0022e	8b f0		 mov	 esi, eax
  00230	83 c4 0c	 add	 esp, 12			; 0000000cH
  00233	3b f7		 cmp	 esi, edi
  00235	0f 85 5f 01 00
	00		 jne	 $cleanup$2177
$L2207:

; 1541 :             }
; 1542 : 
; 1543 :             CHK( mpi_shift_r( &V1, 1 ) );

  0023b	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  0023e	53		 push	 ebx
  0023f	50		 push	 eax
  00240	e8 00 00 00 00	 call	 _mpi_shift_r
  00245	8b f0		 mov	 esi, eax
  00247	59		 pop	 ecx
  00248	3b f7		 cmp	 esi, edi
  0024a	59		 pop	 ecx
  0024b	0f 85 49 01 00
	00		 jne	 $cleanup$2177

; 1544 :             CHK( mpi_shift_r( &V2, 1 ) );

  00251	8d 45 b8	 lea	 eax, DWORD PTR _V2$[ebp]
  00254	53		 push	 ebx
  00255	50		 push	 eax
  00256	e8 00 00 00 00	 call	 _mpi_shift_r
  0025b	8b f0		 mov	 esi, eax
  0025d	59		 pop	 ecx
  0025e	3b f7		 cmp	 esi, edi
  00260	59		 pop	 ecx
  00261	0f 85 33 01 00
	00		 jne	 $cleanup$2177

; 1531 :         }
; 1532 : 
; 1533 :         while( ( TV.p[0] & 1 ) == 0 )

  00267	e9 64 ff ff ff	 jmp	 $L2728
$L2202:

; 1545 :         }
; 1546 : 
; 1547 :         if( mpi_cmp_mpi( &TU, &TV ) >= 0 )

  0026c	8d 45 c4	 lea	 eax, DWORD PTR _TV$[ebp]
  0026f	50		 push	 eax
  00270	8d 45 e8	 lea	 eax, DWORD PTR _TU$[ebp]
  00273	50		 push	 eax
  00274	e8 00 00 00 00	 call	 _mpi_cmp_mpi
  00279	59		 pop	 ecx
  0027a	85 c0		 test	 eax, eax
  0027c	59		 pop	 ecx
  0027d	7c 49		 jl	 SHORT $L2210

; 1548 :         {
; 1549 :             CHK( mpi_sub_mpi( &TU, &TU, &TV ) );

  0027f	8d 45 c4	 lea	 eax, DWORD PTR _TV$[ebp]
  00282	50		 push	 eax
  00283	8d 45 e8	 lea	 eax, DWORD PTR _TU$[ebp]
  00286	50		 push	 eax
  00287	8d 45 e8	 lea	 eax, DWORD PTR _TU$[ebp]
  0028a	50		 push	 eax
  0028b	e8 00 00 00 00	 call	 _mpi_sub_mpi
  00290	8b f0		 mov	 esi, eax
  00292	83 c4 0c	 add	 esp, 12			; 0000000cH
  00295	3b f7		 cmp	 esi, edi
  00297	0f 85 fd 00 00
	00		 jne	 $cleanup$2177

; 1550 :             CHK( mpi_sub_mpi( &U1, &U1, &V1 ) );

  0029d	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  002a0	50		 push	 eax
  002a1	8d 45 dc	 lea	 eax, DWORD PTR _U1$[ebp]
  002a4	50		 push	 eax
  002a5	8d 45 dc	 lea	 eax, DWORD PTR _U1$[ebp]
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 _mpi_sub_mpi
  002ae	8b f0		 mov	 esi, eax
  002b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b3	3b f7		 cmp	 esi, edi
  002b5	0f 85 df 00 00
	00		 jne	 $cleanup$2177

; 1551 :             CHK( mpi_sub_mpi( &U2, &U2, &V2 ) );

  002bb	8d 45 b8	 lea	 eax, DWORD PTR _V2$[ebp]
  002be	50		 push	 eax
  002bf	8d 45 d0	 lea	 eax, DWORD PTR _U2$[ebp]
  002c2	50		 push	 eax
  002c3	8d 45 d0	 lea	 eax, DWORD PTR _U2$[ebp]

; 1552 :         }
; 1553 :         else

  002c6	eb 47		 jmp	 SHORT $L2729
$L2210:

; 1554 :         {
; 1555 :             CHK( mpi_sub_mpi( &TV, &TV, &TU ) );

  002c8	8d 45 e8	 lea	 eax, DWORD PTR _TU$[ebp]
  002cb	50		 push	 eax
  002cc	8d 45 c4	 lea	 eax, DWORD PTR _TV$[ebp]
  002cf	50		 push	 eax
  002d0	8d 45 c4	 lea	 eax, DWORD PTR _TV$[ebp]
  002d3	50		 push	 eax
  002d4	e8 00 00 00 00	 call	 _mpi_sub_mpi
  002d9	8b f0		 mov	 esi, eax
  002db	83 c4 0c	 add	 esp, 12			; 0000000cH
  002de	3b f7		 cmp	 esi, edi
  002e0	0f 85 b4 00 00
	00		 jne	 $cleanup$2177

; 1556 :             CHK( mpi_sub_mpi( &V1, &V1, &U1 ) );

  002e6	8d 45 dc	 lea	 eax, DWORD PTR _U1$[ebp]
  002e9	50		 push	 eax
  002ea	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  002ed	50		 push	 eax
  002ee	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  002f1	50		 push	 eax
  002f2	e8 00 00 00 00	 call	 _mpi_sub_mpi
  002f7	8b f0		 mov	 esi, eax
  002f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  002fc	3b f7		 cmp	 esi, edi
  002fe	0f 85 96 00 00
	00		 jne	 $cleanup$2177

; 1557 :             CHK( mpi_sub_mpi( &V2, &V2, &U2 ) );

  00304	8d 45 d0	 lea	 eax, DWORD PTR _U2$[ebp]
  00307	50		 push	 eax
  00308	8d 45 b8	 lea	 eax, DWORD PTR _V2$[ebp]
  0030b	50		 push	 eax
  0030c	8d 45 b8	 lea	 eax, DWORD PTR _V2$[ebp]
$L2729:
  0030f	50		 push	 eax
  00310	e8 00 00 00 00	 call	 _mpi_sub_mpi
  00315	8b f0		 mov	 esi, eax
  00317	83 c4 0c	 add	 esp, 12			; 0000000cH
  0031a	3b f7		 cmp	 esi, edi
  0031c	75 7c		 jne	 SHORT $cleanup$2177

; 1558 :         }
; 1559 :     }
; 1560 :     while( mpi_cmp_int( &TU, 0 ) != 0 );

  0031e	8d 45 e8	 lea	 eax, DWORD PTR _TU$[ebp]
  00321	57		 push	 edi
  00322	50		 push	 eax
  00323	e8 00 00 00 00	 call	 _mpi_cmp_int
  00328	59		 pop	 ecx
  00329	85 c0		 test	 eax, eax
  0032b	59		 pop	 ecx
  0032c	0f 85 0e fe ff
	ff		 jne	 $L2726
$L2730:

; 1561 : 
; 1562 :     while( mpi_cmp_int( &V1, 0 ) < 0 )

  00332	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  00335	57		 push	 edi
  00336	50		 push	 eax
  00337	e8 00 00 00 00	 call	 _mpi_cmp_int
  0033c	59		 pop	 ecx
  0033d	59		 pop	 ecx

; 1563 :       CHK( mpi_add_mpi( &V1, &V1, N ) );

  0033e	ff 75 10	 push	 DWORD PTR _N$[ebp]
  00341	85 c0		 test	 eax, eax
  00343	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  00346	50		 push	 eax
  00347	7d 14		 jge	 SHORT $L2731
  00349	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  0034c	50		 push	 eax
  0034d	e8 00 00 00 00	 call	 _mpi_add_mpi
  00352	8b f0		 mov	 esi, eax
  00354	83 c4 0c	 add	 esp, 12			; 0000000cH
  00357	3b f7		 cmp	 esi, edi
  00359	75 3f		 jne	 SHORT $cleanup$2177

; 1561 : 
; 1562 :     while( mpi_cmp_int( &V1, 0 ) < 0 )

  0035b	eb d5		 jmp	 SHORT $L2730
$L2731:

; 1564 : 
; 1565 :     while( mpi_cmp_mpi( &V1, N ) >= 0 )

  0035d	e8 00 00 00 00	 call	 _mpi_cmp_mpi
  00362	59		 pop	 ecx
  00363	85 c0		 test	 eax, eax
  00365	59		 pop	 ecx
  00366	7c 22		 jl	 SHORT $L2224

; 1566 :       CHK( mpi_sub_mpi( &V1, &V1, N ) );

  00368	ff 75 10	 push	 DWORD PTR _N$[ebp]
  0036b	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  0036e	50		 push	 eax
  0036f	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  00372	50		 push	 eax
  00373	e8 00 00 00 00	 call	 _mpi_sub_mpi
  00378	8b f0		 mov	 esi, eax
  0037a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0037d	3b f7		 cmp	 esi, edi
  0037f	75 19		 jne	 SHORT $cleanup$2177
  00381	ff 75 10	 push	 DWORD PTR _N$[ebp]
  00384	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  00387	50		 push	 eax
  00388	eb d3		 jmp	 SHORT $L2731
$L2224:

; 1567 : 
; 1568 :     CHK( mpi_copy( X, &V1 ) );

  0038a	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  0038d	50		 push	 eax
  0038e	ff 75 08	 push	 DWORD PTR _X$[ebp]
  00391	e8 00 00 00 00	 call	 _mpi_copy
  00396	59		 pop	 ecx
  00397	8b f0		 mov	 esi, eax
  00399	59		 pop	 ecx
$cleanup$2177:

; 1569 : 
; 1570 : cleanup:
; 1571 : 
; 1572 :     mpi_free( &V2, &V1, &TV, &TB, &G,
; 1573 :               &U2, &U1, &TU, &TA, NULL );

  0039a	8d 45 ac	 lea	 eax, DWORD PTR _TA$[ebp]
  0039d	57		 push	 edi
  0039e	50		 push	 eax
  0039f	8d 45 e8	 lea	 eax, DWORD PTR _TU$[ebp]
  003a2	50		 push	 eax
  003a3	8d 45 dc	 lea	 eax, DWORD PTR _U1$[ebp]
  003a6	50		 push	 eax
  003a7	8d 45 d0	 lea	 eax, DWORD PTR _U2$[ebp]
  003aa	50		 push	 eax
  003ab	8d 45 94	 lea	 eax, DWORD PTR _G$[ebp]
  003ae	50		 push	 eax
  003af	8d 45 a0	 lea	 eax, DWORD PTR _TB$[ebp]
  003b2	50		 push	 eax
  003b3	8d 45 c4	 lea	 eax, DWORD PTR _TV$[ebp]
  003b6	50		 push	 eax
  003b7	8d 45 f4	 lea	 eax, DWORD PTR _V1$[ebp]
  003ba	50		 push	 eax
  003bb	8d 45 b8	 lea	 eax, DWORD PTR _V2$[ebp]
  003be	50		 push	 eax
  003bf	e8 00 00 00 00	 call	 _mpi_free
  003c4	83 c4 28	 add	 esp, 40			; 00000028H

; 1574 : 
; 1575 :     return( ret );

  003c7	8b c6		 mov	 eax, esi
  003c9	5e		 pop	 esi
  003ca	5b		 pop	 ebx
$L2163:
  003cb	5f		 pop	 edi

; 1576 : }

  003cc	c9		 leave
  003cd	c3		 ret	 0
_mpi_inv_mod ENDP
_TEXT	ENDS
PUBLIC	_mpi_is_prime
EXTRN	__imp__rand:NEAR
;	COMDAT _mpi_is_prime
_TEXT	SEGMENT
_X$ = 8
_i$ = -4
_s$ = 8
_xs$ = -12
_W$ = -36
_R$ = -48
_T$ = -60
_A$ = -24
_RR$ = -72
_r$2248 = 8
_mpi_is_prime PROC NEAR					; COMDAT

; 1615 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1616 :     int ret, i, j, s, xs;
; 1617 :     mpi W, R, T, A, RR;
; 1618 : 
; 1619 :     if( mpi_cmp_int( X, 0 ) == 0 )

  00009	8b 7d 08	 mov	 edi, DWORD PTR _X$[ebp]
  0000c	33 f6		 xor	 esi, esi
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 _mpi_cmp_int
  00015	59		 pop	 ecx
  00016	85 c0		 test	 eax, eax
  00018	59		 pop	 ecx

; 1620 :         return( 0 );

  00019	0f 84 1f 02 00
	00		 je	 $L2737

; 1621 : 
; 1622 :     mpi_init( &W, &R, &T, &A, &RR, NULL );

  0001f	8d 45 b8	 lea	 eax, DWORD PTR _RR$[ebp]
  00022	56		 push	 esi
  00023	50		 push	 eax
  00024	8d 45 e8	 lea	 eax, DWORD PTR _A$[ebp]
  00027	50		 push	 eax
  00028	8d 45 c4	 lea	 eax, DWORD PTR _T$[ebp]
  0002b	50		 push	 eax
  0002c	8d 45 d0	 lea	 eax, DWORD PTR _R$[ebp]
  0002f	50		 push	 eax
  00030	8d 45 dc	 lea	 eax, DWORD PTR _W$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _mpi_init

; 1623 :     xs = X->s; X->s = 1;

  00039	8b 07		 mov	 eax, DWORD PTR [edi]
  0003b	83 c4 18	 add	 esp, 24			; 00000018H
  0003e	89 45 f4	 mov	 DWORD PTR _xs$[ebp], eax

; 1624 : 
; 1625 :     /*
; 1626 :      * test trivial factors first
; 1627 :      */
; 1628 :     if( ( X->p[0] & 1 ) == 0 )

  00041	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00044	c7 07 01 00 00
	00		 mov	 DWORD PTR [edi], 1
  0004a	f6 00 01	 test	 BYTE PTR [eax], 1

; 1629 :         return( ERR_MPI_NOT_ACCEPTABLE );

  0004d	0f 84 ef 01 00
	00		 je	 $L2739

; 1630 : 
; 1631 :     for( i = 0; small_prime[i] > 0; i++ )

  00053	39 35 00 00 00
	00		 cmp	 DWORD PTR _small_prime, esi
  00059	7e 44		 jle	 SHORT $L2247

; 1632 :     {
; 1633 :         t_int r;
; 1634 : 
; 1635 :         if( mpi_cmp_int( X, small_prime[i] ) <= 0 )

  0005b	bb 00 00 00 00	 mov	 ebx, OFFSET FLAT:_small_prime
  00060	8b c3		 mov	 eax, ebx
$L2245:
  00062	ff 30		 push	 DWORD PTR [eax]
  00064	57		 push	 edi
  00065	e8 00 00 00 00	 call	 _mpi_cmp_int
  0006a	59		 pop	 ecx
  0006b	85 c0		 test	 eax, eax
  0006d	59		 pop	 ecx
  0006e	0f 8e ca 01 00
	00		 jle	 $L2737

; 1637 : 
; 1638 :         CHK( mpi_mod_int( &r, X, small_prime[i] ) );

  00074	ff 33		 push	 DWORD PTR [ebx]
  00076	8d 45 08	 lea	 eax, DWORD PTR _r$2248[ebp]
  00079	57		 push	 edi
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _mpi_mod_int
  00080	8b f0		 mov	 esi, eax
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	85 f6		 test	 esi, esi
  00087	0f 85 bd 01 00
	00		 jne	 $cleanup$2251

; 1639 : 
; 1640 :         if( r == 0 )

  0008d	39 45 08	 cmp	 DWORD PTR _r$2248[ebp], eax
  00090	0f 84 ac 01 00
	00		 je	 $L2739
  00096	83 c3 04	 add	 ebx, 4
  00099	8b c3		 mov	 eax, ebx
  0009b	39 33		 cmp	 DWORD PTR [ebx], esi
  0009d	7f c3		 jg	 SHORT $L2245
$L2247:

; 1642 :     }
; 1643 : 
; 1644 :     /*
; 1645 :      * W = |X| - 1
; 1646 :      * R = W >> lsb( W )
; 1647 :      */
; 1648 :     CHK( mpi_sub_int( &W, X, 1 ) );

  0009f	6a 01		 push	 1
  000a1	8d 45 dc	 lea	 eax, DWORD PTR _W$[ebp]
  000a4	57		 push	 edi
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _mpi_sub_int
  000ab	8b f0		 mov	 esi, eax
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b0	85 f6		 test	 esi, esi
  000b2	0f 85 92 01 00
	00		 jne	 $cleanup$2251

; 1649 :     CHK( mpi_copy( &R, &W ) );

  000b8	8d 45 dc	 lea	 eax, DWORD PTR _W$[ebp]
  000bb	50		 push	 eax
  000bc	8d 45 d0	 lea	 eax, DWORD PTR _R$[ebp]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 _mpi_copy
  000c5	8b f0		 mov	 esi, eax
  000c7	59		 pop	 ecx
  000c8	85 f6		 test	 esi, esi
  000ca	59		 pop	 ecx
  000cb	0f 85 79 01 00
	00		 jne	 $cleanup$2251

; 1650 :     CHK( mpi_shift_r( &R, s = mpi_lsb( &W ) ) );

  000d1	8d 45 dc	 lea	 eax, DWORD PTR _W$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _mpi_lsb
  000da	89 45 08	 mov	 DWORD PTR _s$[ebp], eax
  000dd	50		 push	 eax
  000de	8d 45 d0	 lea	 eax, DWORD PTR _R$[ebp]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 _mpi_shift_r
  000e7	8b f0		 mov	 esi, eax
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ec	85 f6		 test	 esi, esi
  000ee	0f 85 56 01 00
	00		 jne	 $cleanup$2251

; 1651 : 
; 1652 :     for( i = 0; i < 8; i++ )

  000f4	21 45 fc	 and	 DWORD PTR _i$[ebp], eax
$L2256:

; 1653 :     {
; 1654 :         /*
; 1655 :          * pick a random A, 1 < A < |X| - 1
; 1656 :          */
; 1657 :         CHK( mpi_grow( &A, X->n ) );

  000f7	ff 77 04	 push	 DWORD PTR [edi+4]
  000fa	8d 45 e8	 lea	 eax, DWORD PTR _A$[ebp]
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 _mpi_grow
  00103	8b f0		 mov	 esi, eax
  00105	59		 pop	 ecx
  00106	85 f6		 test	 esi, esi
  00108	59		 pop	 ecx
  00109	0f 85 3b 01 00
	00		 jne	 $cleanup$2251

; 1658 : 
; 1659 :         for( j = 0; j < A.n; j++ )

  0010f	39 75 ec	 cmp	 DWORD PTR _A$[ebp+4], esi
  00112	7e 21		 jle	 SHORT $L2262
$L2260:

; 1660 :             A.p[j] = (t_int) rand() * rand();

  00114	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__rand
  0011a	ff d3		 call	 ebx
  0011c	8b d0		 mov	 edx, eax
  0011e	89 55 f8	 mov	 DWORD PTR -8+[ebp], edx
  00121	ff d3		 call	 ebx
  00123	8b 4d f8	 mov	 ecx, DWORD PTR -8+[ebp]
  00126	0f af c8	 imul	 ecx, eax
  00129	8b 45 f0	 mov	 eax, DWORD PTR _A$[ebp+8]
  0012c	89 0c b0	 mov	 DWORD PTR [eax+esi*4], ecx
  0012f	46		 inc	 esi
  00130	3b 75 ec	 cmp	 esi, DWORD PTR _A$[ebp+4]
  00133	7c df		 jl	 SHORT $L2260
$L2262:

; 1661 : 
; 1662 :         CHK( mpi_shift_r( &A, mpi_msb( &A ) -
; 1663 :                               mpi_msb( &W ) + 1 ) );

  00135	8d 45 dc	 lea	 eax, DWORD PTR _W$[ebp]
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 _mpi_msb
  0013e	6a 01		 push	 1
  00140	5b		 pop	 ebx
  00141	8b f3		 mov	 esi, ebx
  00143	2b f0		 sub	 esi, eax
  00145	8d 45 e8	 lea	 eax, DWORD PTR _A$[ebp]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 _mpi_msb
  0014e	03 f0		 add	 esi, eax
  00150	8d 45 e8	 lea	 eax, DWORD PTR _A$[ebp]
  00153	56		 push	 esi
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 _mpi_shift_r
  0015a	8b f0		 mov	 esi, eax
  0015c	83 c4 10	 add	 esp, 16			; 00000010H
  0015f	85 f6		 test	 esi, esi
  00161	0f 85 e3 00 00
	00		 jne	 $cleanup$2251

; 1664 :         A.p[0] |= 3;

  00167	8b 45 f0	 mov	 eax, DWORD PTR _A$[ebp+8]
  0016a	83 08 03	 or	 DWORD PTR [eax], 3

; 1665 : 
; 1666 :         /*
; 1667 :          * A = A^R mod |X|
; 1668 :          */
; 1669 :         CHK( mpi_exp_mod( &A, &A, &R, X, &RR ) );

  0016d	8d 45 b8	 lea	 eax, DWORD PTR _RR$[ebp]
  00170	50		 push	 eax
  00171	8d 45 d0	 lea	 eax, DWORD PTR _R$[ebp]
  00174	57		 push	 edi
  00175	50		 push	 eax
  00176	8d 45 e8	 lea	 eax, DWORD PTR _A$[ebp]
  00179	50		 push	 eax
  0017a	8d 45 e8	 lea	 eax, DWORD PTR _A$[ebp]
  0017d	50		 push	 eax
  0017e	e8 00 00 00 00	 call	 _mpi_exp_mod
  00183	8b f0		 mov	 esi, eax
  00185	83 c4 14	 add	 esp, 20			; 00000014H
  00188	85 f6		 test	 esi, esi
  0018a	0f 85 ba 00 00
	00		 jne	 $cleanup$2251

; 1670 : 
; 1671 :         if( mpi_cmp_mpi( &A, &W ) == 0 ||
; 1672 :             mpi_cmp_int( &A,  1 ) == 0 )

  00190	8d 45 dc	 lea	 eax, DWORD PTR _W$[ebp]
  00193	50		 push	 eax
  00194	8d 45 e8	 lea	 eax, DWORD PTR _A$[ebp]
  00197	50		 push	 eax
  00198	e8 00 00 00 00	 call	 _mpi_cmp_mpi
  0019d	59		 pop	 ecx
  0019e	85 c0		 test	 eax, eax
  001a0	59		 pop	 ecx
  001a1	0f 84 88 00 00
	00		 je	 $L2257
  001a7	8d 45 e8	 lea	 eax, DWORD PTR _A$[ebp]
  001aa	53		 push	 ebx
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 _mpi_cmp_int
  001b1	59		 pop	 ecx
  001b2	85 c0		 test	 eax, eax
  001b4	59		 pop	 ecx
  001b5	74 78		 je	 SHORT $L2257

; 1673 :             continue;
; 1674 : 
; 1675 :         j = 1;
; 1676 :         while( j < s && mpi_cmp_mpi( &A, &W ) != 0 )

  001b7	39 5d 08	 cmp	 DWORD PTR _s$[ebp], ebx
  001ba	7e 5b		 jle	 SHORT $L2742
$L2269:
  001bc	8d 45 dc	 lea	 eax, DWORD PTR _W$[ebp]
  001bf	50		 push	 eax
  001c0	8d 45 e8	 lea	 eax, DWORD PTR _A$[ebp]
  001c3	50		 push	 eax
  001c4	e8 00 00 00 00	 call	 _mpi_cmp_mpi
  001c9	59		 pop	 ecx
  001ca	85 c0		 test	 eax, eax
  001cc	59		 pop	 ecx
  001cd	74 48		 je	 SHORT $L2742

; 1677 :         {
; 1678 :             /*
; 1679 :              * A = A * A mod |X|
; 1680 :              */
; 1681 :             CHK( mpi_mul_mpi( &T, &A, &A ) );

  001cf	8d 45 e8	 lea	 eax, DWORD PTR _A$[ebp]
  001d2	50		 push	 eax
  001d3	8d 45 e8	 lea	 eax, DWORD PTR _A$[ebp]
  001d6	50		 push	 eax
  001d7	8d 45 c4	 lea	 eax, DWORD PTR _T$[ebp]
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 _mpi_mul_mpi
  001e0	8b f0		 mov	 esi, eax
  001e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e5	85 f6		 test	 esi, esi
  001e7	75 61		 jne	 SHORT $cleanup$2251

; 1682 :             CHK( mpi_mod_mpi( &A, &T, X  ) );

  001e9	8d 45 c4	 lea	 eax, DWORD PTR _T$[ebp]
  001ec	57		 push	 edi
  001ed	50		 push	 eax
  001ee	8d 45 e8	 lea	 eax, DWORD PTR _A$[ebp]
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 _mpi_mod_mpi
  001f7	8b f0		 mov	 esi, eax
  001f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001fc	85 f6		 test	 esi, esi
  001fe	75 4a		 jne	 SHORT $cleanup$2251

; 1683 : 
; 1684 :             if( mpi_cmp_int( &A, 1 ) == 0 )

  00200	8d 45 e8	 lea	 eax, DWORD PTR _A$[ebp]
  00203	6a 01		 push	 1
  00205	50		 push	 eax
  00206	e8 00 00 00 00	 call	 _mpi_cmp_int
  0020b	59		 pop	 ecx
  0020c	85 c0		 test	 eax, eax
  0020e	59		 pop	 ecx
  0020f	74 06		 je	 SHORT $L2742

; 1685 :                 break;
; 1686 : 
; 1687 :             j++;

  00211	43		 inc	 ebx
  00212	3b 5d 08	 cmp	 ebx, DWORD PTR _s$[ebp]
  00215	7c a5		 jl	 SHORT $L2269
$L2742:

; 1688 :         }
; 1689 : 
; 1690 :         /*
; 1691 :          * not prime if A != |X| - 1 or A == 1
; 1692 :          */
; 1693 :         if( mpi_cmp_mpi( &A, &W ) != 0 || j < s )

  00217	8d 45 dc	 lea	 eax, DWORD PTR _W$[ebp]
  0021a	50		 push	 eax
  0021b	8d 45 e8	 lea	 eax, DWORD PTR _A$[ebp]
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _mpi_cmp_mpi
  00224	59		 pop	 ecx
  00225	85 c0		 test	 eax, eax
  00227	59		 pop	 ecx
  00228	75 1d		 jne	 SHORT $L2746
  0022a	3b 5d 08	 cmp	 ebx, DWORD PTR _s$[ebp]
  0022d	7c 18		 jl	 SHORT $L2746
$L2257:

; 1651 : 
; 1652 :     for( i = 0; i < 8; i++ )

  0022f	ff 45 fc	 inc	 DWORD PTR _i$[ebp]
  00232	83 7d fc 08	 cmp	 DWORD PTR _i$[ebp], 8
  00236	0f 8c bb fe ff
	ff		 jl	 $L2256

; 1688 :         }
; 1689 : 
; 1690 :         /*
; 1691 :          * not prime if A != |X| - 1 or A == 1
; 1692 :          */
; 1693 :         if( mpi_cmp_mpi( &A, &W ) != 0 || j < s )

  0023c	eb 0c		 jmp	 SHORT $cleanup$2251
$L2737:

; 1636 :             return( 0 );

  0023e	33 c0		 xor	 eax, eax
  00240	eb 29		 jmp	 SHORT $L2231
$L2739:

; 1641 :             return( ERR_MPI_NOT_ACCEPTABLE );

  00242	6a 0e		 push	 14			; 0000000eH
  00244	58		 pop	 eax
  00245	eb 24		 jmp	 SHORT $L2231
$L2746:

; 1694 :         {
; 1695 :             ret = ERR_MPI_NOT_ACCEPTABLE;

  00247	6a 0e		 push	 14			; 0000000eH
  00249	5e		 pop	 esi
$cleanup$2251:

; 1696 :             break;
; 1697 :         }
; 1698 :     }
; 1699 : 
; 1700 : cleanup:
; 1701 : 
; 1702 :     X->s = xs;

  0024a	8b 45 f4	 mov	 eax, DWORD PTR _xs$[ebp]

; 1703 :     mpi_free( &A, &T, &R, &W, NULL );

  0024d	6a 00		 push	 0
  0024f	89 07		 mov	 DWORD PTR [edi], eax
  00251	8d 45 dc	 lea	 eax, DWORD PTR _W$[ebp]
  00254	50		 push	 eax
  00255	8d 45 d0	 lea	 eax, DWORD PTR _R$[ebp]
  00258	50		 push	 eax
  00259	8d 45 c4	 lea	 eax, DWORD PTR _T$[ebp]
  0025c	50		 push	 eax
  0025d	8d 45 e8	 lea	 eax, DWORD PTR _A$[ebp]
  00260	50		 push	 eax
  00261	e8 00 00 00 00	 call	 _mpi_free
  00266	83 c4 14	 add	 esp, 20			; 00000014H

; 1704 :     return( ret );

  00269	8b c6		 mov	 eax, esi
$L2231:
  0026b	5f		 pop	 edi
  0026c	5e		 pop	 esi
  0026d	5b		 pop	 ebx

; 1705 : }

  0026e	c9		 leave
  0026f	c3		 ret	 0
_mpi_is_prime ENDP
_TEXT	ENDS
PUBLIC	_mpi_gen_prime
;	COMDAT _mpi_gen_prime
_TEXT	SEGMENT
_X$ = 8
_nbits$ = 12
_dh_flag$ = 16
_rng_f$ = 20
_rng_d$ = 24
_Y$ = -12
_mpi_gen_prime PROC NEAR				; COMDAT

; 1712 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 1713 :     int ret, k, n;
; 1714 :     unsigned char *p;
; 1715 :     mpi Y;
; 1716 : 
; 1717 :     if( nbits < 3 )

  00007	8b 75 0c	 mov	 esi, DWORD PTR _nbits$[ebp]
  0000a	83 fe 03	 cmp	 esi, 3
  0000d	7d 08		 jge	 SHORT $L2294

; 1718 :         return( ERR_MPI_INVALID_PARAMETER );

  0000f	6a 06		 push	 6
  00011	58		 pop	 eax
  00012	e9 5e 01 00 00	 jmp	 $L2288
$L2294:
  00017	53		 push	 ebx

; 1719 : 
; 1720 :     mpi_init( &Y, NULL );

  00018	33 db		 xor	 ebx, ebx
  0001a	57		 push	 edi
  0001b	8d 45 f4	 lea	 eax, DWORD PTR _Y$[ebp]
  0001e	53		 push	 ebx
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _mpi_init

; 1721 : 
; 1722 :     n = BITS_TO_LIMBS( nbits );

  00025	8d 46 1f	 lea	 eax, DWORD PTR [esi+31]
  00028	6a 20		 push	 32			; 00000020H
  0002a	99		 cdq
  0002b	59		 pop	 ecx

; 1723 : 
; 1724 :     CHK( mpi_grow( X, n ) );

  0002c	8b 7d 08	 mov	 edi, DWORD PTR _X$[ebp]
  0002f	f7 f9		 idiv	 ecx
  00031	50		 push	 eax
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 _mpi_grow
  00038	8b f0		 mov	 esi, eax
  0003a	83 c4 10	 add	 esp, 16			; 00000010H
  0003d	3b f3		 cmp	 esi, ebx
  0003f	0f 85 1f 01 00
	00		 jne	 $cleanup$2301

; 1725 :     CHK( mpi_lset( X, 0 ) );

  00045	53		 push	 ebx
  00046	57		 push	 edi
  00047	e8 00 00 00 00	 call	 _mpi_lset
  0004c	8b f0		 mov	 esi, eax
  0004e	59		 pop	 ecx
  0004f	3b f3		 cmp	 esi, ebx
  00051	59		 pop	 ecx
  00052	0f 85 0c 01 00
	00		 jne	 $cleanup$2301

; 1726 : 
; 1727 :     p = (unsigned char *) X->p;
; 1728 :     for( k = 0; k < ciL * X->n; k++ )

  00058	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0005b	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  0005e	c1 e0 02	 shl	 eax, 2
  00061	85 c0		 test	 eax, eax
  00063	7e 15		 jle	 SHORT $L2308
$L2306:

; 1729 :         *p++ = rng_f( rng_d );

  00065	ff 75 18	 push	 DWORD PTR _rng_d$[ebp]
  00068	ff 55 14	 call	 DWORD PTR _rng_f$[ebp]
  0006b	88 06		 mov	 BYTE PTR [esi], al
  0006d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00070	46		 inc	 esi
  00071	43		 inc	 ebx
  00072	c1 e0 02	 shl	 eax, 2
  00075	3b d8		 cmp	 ebx, eax
  00077	59		 pop	 ecx
  00078	7c eb		 jl	 SHORT $L2306
$L2308:

; 1730 : 
; 1731 :     k = mpi_msb( X );

  0007a	57		 push	 edi
  0007b	e8 00 00 00 00	 call	 _mpi_msb
  00080	8b d8		 mov	 ebx, eax
  00082	59		 pop	 ecx

; 1732 :     if( k < nbits ) CHK( mpi_shift_l( X, nbits - k ) );

  00083	3b 5d 0c	 cmp	 ebx, DWORD PTR _nbits$[ebp]
  00086	7d 1b		 jge	 SHORT $L2769
  00088	8b 45 0c	 mov	 eax, DWORD PTR _nbits$[ebp]
  0008b	2b c3		 sub	 eax, ebx
  0008d	50		 push	 eax
  0008e	57		 push	 edi
  0008f	e8 00 00 00 00	 call	 _mpi_shift_l
  00094	8b f0		 mov	 esi, eax
  00096	59		 pop	 ecx
  00097	85 f6		 test	 esi, esi
  00099	59		 pop	 ecx
  0009a	0f 85 c4 00 00
	00		 jne	 $cleanup$2301

; 1733 :     if( k > nbits ) CHK( mpi_shift_r( X, k - nbits ) );

  000a0	3b 5d 0c	 cmp	 ebx, DWORD PTR _nbits$[ebp]
$L2769:
  000a3	7e 16		 jle	 SHORT $L2312
  000a5	2b 5d 0c	 sub	 ebx, DWORD PTR _nbits$[ebp]
  000a8	53		 push	 ebx
  000a9	57		 push	 edi
  000aa	e8 00 00 00 00	 call	 _mpi_shift_r
  000af	8b f0		 mov	 esi, eax
  000b1	59		 pop	 ecx
  000b2	85 f6		 test	 esi, esi
  000b4	59		 pop	 ecx
  000b5	0f 85 a9 00 00
	00		 jne	 $cleanup$2301
$L2312:

; 1734 :     X->p[0] |= 3;

  000bb	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000be	83 08 03	 or	 DWORD PTR [eax], 3

; 1735 : 
; 1736 :     if( dh_flag == 0 )

  000c1	83 7d 10 00	 cmp	 DWORD PTR _dh_flag$[ebp], 0
  000c5	75 2e		 jne	 SHORT $L2313
$L2770:

; 1737 :     {
; 1738 :         while( ( ret = mpi_is_prime( X ) ) != 0 )

  000c7	57		 push	 edi
  000c8	e8 00 00 00 00	 call	 _mpi_is_prime
  000cd	8b f0		 mov	 esi, eax
  000cf	59		 pop	 ecx
  000d0	85 f6		 test	 esi, esi
  000d2	0f 84 8c 00 00
	00		 je	 $cleanup$2301

; 1739 :         {
; 1740 :             if( ret != ERR_MPI_NOT_ACCEPTABLE )

  000d8	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  000db	0f 85 83 00 00
	00		 jne	 $cleanup$2301

; 1741 :                 goto cleanup;
; 1742 : 
; 1743 :             CHK( mpi_add_int( X, X, 2 ) );

  000e1	6a 02		 push	 2
  000e3	57		 push	 edi
  000e4	57		 push	 edi
  000e5	e8 00 00 00 00	 call	 _mpi_add_int
  000ea	8b f0		 mov	 esi, eax
  000ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ef	85 f6		 test	 esi, esi
  000f1	75 71		 jne	 SHORT $cleanup$2301

; 1767 :             CHK( mpi_shift_r( &Y, 1 ) );

  000f3	eb d2		 jmp	 SHORT $L2770
$L2313:

; 1744 :         }
; 1745 :     }
; 1746 :     else
; 1747 :     {
; 1748 :         CHK( mpi_sub_int( &Y, X, 1 ) );

  000f5	6a 01		 push	 1
  000f7	8d 45 f4	 lea	 eax, DWORD PTR _Y$[ebp]
  000fa	5b		 pop	 ebx
  000fb	53		 push	 ebx
  000fc	57		 push	 edi
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 _mpi_sub_int
$L2771:
  00103	8b f0		 mov	 esi, eax
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH
  00108	85 f6		 test	 esi, esi
  0010a	75 58		 jne	 SHORT $cleanup$2301

; 1749 :         CHK( mpi_shift_r( &Y, 1 ) );

  0010c	8d 45 f4	 lea	 eax, DWORD PTR _Y$[ebp]
  0010f	53		 push	 ebx
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 _mpi_shift_r
  00116	8b f0		 mov	 esi, eax
  00118	59		 pop	 ecx
  00119	85 f6		 test	 esi, esi
  0011b	59		 pop	 ecx
  0011c	75 46		 jne	 SHORT $cleanup$2301

; 1750 : 
; 1751 :         while( 1 )
; 1752 :         {
; 1753 :             if( ( ret = mpi_is_prime( X ) ) == 0 )

  0011e	57		 push	 edi
  0011f	e8 00 00 00 00	 call	 _mpi_is_prime
  00124	8b f0		 mov	 esi, eax
  00126	59		 pop	 ecx
  00127	85 f6		 test	 esi, esi
  00129	75 15		 jne	 SHORT $L2327

; 1754 :             {
; 1755 :                 if( ( ret = mpi_is_prime( &Y ) ) == 0 )

  0012b	8d 45 f4	 lea	 eax, DWORD PTR _Y$[ebp]
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 _mpi_is_prime
  00134	8b f0		 mov	 esi, eax
  00136	59		 pop	 ecx
  00137	85 f6		 test	 esi, esi
  00139	74 29		 je	 SHORT $cleanup$2301

; 1756 :                     break;
; 1757 : 
; 1758 :                 if( ret != ERR_MPI_NOT_ACCEPTABLE )

  0013b	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  0013e	75 24		 jne	 SHORT $cleanup$2301
$L2327:

; 1759 :                     goto cleanup;
; 1760 :             }
; 1761 : 
; 1762 :             if( ret != ERR_MPI_NOT_ACCEPTABLE )

  00140	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00143	75 1f		 jne	 SHORT $cleanup$2301

; 1763 :                 goto cleanup;
; 1764 : 
; 1765 :             CHK( mpi_add_int( &Y, X, 1 ) );

  00145	53		 push	 ebx
  00146	8d 45 f4	 lea	 eax, DWORD PTR _Y$[ebp]
  00149	57		 push	 edi
  0014a	50		 push	 eax
  0014b	e8 00 00 00 00	 call	 _mpi_add_int
  00150	8b f0		 mov	 esi, eax
  00152	83 c4 0c	 add	 esp, 12			; 0000000cH
  00155	85 f6		 test	 esi, esi
  00157	75 0b		 jne	 SHORT $cleanup$2301

; 1766 :             CHK( mpi_add_int(  X, X, 2 ) );

  00159	6a 02		 push	 2
  0015b	57		 push	 edi
  0015c	57		 push	 edi
  0015d	e8 00 00 00 00	 call	 _mpi_add_int
  00162	eb 9f		 jmp	 SHORT $L2771
$cleanup$2301:

; 1768 :         }
; 1769 :     }
; 1770 : 
; 1771 : cleanup:
; 1772 : 
; 1773 :     mpi_free( &Y, NULL );

  00164	8d 45 f4	 lea	 eax, DWORD PTR _Y$[ebp]
  00167	6a 00		 push	 0
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 _mpi_free
  0016f	59		 pop	 ecx

; 1774 :     return( ret );

  00170	8b c6		 mov	 eax, esi
  00172	59		 pop	 ecx
  00173	5f		 pop	 edi
  00174	5b		 pop	 ebx
$L2288:
  00175	5e		 pop	 esi

; 1775 : }

  00176	c9		 leave
  00177	c3		 ret	 0
_mpi_gen_prime ENDP
_TEXT	ENDS
PUBLIC	_mpi_self_test
;	COMDAT _mpi_self_test
_TEXT	SEGMENT
_mpi_self_test PROC NEAR				; COMDAT

; 1915 :     return( 0 );

  00000	33 c0		 xor	 eax, eax

; 1916 : }

  00002	c3		 ret	 0
_mpi_self_test ENDP
_TEXT	ENDS
END
