	TITLE	E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\codec\gsm_rpe.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _weightingFilter
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _gridSelection
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _gridPositioning
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _APCMXmaxcToExpMant
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _APCMQuantization
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _APCMDequantization
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _encodeRPE
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _decodeRPE
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
CONST	SEGMENT
_gsm_H	DD	0ffffff7aH
	DD	0fffffe8aH
	DD	00H
	DD	0806H
	DD	0166dH
	DD	02000H
	DD	0166dH
	DD	0806H
	DD	00H
	DD	0fffffe8aH
	DD	0ffffff7aH
_gsm_NRFAC DD	071c8H
	DD	06667H
	DD	05d18H
	DD	05556H
	DD	04ec5H
	DD	04925H
	DD	04444H
	DD	04000H
_gsm_FAC DD	047ffH
	DD	04fffH
	DD	057ffH
	DD	05fffH
	DD	067ffH
	DD	06fffH
	DD	077ffH
	DD	07fffH
CONST	ENDS
PUBLIC	_encodeRPE
;	COMDAT _encodeRPE
_TEXT	SEGMENT
_state$ = 8
_x$ = -272
_xM$ = -60
_xMp$ = -112
_mant$ = -8
_exp$ = -4
_xMaxc$ = 8
_encodeRPE PROC NEAR					; COMDAT

; 208  : {   int		x[40];

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H

; 209  : 	int		xM[13], xMp[13];
; 210  : 	int		mant, exp;
; 211  : 	int     *Mc = state->Mc + state->subframe;

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 81 a8 00 00
	00		 mov	 eax, DWORD PTR [ecx+168]

; 212  : 	int     *xMaxc = state->xMaxc + state->subframe;

  00015	8d 94 81 90 05
	00 00		 lea	 edx, DWORD PTR [ecx+eax*4+1424]
  0001c	8d b4 81 80 05
	00 00		 lea	 esi, DWORD PTR [ecx+eax*4+1408]
  00023	89 55 08	 mov	 DWORD PTR _xMaxc$[ebp], edx

; 213  : 	int 	*xMc = state->xMc + state->subframe * 13;

  00026	8b d0		 mov	 edx, eax
  00028	6b d2 34	 imul	 edx, 52			; 00000034H

; 214  : 	int     *e = state->e + state->subframe * 40;

  0002b	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0002e	c1 e0 05	 shl	 eax, 5
  00031	8d bc 0a a0 05
	00 00		 lea	 edi, DWORD PTR [edx+ecx+1440]
  00038	8d 9c 08 dc 02
	00 00		 lea	 ebx, DWORD PTR [eax+ecx+732]

; 215  : 	//int		i;
; 216  : 	/*
; 217  : 	printf("RPE in: \n");
; 218  : 	for (i=0;i<40;i++) {
; 219  : 		printf("%7d ", e[i]);
; 220  : 	}
; 221  : 	printf("\n");
; 222  : 	*/
; 223  : 	weightingFilter(e, x);

  0003f	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _x$[ebp]
  00045	50		 push	 eax
  00046	53		 push	 ebx
  00047	e8 00 00 00 00	 call	 _weightingFilter

; 224  : 	/*
; 225  : 	printf("RPE weighting filter: \n");
; 226  : 	for (i=0;i<40;i++) {
; 227  : 		printf("%7d ", x[i]);
; 228  : 	}
; 229  : 	printf("\n");
; 230  : 	*/
; 231  : 	gridSelection(x, xM, Mc);

  0004c	8d 45 c4	 lea	 eax, DWORD PTR _xM$[ebp]
  0004f	56		 push	 esi
  00050	50		 push	 eax
  00051	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _x$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _gridSelection

; 232  : 	APCMQuantization(xM, xMc, &mant, &exp, xMaxc);

  0005d	ff 75 08	 push	 DWORD PTR _xMaxc$[ebp]
  00060	8d 45 fc	 lea	 eax, DWORD PTR _exp$[ebp]
  00063	50		 push	 eax
  00064	8d 45 f8	 lea	 eax, DWORD PTR _mant$[ebp]
  00067	50		 push	 eax
  00068	8d 45 c4	 lea	 eax, DWORD PTR _xM$[ebp]
  0006b	57		 push	 edi
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _APCMQuantization

; 233  : 	/* printf("RPE Mc(grid #)=%d xmaxc=%d mant=%d exp=%d \n", *Mc, *xMaxc, mant, exp); */
; 234  : 	APCMDequantization(xMc, mant, exp, xMp);

  00072	8d 45 90	 lea	 eax, DWORD PTR _xMp$[ebp]
  00075	50		 push	 eax
  00076	ff 75 fc	 push	 DWORD PTR _exp$[ebp]
  00079	ff 75 f8	 push	 DWORD PTR _mant$[ebp]
  0007c	57		 push	 edi
  0007d	e8 00 00 00 00	 call	 _APCMDequantization

; 235  : 	gridPositioning(*Mc, xMp, e);

  00082	8d 45 90	 lea	 eax, DWORD PTR _xMp$[ebp]
  00085	53		 push	 ebx
  00086	50		 push	 eax
  00087	ff 36		 push	 DWORD PTR [esi]
  00089	e8 00 00 00 00	 call	 _gridPositioning
  0008e	83 c4 44	 add	 esp, 68			; 00000044H
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx

; 236  : }

  00094	c9		 leave
  00095	c3		 ret	 0
_encodeRPE ENDP
_TEXT	ENDS
;	COMDAT _weightingFilter
_TEXT	SEGMENT
_e$ = 8
_x$ = 12
_k$ = -4
_weightingFilter PROC NEAR				; COMDAT

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 42   : 	int	L_result;
; 43   : 	int	k, i;
; 44   : 	for (k = 0; k < 40; k++) {

  00004	8b 45 08	 mov	 eax, DWORD PTR _e$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR _k$[ebp], 0
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b 7d 0c	 mov	 edi, DWORD PTR _x$[ebp]
  00011	83 c0 ec	 add	 eax, -20		; ffffffecH
  00014	89 45 0c	 mov	 DWORD PTR 12+[ebp], eax
$L75904:

; 45   : 		L_result = 4096;

  00017	8b 75 fc	 mov	 esi, DWORD PTR _k$[ebp]
  0001a	8b 55 0c	 mov	 edx, DWORD PTR 12+[ebp]
  0001d	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_gsm_H
$L75907:

; 46   : 		for (i = 0; i < 11; i++) {
; 47   : 			int ix = i + k;
; 48   : 			if (ix>4 && ix<45) L_result += e[ix - 5] * gsm_H[i];

  00027	83 fe 04	 cmp	 esi, 4
  0002a	7e 0c		 jle	 SHORT $L75908
  0002c	83 fe 2d	 cmp	 esi, 45			; 0000002dH
  0002f	7d 07		 jge	 SHORT $L75908
  00031	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00033	0f af 1a	 imul	 ebx, DWORD PTR [edx]
  00036	03 c3		 add	 eax, ebx
$L75908:
  00038	83 c1 04	 add	 ecx, 4
  0003b	46		 inc	 esi
  0003c	83 c2 04	 add	 edx, 4
  0003f	81 f9 2c 00 00
	00		 cmp	 ecx, OFFSET FLAT:_gsm_H+44
  00045	7c e0		 jl	 SHORT $L75907

; 49   : 		}
; 50   : 		L_result >>= 13;

  00047	c1 f8 0d	 sar	 eax, 13			; 0000000dH

; 51   : 		x[k] =  (L_result < -32768 ? -32768 : (L_result > 32767 ? 32767 : L_result));

  0004a	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
  0004f	3b c1		 cmp	 eax, ecx
  00051	7c 09		 jl	 SHORT $L76062
  00053	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00058	3b c1		 cmp	 eax, ecx
  0005a	7e 02		 jle	 SHORT $L76055
$L76062:
  0005c	8b c1		 mov	 eax, ecx
$L76055:

; 42   : 	int	L_result;
; 43   : 	int	k, i;
; 44   : 	for (k = 0; k < 40; k++) {

  0005e	ff 45 fc	 inc	 DWORD PTR _k$[ebp]
  00061	83 45 0c 04	 add	 DWORD PTR 12+[ebp], 4

; 51   : 		x[k] =  (L_result < -32768 ? -32768 : (L_result > 32767 ? 32767 : L_result));

  00065	89 07		 mov	 DWORD PTR [edi], eax
  00067	83 c7 04	 add	 edi, 4
  0006a	83 7d fc 28	 cmp	 DWORD PTR _k$[ebp], 40	; 00000028H
  0006e	7c a7		 jl	 SHORT $L75904
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx

; 52   : 	}
; 53   : }

  00073	c9		 leave
  00074	c3		 ret	 0
_weightingFilter ENDP
_TEXT	ENDS
;	COMDAT _gridSelection
_TEXT	SEGMENT
_x$ = 8
_xM$ = 12
_Mc_out$ = 16
_m$ = -4
_EM$ = -12
_gridSelection PROC NEAR				; COMDAT

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 61   : 	int		m, i;
; 62   : 	int 	L_result, L_temp;
; 63   : 	int 	EM, Mc;
; 64   : 
; 65   : 	EM = 0;

  00006	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	33 ff		 xor	 edi, edi
  0000e	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
  00011	89 7d f4	 mov	 DWORD PTR _EM$[ebp], edi

; 66   : 	Mc = 0;
; 67   : 
; 68   : 	for (m = 0; m < 4; m++) {

  00014	89 7d fc	 mov	 DWORD PTR _m$[ebp], edi
$L75926:

; 69   : 		L_result = 0;

  00017	8b 55 f8	 mov	 edx, DWORD PTR -8+[ebp]
  0001a	6a 0d		 push	 13			; 0000000dH
  0001c	33 c9		 xor	 ecx, ecx
  0001e	5e		 pop	 esi
$L75929:

; 70   : 		for (i = 0; i < 13; i++) {
; 71   : 			int temp = x[m + 3*i] >> 2;

  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	83 c2 0c	 add	 edx, 12			; 0000000cH
  00024	c1 f8 02	 sar	 eax, 2

; 72   : 			L_temp = temp * temp << 1;
; 73   : 			L_result += L_temp;

  00027	8b d8		 mov	 ebx, eax
  00029	0f af d8	 imul	 ebx, eax
  0002c	4e		 dec	 esi
  0002d	8d 0c 59	 lea	 ecx, DWORD PTR [ecx+ebx*2]
  00030	75 ed		 jne	 SHORT $L75929

; 74   : 		}
; 75   : 		if (L_result > EM) {

  00032	3b 4d f4	 cmp	 ecx, DWORD PTR _EM$[ebp]
  00035	7e 06		 jle	 SHORT $L75927

; 76   : 			Mc = m;

  00037	8b 7d fc	 mov	 edi, DWORD PTR _m$[ebp]

; 77   : 			EM = L_result;

  0003a	89 4d f4	 mov	 DWORD PTR _EM$[ebp], ecx
$L75927:
  0003d	ff 45 fc	 inc	 DWORD PTR _m$[ebp]
  00040	83 45 f8 04	 add	 DWORD PTR -8+[ebp], 4
  00044	83 7d fc 04	 cmp	 DWORD PTR _m$[ebp], 4
  00048	7c cd		 jl	 SHORT $L75926

; 78   : 		}
; 79   : 	}
; 80   : 	/*  Down-sampling by a factor 3 to get the selected xM[0..12]
; 81   : 	 *  RPE sequence.
; 82   : 	 */
; 83   : 	for (i = 0; i < 13; i ++) xM[i] = x[Mc + 3*i];

  0004a	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _xM$[ebp]
  00050	6a 0d		 push	 13			; 0000000dH
  00052	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  00055	5a		 pop	 edx
$L75934:
  00056	8b 30		 mov	 esi, DWORD PTR [eax]
  00058	83 c0 0c	 add	 eax, 12			; 0000000cH
  0005b	89 31		 mov	 DWORD PTR [ecx], esi
  0005d	83 c1 04	 add	 ecx, 4
  00060	4a		 dec	 edx
  00061	75 f3		 jne	 SHORT $L75934

; 84   : 	*Mc_out = Mc;

  00063	8b 45 10	 mov	 eax, DWORD PTR _Mc_out$[ebp]
  00066	89 38		 mov	 DWORD PTR [eax], edi
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx

; 85   : }

  0006b	c9		 leave
  0006c	c3		 ret	 0
_gridSelection ENDP
_TEXT	ENDS
;	COMDAT _gridPositioning
_TEXT	SEGMENT
_Mc$ = 8
_xMp$ = 12
_ep$ = 16
_gridPositioning PROC NEAR				; COMDAT

; 96   : 	int i, k;
; 97   : 	for (k = 0; k < 40; k++) ep[k] = 0;

  00000	8b 54 24 0c	 mov	 edx, DWORD PTR _ep$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	6a 28		 push	 40			; 00000028H
  00008	59		 pop	 ecx
  00009	33 c0		 xor	 eax, eax
  0000b	8b fa		 mov	 edi, edx

; 98   : 	for (i = 0; i < 13; i++) {

  0000d	6a 0d		 push	 13			; 0000000dH
  0000f	f3 ab		 rep stosd
  00011	8b 4c 24 10	 mov	 ecx, DWORD PTR _Mc$[esp+8]
  00015	8b 44 24 14	 mov	 eax, DWORD PTR _xMp$[esp+8]
  00019	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  0001c	5a		 pop	 edx
$L75950:

; 99   : 		ep[ Mc + (3*i) ] = xMp[i];

  0001d	8b 30		 mov	 esi, DWORD PTR [eax]
  0001f	83 c0 04	 add	 eax, 4
  00022	89 31		 mov	 DWORD PTR [ecx], esi
  00024	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00027	4a		 dec	 edx
  00028	75 f3		 jne	 SHORT $L75950
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi

; 100  : 	}
; 101  : }

  0002c	c3		 ret	 0
_gridPositioning ENDP
_TEXT	ENDS
EXTRN	_abs:NEAR
;	COMDAT _APCMQuantization
_TEXT	SEGMENT
_xM$ = 8
_xMc$ = 12
_mant_out$ = 16
_exp_out$ = 20
_xmaxc_out$ = 24
_exp$ = -4
_mant$ = -8
_APCMQuantization PROC NEAR				; COMDAT

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi

; 130  : 	int		i, itest;
; 131  : 	int		xmax, xmaxc, temp, temp1, temp2;
; 132  : 	int		exp, mant;
; 133  : 
; 134  : 
; 135  : 	/*  Find the maximum absolute value xmax of xM[0..12].
; 136  : 	 */
; 137  : 
; 138  : 	xmax = 0;

  00008	8b 7d 08	 mov	 edi, DWORD PTR _xM$[ebp]
  0000b	6a 0d		 push	 13			; 0000000dH
  0000d	33 f6		 xor	 esi, esi
  0000f	5b		 pop	 ebx
$L75990:

; 140  : 		temp = abs(xM[i]);

  00010	ff 37		 push	 DWORD PTR [edi]
  00012	e8 00 00 00 00	 call	 _abs

; 141  : 		if (temp > xmax) xmax = temp;

  00017	3b c6		 cmp	 eax, esi
  00019	59		 pop	 ecx
  0001a	7e 02		 jle	 SHORT $L75991
  0001c	8b f0		 mov	 esi, eax
$L75991:

; 139  : 	for (i = 0; i < 13; i++) {

  0001e	83 c7 04	 add	 edi, 4
  00021	4b		 dec	 ebx
  00022	75 ec		 jne	 SHORT $L75990

; 142  : 	}
; 143  : 	if (xmax > 32767) xmax = 32767;

  00024	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00029	3b f0		 cmp	 esi, eax
  0002b	7e 02		 jle	 SHORT $L75994
  0002d	8b f0		 mov	 esi, eax
$L75994:

; 144  : 	/*  Qantizing and coding of xmax to get xmaxc.
; 145  : 	 */
; 146  : 
; 147  : 	exp   = 0;

  0002f	33 c0		 xor	 eax, eax

; 148  : 	temp  = xmax >> 9;

  00031	8b ce		 mov	 ecx, esi
  00033	6a 06		 push	 6
  00035	89 45 fc	 mov	 DWORD PTR _exp$[ebp], eax
  00038	c1 f9 09	 sar	 ecx, 9
  0003b	5a		 pop	 edx
$L75995:

; 149  : 	itest = 0;
; 150  : 
; 151  : 	for (i = 0; i < 6; i++) {
; 152  : 		if (temp != 0) exp++;

  0003c	85 c9		 test	 ecx, ecx
  0003e	74 01		 je	 SHORT $L75998
  00040	40		 inc	 eax
$L75998:

; 153  : 		temp = temp >> 1;

  00041	d1 f9		 sar	 ecx, 1
  00043	4a		 dec	 edx
  00044	75 f6		 jne	 SHORT $L75995

; 154  : 	}
; 155  : 
; 156  : 	temp = exp + 5;

  00046	8d 48 05	 lea	 ecx, DWORD PTR [eax+5]
  00049	89 45 fc	 mov	 DWORD PTR _exp$[ebp], eax

; 157  : 
; 158  : 	xmaxc = (xmax >> temp) + (exp << 3);

  0004c	d3 fe		 sar	 esi, cl
  0004e	8d 34 c6	 lea	 esi, DWORD PTR [esi+eax*8]

; 159  : 
; 160  : 	/*   Quantizing and coding of the xM[0..12] RPE sequence
; 161  : 	 *   to get the xMc[0..12]
; 162  : 	 */
; 163  : 	APCMXmaxcToExpMant( xmaxc, &exp, &mant );

  00051	8d 45 f8	 lea	 eax, DWORD PTR _mant$[ebp]
  00054	50		 push	 eax
  00055	8d 45 fc	 lea	 eax, DWORD PTR _exp$[ebp]
  00058	50		 push	 eax
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 _APCMXmaxcToExpMant

; 164  : 
; 165  : 	/*  This computation uses the fact that the decoded version of xmaxc
; 166  : 	 *  can be calculated by using the exponent and the mantissa part of
; 167  : 	 *  xmaxc (logarithmic table).
; 168  : 	 *  So, this method avoids any division and uses only a scaling
; 169  : 	 *  of the RPE samples by a function of the exponent.  A direct
; 170  : 	 *  multiplication by the inverse of the mantissa (NRFAC[0..7]
; 171  : 	 *  found in table 4.5) gives the 3 bit coded version xMc[0..12]
; 172  : 	 *  of the RPE samples.
; 173  : 	 */
; 174  : 
; 175  : 	/* Direct computation of xMc[0..12] using table 4.5
; 176  : 	 */
; 177  : 	temp = (mant|8)<<(5+exp);
; 178  : 	temp1 = 6 - exp;
; 179  : 	temp2 = gsm_NRFAC[ mant ];

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _mant$[ebp]

; 180  : 	for (i = 0; i < 13; i++) {

  00062	8b 7d 08	 mov	 edi, DWORD PTR _xM$[ebp]
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	c7 45 08 0d 00
	00 00		 mov	 DWORD PTR 8+[ebp], 13	; 0000000dH
  0006f	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _gsm_NRFAC[eax*4]
  00076	8b 45 0c	 mov	 eax, DWORD PTR _xMc$[ebp]
  00079	6a 06		 push	 6
  0007b	59		 pop	 ecx
  0007c	2b 4d fc	 sub	 ecx, DWORD PTR _exp$[ebp]
  0007f	2b f8		 sub	 edi, eax
$L75999:

; 181  : 		xMc[i] = ((xM[i] << temp1) * temp2 >> 27) + 4;

  00081	8b 1c 07	 mov	 ebx, DWORD PTR [edi+eax]
  00084	d3 e3		 shl	 ebx, cl
  00086	0f af da	 imul	 ebx, edx
  00089	c1 fb 1b	 sar	 ebx, 27			; 0000001bH
  0008c	83 c3 04	 add	 ebx, 4
  0008f	89 18		 mov	 DWORD PTR [eax], ebx
  00091	83 c0 04	 add	 eax, 4
  00094	ff 4d 08	 dec	 DWORD PTR 8+[ebp]
  00097	75 e8		 jne	 SHORT $L75999

; 182  : 	}
; 183  : 
; 184  : 	/*  NOTE: This equation is used to make all the xMc[i] positive.
; 185  : 	 */
; 186  : 
; 187  : 	*mant_out  = mant;

  00099	8b 45 10	 mov	 eax, DWORD PTR _mant_out$[ebp]
  0009c	8b 4d f8	 mov	 ecx, DWORD PTR _mant$[ebp]
  0009f	5f		 pop	 edi
  000a0	89 08		 mov	 DWORD PTR [eax], ecx

; 188  : 	*exp_out   = exp;

  000a2	8b 45 14	 mov	 eax, DWORD PTR _exp_out$[ebp]
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _exp$[ebp]
  000a8	89 08		 mov	 DWORD PTR [eax], ecx

; 189  : 	*xmaxc_out = xmaxc;

  000aa	8b 45 18	 mov	 eax, DWORD PTR _xmaxc_out$[ebp]
  000ad	89 30		 mov	 DWORD PTR [eax], esi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx

; 190  : }

  000b1	c9		 leave
  000b2	c3		 ret	 0
_APCMQuantization ENDP
_TEXT	ENDS
;	COMDAT _APCMXmaxcToExpMant
_TEXT	SEGMENT
_xmaxc$ = 8
_exp_out$ = 12
_mant_out$ = 16
_APCMXmaxcToExpMant PROC NEAR				; COMDAT

; 105  : 	int 	exp, mant;
; 106  : 	/* Compute exponent and mantissa of the decoded version of xmaxc
; 107  : 	 */
; 108  : 	exp = 0;
; 109  : 	if (xmaxc > 15) exp = (xmaxc >> 3) - 1;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _xmaxc$[esp-4]
  00004	33 c0		 xor	 eax, eax
  00006	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00009	7e 06		 jle	 SHORT $L75963
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 03	 sar	 eax, 3
  00010	48		 dec	 eax
$L75963:

; 110  : 	mant = xmaxc - (exp << 3);

  00011	8b d0		 mov	 edx, eax
  00013	c1 e2 03	 shl	 edx, 3
  00016	2b ca		 sub	 ecx, edx

; 111  : 
; 112  : 	if (mant == 0) {

  00018	75 08		 jne	 SHORT $L76088

; 113  : 		exp  = -4;

  0001a	6a fc		 push	 -4			; fffffffcH
  0001c	58		 pop	 eax

; 114  : 		mant = 7;

  0001d	6a 07		 push	 7
  0001f	59		 pop	 ecx

; 115  : 	}
; 116  : 	else {

  00020	eb 10		 jmp	 SHORT $L75965
$L76088:

; 117  : 		while (mant < 8) {

  00022	83 f9 08	 cmp	 ecx, 8
  00025	7d 08		 jge	 SHORT $L75968

; 118  : 			mant = mant << 1 | 1;

  00027	03 c9		 add	 ecx, ecx
  00029	83 c9 01	 or	 ecx, 1

; 119  : 			exp--;

  0002c	48		 dec	 eax
  0002d	eb f3		 jmp	 SHORT $L76088
$L75968:

; 120  : 		}
; 121  : 		mant -= 8;

  0002f	83 e9 08	 sub	 ecx, 8
$L75965:

; 122  : 	}
; 123  : 
; 124  : 	*exp_out  = exp;

  00032	8b 54 24 08	 mov	 edx, DWORD PTR _exp_out$[esp-4]
  00036	89 02		 mov	 DWORD PTR [edx], eax

; 125  : 	*mant_out = mant;

  00038	8b 44 24 0c	 mov	 eax, DWORD PTR _mant_out$[esp-4]
  0003c	89 08		 mov	 DWORD PTR [eax], ecx

; 126  : }

  0003e	c3		 ret	 0
_APCMXmaxcToExpMant ENDP
_TEXT	ENDS
;	COMDAT _APCMDequantization
_TEXT	SEGMENT
_xMc$ = 8
_mant$ = 12
_exp$ = 16
_xMp$ = 20
_temp1$ = -4
_APCMDequantization PROC NEAR				; COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 194  :    	int		i, temp1, temp2, temp3;
; 195  : 	temp1 = gsm_FAC[ mant ];

  00004	8b 45 0c	 mov	 eax, DWORD PTR _mant$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _gsm_FAC[eax*4]

; 196  : 	temp2 = 6 - exp;

  00011	6a 06		 push	 6
  00013	5f		 pop	 edi
  00014	89 45 fc	 mov	 DWORD PTR _temp1$[ebp], eax
  00017	2b 7d 10	 sub	 edi, DWORD PTR _exp$[ebp]

; 197  : 	if (temp2 <= 0) {

  0001a	85 ff		 test	 edi, edi
  0001c	7f 0b		 jg	 SHORT $L76016

; 198  : 		temp3 = 1 >> (1 - temp2);

  0001e	6a 01		 push	 1
  00020	5a		 pop	 edx
  00021	8b ca		 mov	 ecx, edx
  00023	2b cf		 sub	 ecx, edi
  00025	d3 fa		 sar	 edx, cl

; 199  : 	} else {

  00027	eb 08		 jmp	 SHORT $L76017
$L76016:

; 200  : 		temp3 = 1 << (temp2 - 1);

  00029	6a 01		 push	 1
  0002b	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]
  0002e	5a		 pop	 edx
  0002f	d3 e2		 shl	 edx, cl
$L76017:

; 201  : 	}
; 202  : 	for (i = 0; i < 13; i++) {

  00031	8b 45 14	 mov	 eax, DWORD PTR _xMp$[ebp]
  00034	8b 75 08	 mov	 esi, DWORD PTR _xMc$[ebp]
  00037	2b f0		 sub	 esi, eax
  00039	c7 45 0c 0d 00
	00 00		 mov	 DWORD PTR 12+[ebp], 13	; 0000000dH
$L76018:

; 203  : 		xMp[i] = ((((((xMc[i]<<1)-7)<<12)*temp1+16384)>>15)+temp3)>>temp2;

  00040	8b 1c 06	 mov	 ebx, DWORD PTR [esi+eax]
  00043	8b cf		 mov	 ecx, edi
  00045	c1 e3 0d	 shl	 ebx, 13			; 0000000dH
  00048	81 eb 00 70 00
	00		 sub	 ebx, 28672		; 00007000H
  0004e	0f af 5d fc	 imul	 ebx, DWORD PTR _temp1$[ebp]
  00052	81 c3 00 40 00
	00		 add	 ebx, 16384		; 00004000H
  00058	c1 fb 0f	 sar	 ebx, 15			; 0000000fH
  0005b	03 da		 add	 ebx, edx
  0005d	d3 fb		 sar	 ebx, cl
  0005f	89 18		 mov	 DWORD PTR [eax], ebx
  00061	83 c0 04	 add	 eax, 4
  00064	ff 4d 0c	 dec	 DWORD PTR 12+[ebp]
  00067	75 d7		 jne	 SHORT $L76018
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx

; 204  : 	}
; 205  : }

  0006c	c9		 leave
  0006d	c3		 ret	 0
_APCMDequantization ENDP
_TEXT	ENDS
PUBLIC	_decodeRPE
;	COMDAT _decodeRPE
_TEXT	SEGMENT
_state$ = 8
_exp$ = 8
_mant$ = -4
_xMp$ = -56
_decodeRPE PROC NEAR					; COMDAT

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 240  : 	int		exp, mant;
; 241  : 	int		xMp[ 13 ];
; 242  : 	int 	*xMc = state->xMc + state->subframe * 13;

  00008	8b 75 08	 mov	 esi, DWORD PTR _state$[ebp]
  0000b	57		 push	 edi
  0000c	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  00012	8b c8		 mov	 ecx, eax
  00014	6b c9 34	 imul	 ecx, 52			; 00000034H
  00017	8d bc 31 a0 05
	00 00		 lea	 edi, DWORD PTR [ecx+esi+1440]

; 243  : 	int     *e = state->e + state->subframe * 40;

  0001e	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00021	c1 e1 05	 shl	 ecx, 5
  00024	8d 9c 31 dc 02
	00 00		 lea	 ebx, DWORD PTR [ecx+esi+732]

; 244  : 
; 245  : 	APCMXmaxcToExpMant(state->xMaxc[state->subframe], &exp, &mant);

  0002b	8d 4d fc	 lea	 ecx, DWORD PTR _mant$[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d 08	 lea	 ecx, DWORD PTR _exp$[ebp]
  00032	51		 push	 ecx
  00033	ff b4 86 90 05
	00 00		 push	 DWORD PTR [esi+eax*4+1424]
  0003a	e8 00 00 00 00	 call	 _APCMXmaxcToExpMant

; 246  : 	APCMDequantization(xMc, mant, exp, xMp);

  0003f	8d 45 c8	 lea	 eax, DWORD PTR _xMp$[ebp]
  00042	50		 push	 eax
  00043	ff 75 08	 push	 DWORD PTR _exp$[ebp]
  00046	ff 75 fc	 push	 DWORD PTR _mant$[ebp]
  00049	57		 push	 edi
  0004a	e8 00 00 00 00	 call	 _APCMDequantization

; 247  : 	gridPositioning(state->Mc[state->subframe], xMp, e);

  0004f	8d 45 c8	 lea	 eax, DWORD PTR _xMp$[ebp]
  00052	53		 push	 ebx
  00053	50		 push	 eax
  00054	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  0005a	ff b4 86 80 05
	00 00		 push	 DWORD PTR [esi+eax*4+1408]
  00061	e8 00 00 00 00	 call	 _gridPositioning
  00066	83 c4 28	 add	 esp, 40			; 00000028H
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx

; 248  : }

  0006c	c9		 leave
  0006d	c3		 ret	 0
_decodeRPE ENDP
_TEXT	ENDS
END
