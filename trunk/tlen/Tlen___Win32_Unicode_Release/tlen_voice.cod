	TITLE	E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\tlen_voice.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BG@FJFA@Miranda?1System?1GetMMI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@DNA@Miranda?1System?1GetLI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@FHMP@Miranda?1System?1GetUTFI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@DCOH@Miranda?1Thread?1Fork?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@IENN@Miranda?1Thread?1ForkEx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FGIN@Miranda?1SysTerm?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@LIGC@Utils?1AddToWindowList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@PEAI@Utils?1RemoveFromWindowList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@GMNB@Utils?1FindWindowInList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@NOMI@Utils?1BroadcastToWindowList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@CFCA@Utils?1BroadcastToWindowListAsync@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@MDKL@Utils?1SaveWindowPos?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@GALP@Utils?1RestoreWindowPos?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@CHLF@Miranda?1System?1GetMD5I?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@FOPF@Miranda?1System?1GetSHA1I?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@EFDJ@Netlib?1Send?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@GFGB@Netlib?1Recv?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@CMGK@Netlib?1Log?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@GDOO@Netlib?1InitSecurityProvider?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@JINJ@Netlib?1DestroySecurityProvider?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@CBFG@Netlib?1NtlmCreateResponse?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@COCL@Proto?1EnumAccounts?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CCNI@Proto?1GetAccount?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@IFFL@Proto?1BroadcastAck?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@MGBG@DB?1Event?1GetText?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@BEPM@DB?1Contact?1GetSettingStr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@FLKM@C?3?2MirandaDev?2miranda_svn2?2inclu@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@IGCO@DB?1Contact?1DeleteSetting?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@PLGC@DB?1Contact?1WriteSetting?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@GNEH@LangPack?1TranslateDialog?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@GFNK@Skin?1Icons?1Load?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@BLFF@Skin?1Icons?1LoadProto?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@CNOA@Skin?1Sounds?1AddNew?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@LENC@Skin?1Sounds?1Play?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@PNGM@PopUp?1AddPopUp?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@OBDC@PopUp?1AddPopUpEx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@CGKI@PopUp?1AddPopUpW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@HIHP@PopUp?1GetContact?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@CCHD@PopUp?1GetPluginData?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@HKEA@PopUp?1IsSecondLineShown?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@KGOE@PopUp?1Changetext?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LAPD@PopUp?1ChangetextW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@KOPP@PopUp?1Change?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@BGJ@PopUp?1ShowMessage?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@NFFE@PopUp?1ShowMessageW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@MAHO@PopUp?1AddPopupClass?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@OEMO@recording?5thread?5ended?4?4?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FD@FMB@E?3?2Documents?5and?5Settings?2piotr?2@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@OODI@VoiceDeviceOut?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@MJGN@Playback?5device?5ID?5?$CD?$CFu?3?5?$CFs?$AN?6?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@OELG@TlenVoiceStart?5FAILED?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@NBHN@TlenVoiceStart?5OK?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@EBHE@VoiceDeviceIn?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@PNKF@Recording?5device?5ID?5?$CD?$CFu?3?5?$CFs?$AN?6?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@JLOF@TlenVoiceStart?5FAILED?5?$CFd?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@MAGB@TlenVoiceStart?5FAILED?5?$CD2?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HLBB@TlenVoiceRStart?5OK?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GCEN@?9?$DO?5TlenVoiceFreeVc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@HGIF@?$DM?9?5TlenVoiceFreeVc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DI@NLKJ@Thread?5started?3?5type?$DNfile_receiv@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CC@CDEO@?$AA?4?$AA?4?$AA?4?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAi?$AAn?$AAg?$AA?4?$AA?4?$AA?4?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@MKNL@LangPack?1TranslateString?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@JEKK@Netlib?1OpenConnection?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@CMPD@Entering?5file?5receive?5loop?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@OFJJ@Connection?5failed?5?9?5receiving?5as@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1DK@CHIL@?$AA?4?$AA?4?$AA?4?$AAW?$AAa?$AAi?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAc?$AAo?$AAn?$AAn?$AAe@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CH@FGBA@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?87?8?5a?$DN?8?$CFs?8?5p?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CH@MMNC@Waiting?5for?5the?5file?5to?5be?5recei@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@NFGI@Finish?5all?5files?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BO@LFEK@?$AA?4?$AA?4?$AA?4?$AAF?$AAi?$AAn?$AAi?$AAs?$AAh?$AAe?$AAd?$AA?4?$AA?4?$AA?4?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@EFIH@?$DMf?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?88?8?1?$DO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BI@LPHK@?$AA?4?$AA?4?$AA?4?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?4?$AA?4?$AA?4?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CM@ENML@Thread?5ended?3?5type?$DNfile_receive?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@NHEE@Set?5ft?9?$DOs?5to?5?$CFd?5?$CIsaving?5?$CFd?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EG@JOAE@Entering?5send?5loop?5for?5this?5file@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EC@KHJJ@Closing?5connection?5for?5this?5file@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@CBPP@ft?9?$DOs?5is?5restored?5to?5?$CFd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@NMB@?5Unknown?5packet?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04HHNC@?5OK?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FDGN@?5Unknown?5codec?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@EBIO@?$CB?$CB?5Skipping?5frame?5?$CB?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09HLBN@?$CFs?5?$CFd?5?$CFd?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@OEBH@Thread?5started?3?5type?$DNvoice_send?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CH@EDOE@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?86?8?5a?$DN?8?$CFs?8?5p?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@NBAC@Waiting?5for?5the?5voice?5data?5to?5be@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@LDFM@Finish?5voice?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@IMLC@ft?9?$DOs?5is?5NULL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@IPEE@Sending?5as?5client?4?4?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CP@CNGK@Entering?5send?5loop?5for?5this?5file@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CO@DACA@Closing?5connection?5for?5this?5file@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0ED@MCPA@Cannot?5allocate?5port?5to?5bind?5for@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@NAKP@Finish?5successfully?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BK@OCHC@?$AA?4?$AA?4?$AA?4?$AAD?$AAe?$AAn?$AAi?$AAe?$AAd?$AA?4?$AA?4?$AA?4?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@HICO@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?88?8?1?$DO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@FGGL@Finish?5with?5errors?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@JLOP@Thread?5ended?3?5type?$DNvoice_send?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@DINM@Closing?5ft?9?$DOs?5?$DN?5?$CFd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@CKCO@freeing?5?$CIV?$CJ?5ft?5struct?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03HCJC@jid?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02MECO@?$CFd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@EMAL@?$DMv?5t?$DN?8?$CFs?8?5e?$DN?81?8?5i?$DN?8?$CFs?8?5v?$DN?81?8?1?$DO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BA@FHJ@?$AAD?$AAI?$AAS?$AAP?$AAL?$AAA?$AAY?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CI@MBGJ@?$AA8?$AA0?$AA0?$AA0?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA1?$AA3?$AA?4?$AA8?$AA?5?$AAk?$AAb?$AAp?$AAs?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CK@BJKM@?$AA1?$AA1?$AA0?$AA2?$AA5?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA1?$AA9?$AA?4?$AA1?$AA?5?$AAk?$AAb?$AAp?$AAs@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CK@CJED@?$AA2?$AA2?$AA0?$AA5?$AA0?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA3?$AA6?$AA?4?$AA8?$AA?5?$AAk?$AAb?$AAp?$AAs@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CG@NCHG@?$AA4?$AA4?$AA1?$AA0?$AA0?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA7?$AA2?$AA?5?$AAk?$AAb?$AAp?$AAs?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BE@FBJM@?$AA?4?$AA?4?$AA?4?$AA?$DP?$AA?$DP?$AA?$DP?$AA?4?$AA?4?$AA?4?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09PMKM@?$CF?41f?5kB?1s?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@IBOM@LoginServer?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05FNBL@?$CFs?$EA?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@DJCK@CList?1GetContactDisplayName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@HHBC@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?85?8?5v?$DN?81?8?1?$DO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@GEK@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?84?8?5?1?$DO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@CKKI@VoiceChatPolicy?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BA@HMKN@?$AAD?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _Netlib_CloseHandle
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBGetContactSettingByte_Helper
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBGetContactSettingWord_Helper
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBGetContactSettingDword_Helper
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBGetContactSetting_Helper
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBGetContactSettingString_Helper
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBFreeVariant
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TranslateDialogDefault
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoicePlaybackCallback@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceRecordingThreadProc@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoicePlaybackStart
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceRecordingStart
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceCreateVC
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceFreeVc
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceCrypt
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceReceiveThread
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceReceivingConnection
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceReceiveParse
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceSendingThread
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceSendParse
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceCancelAll
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceContactMenuHandleVoice
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceIsInUse
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceMakeBitmap
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceInitVUMeters
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceDlgProc@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceDlgThread
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceStart
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _getDisplayName
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceAcceptDlgProc@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceAcceptDlgThread
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceAccept
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceBuildInDeviceList
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _TlenVoiceBuildOutDeviceList
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
_BSS	SEGMENT
_voiceDlgHWND DD 01H DUP (?)
_playbackControl DD 01H DUP (?)
_recordingControl DD 01H DUP (?)
_availPlayback DD 01H DUP (?)
_availOverrun DD 01H DUP (?)
_availLimit DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_modeFrequency DD 00H
	DD	00H
	DD	01f40H
	DD	02b11H
	DD	05622H
	DD	0ac44H
_modeFrameSize DD 00H
	DD	00H
	DD	05H
	DD	05H
	DD	0aH
	DD	019H
_availLimitMin DD 02H
_availLimitMax DD 04H
_vuMeterHeight DD 040H
_vuMeterWidth DD 014H
_vuMeterLevels DD 010H
_DATA	ENDS
PUBLIC	_TlenVoiceReceiveThread
PUBLIC	??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@		; `string'
PUBLIC	??_C@_0DI@NLKJ@Thread?5started?3?5type?$DNfile_receiv@ ; `string'
PUBLIC	??_C@_1CC@CDEO@?$AA?4?$AA?4?$AA?4?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAi?$AAn?$AAg?$AA?4?$AA?4?$AA?4?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BJ@MKNL@LangPack?1TranslateString?$AA@	; `string'
PUBLIC	??_C@_0BG@JEKK@Netlib?1OpenConnection?$AA@	; `string'
PUBLIC	??_C@_0BL@CMPD@Entering?5file?5receive?5loop?$AA@ ; `string'
PUBLIC	??_C@_0CI@OFJJ@Connection?5failed?5?9?5receiving?5as@ ; `string'
PUBLIC	??_C@_1DK@CHIL@?$AA?4?$AA?4?$AA?4?$AAW?$AAa?$AAi?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAc?$AAo?$AAn?$AAn?$AAe@ ; `string'
PUBLIC	??_C@_0CH@FGBA@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?87?8?5a?$DN?8?$CFs?8?5p?$DN@ ; `string'
PUBLIC	??_C@_0CH@MMNC@Waiting?5for?5the?5file?5to?5be?5recei@ ; `string'
PUBLIC	??_C@_0BB@NFGI@Finish?5all?5files?$AA@		; `string'
PUBLIC	??_C@_1BO@LFEK@?$AA?4?$AA?4?$AA?4?$AAF?$AAi?$AAn?$AAi?$AAs?$AAh?$AAe?$AAd?$AA?4?$AA?4?$AA?4?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BJ@EFIH@?$DMf?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?88?8?1?$DO?$AA@ ; `string'
PUBLIC	??_C@_1BI@LPHK@?$AA?4?$AA?4?$AA?4?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?4?$AA?4?$AA?4?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CM@ENML@Thread?5ended?3?5type?$DNfile_receive?5@ ; `string'
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	__imp__SetDlgItemTextW@12:NEAR
EXTRN	_mmi:BYTE
EXTRN	_JabberListRemove:NEAR
EXTRN	__imp__CreateEventW@16:NEAR
EXTRN	__imp__CloseHandle@4:NEAR
EXTRN	_TlenP2PFreeFileTransfer:NEAR
EXTRN	_TlenP2PEstablishOutgoingConnection:NEAR
EXTRN	_TlenP2PListen:NEAR
EXTRN	_JabberLog:NEAR
EXTRN	_JabberSend:NEAR
EXTRN	_JabberNickFromJID:NEAR
EXTRN	_pluginLink:DWORD
;	COMDAT ??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_netlib.h
_DATA	SEGMENT
??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@ DB 'Netlib/CloseHandle', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DI@NLKJ@Thread?5started?3?5type?$DNfile_receiv@
_DATA	SEGMENT
??_C@_0DI@NLKJ@Thread?5started?3?5type?$DNfile_receiv@ DB 'Thread started'
	DB	': type=file_receive server=''%s'' port=''%d''', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_1CC@CDEO@?$AA?4?$AA?4?$AA?4?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAi?$AAn?$AAg?$AA?4?$AA?4?$AA?4?$AA?$AA@
_DATA	SEGMENT
??_C@_1CC@CDEO@?$AA?4?$AA?4?$AA?4?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAi?$AAn?$AAg?$AA?4?$AA?4?$AA?4?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '.', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 'n', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '.'
	DB	00H, '.', 00H, '.', 00H, 00H, 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@MKNL@LangPack?1TranslateString?$AA@
_DATA	SEGMENT
??_C@_0BJ@MKNL@LangPack?1TranslateString?$AA@ DB 'LangPack/TranslateStrin'
	DB	'g', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@JEKK@Netlib?1OpenConnection?$AA@
_DATA	SEGMENT
??_C@_0BG@JEKK@Netlib?1OpenConnection?$AA@ DB 'Netlib/OpenConnection', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@CMPD@Entering?5file?5receive?5loop?$AA@
_DATA	SEGMENT
??_C@_0BL@CMPD@Entering?5file?5receive?5loop?$AA@ DB 'Entering file recei'
	DB	've loop', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@OFJJ@Connection?5failed?5?9?5receiving?5as@
_DATA	SEGMENT
??_C@_0CI@OFJJ@Connection?5failed?5?9?5receiving?5as@ DB 'Connection fail'
	DB	'ed - receiving as server', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_1DK@CHIL@?$AA?4?$AA?4?$AA?4?$AAW?$AAa?$AAi?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAc?$AAo?$AAn?$AAn?$AAe@
_DATA	SEGMENT
??_C@_1DK@CHIL@?$AA?4?$AA?4?$AA?4?$AAW?$AAa?$AAi?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAc?$AAo?$AAn?$AAn?$AAe@ DB '.'
	DB	00H, '.', 00H, '.', 00H, 'W', 00H, 'a', 00H, 'i', 00H, 't', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'n', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '.', 00H, '.'
	DB	00H, '.', 00H, 00H, 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CH@FGBA@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?87?8?5a?$DN?8?$CFs?8?5p?$DN@
_DATA	SEGMENT
??_C@_0CH@FGBA@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?87?8?5a?$DN?8?$CFs?8?5p?$DN@ DB '<'
	DB	'v t=''%s'' i=''%s'' e=''7'' a=''%s'' p=''%d''/>', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CH@MMNC@Waiting?5for?5the?5file?5to?5be?5recei@
_DATA	SEGMENT
??_C@_0CH@MMNC@Waiting?5for?5the?5file?5to?5be?5recei@ DB 'Waiting for th'
	DB	'e file to be received...', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@NFGI@Finish?5all?5files?$AA@
_DATA	SEGMENT
??_C@_0BB@NFGI@Finish?5all?5files?$AA@ DB 'Finish all files', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_1BO@LFEK@?$AA?4?$AA?4?$AA?4?$AAF?$AAi?$AAn?$AAi?$AAs?$AAh?$AAe?$AAd?$AA?4?$AA?4?$AA?4?$AA?$AA@
_DATA	SEGMENT
??_C@_1BO@LFEK@?$AA?4?$AA?4?$AA?4?$AAF?$AAi?$AAn?$AAi?$AAs?$AAh?$AAe?$AAd?$AA?4?$AA?4?$AA?4?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '.', 00H, 'F', 00H, 'i', 00H, 'n', 00H, 'i', 00H
	DB	's', 00H, 'h', 00H, 'e', 00H, 'd', 00H, '.', 00H, '.', 00H, '.'
	DB	00H, 00H, 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@EFIH@?$DMf?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?88?8?1?$DO?$AA@
_DATA	SEGMENT
??_C@_0BJ@EFIH@?$DMf?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?88?8?1?$DO?$AA@ DB '<'
	DB	'f t=''%s'' i=''%s'' e=''8''/>', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_1BI@LPHK@?$AA?4?$AA?4?$AA?4?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?4?$AA?4?$AA?4?$AA?$AA@
_DATA	SEGMENT
??_C@_1BI@LPHK@?$AA?4?$AA?4?$AA?4?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?4?$AA?4?$AA?4?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '.', 00H, 'E', 00H, 'r', 00H, 'r', 00H, 'o', 00H
	DB	'r', 00H, '.', 00H, '.', 00H, '.', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CM@ENML@Thread?5ended?3?5type?$DNfile_receive?5@
_DATA	SEGMENT
??_C@_0CM@ENML@Thread?5ended?3?5type?$DNfile_receive?5@ DB 'Thread ended:'
	DB	' type=file_receive server=''%s''', 00H	; `string'
_DATA	ENDS
;	COMDAT _TlenVoiceReceiveThread
_TEXT	SEGMENT
_ft$ = 8
_nloc$ = -24
_s$ = 8
_nick$83688 = -28
_TlenVoiceReceiveThread PROC NEAR			; COMDAT

; 351  : {

  00000	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 352  : 	NETLIBOPENCONNECTION nloc;
; 353  : 	JABBER_SOCKET s;
; 354  : 
; 355  : 	JabberLog(ft->proto, "Thread started: type=file_receive server='%s' port='%d'", ft->hostName, ft->wPort);

  00006	8b 74 24 2c	 mov	 esi, DWORD PTR _ft$[esp+36]
  0000a	57		 push	 edi
  0000b	0f b7 46 24	 movzx	 eax, WORD PTR [esi+36]
  0000f	50		 push	 eax
  00010	ff 76 20	 push	 DWORD PTR [esi+32]
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DI@NLKJ@Thread?5started?3?5type?$DNfile_receiv@ ; `string'
  00018	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  0001e	e8 00 00 00 00	 call	 _JabberLog

; 356  : 	nloc.cbSize = NETLIBOPENCONNECTION_V1_SIZE;//sizeof(NETLIBOPENCONNECTION);
; 357  : 	nloc.szHost = ft->hostName;

  00023	8b 46 20	 mov	 eax, DWORD PTR [esi+32]

; 358  : 	nloc.wPort = ft->wPort;
; 359  : 	nloc.flags = 0;
; 360  : 	SetDlgItemText(voiceDlgHWND, IDC_STATUS, TranslateT("...Connecting..."));

  00026	bb 00 10 00 00	 mov	 ebx, 4096		; 00001000H
  0002b	89 44 24 28	 mov	 DWORD PTR _nloc$[esp+64], eax
  0002f	66 8b 46 24	 mov	 ax, WORD PTR [esi+36]
  00033	66 89 44 24 2c	 mov	 WORD PTR _nloc$[esp+68], ax
  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CC@CDEO@?$AA?4?$AA?4?$AA?4?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAi?$AAn?$AAg?$AA?4?$AA?4?$AA?4?$AA?$AA@ ; `string'
  00042	33 ff		 xor	 edi, edi
  00044	53		 push	 ebx
  00045	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@MKNL@LangPack?1TranslateString?$AA@ ; `string'
  0004a	c7 44 24 30 10
	00 00 00	 mov	 DWORD PTR _nloc$[esp+72], 16 ; 00000010H
  00052	89 7c 24 3c	 mov	 DWORD PTR _nloc$[esp+84], edi
  00056	ff 50 24	 call	 DWORD PTR [eax+36]
  00059	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__SetDlgItemTextW@12
  0005f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00062	50		 push	 eax
  00063	68 86 05 00 00	 push	 1414			; 00000586H
  00068	ff 35 00 00 00
	00		 push	 DWORD PTR _voiceDlgHWND
  0006e	ff d5		 call	 ebp

; 361  : //	ProtoBroadcastAck(iface.m_szModuleName, ft->hContact, ACKTYPE_FILE, ACKRESULT_CONNECTING, ft, 0);
; 362  : 	s = (HANDLE) CallService(MS_NETLIB_OPENCONNECTION, (WPARAM) ft->proto->hNetlibUser, (LPARAM) &nloc);

  00070	8d 44 24 14	 lea	 eax, DWORD PTR _nloc$[esp+44]
  00074	50		 push	 eax
  00075	8b 86 7c 02 00
	00		 mov	 eax, DWORD PTR [esi+636]
  0007b	ff b0 c0 00 00
	00		 push	 DWORD PTR [eax+192]
  00081	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00086	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@JEKK@Netlib?1OpenConnection?$AA@ ; `string'
  0008b	ff 50 24	 call	 DWORD PTR [eax+36]
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 363  : 	if (s != NULL) {

  00091	3b c7		 cmp	 eax, edi
  00093	89 44 24 30	 mov	 DWORD PTR _s$[esp+40], eax
  00097	0f 84 9c 00 00
	00		 je	 $L83672

; 364  : 		ft->s = s;
; 365  : 		JabberLog(ft->proto, "Entering file receive loop");

  0009d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@CMPD@Entering?5file?5receive?5loop?$AA@ ; `string'
  000a2	89 46 04	 mov	 DWORD PTR [esi+4], eax
  000a5	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  000ab	e8 00 00 00 00	 call	 _JabberLog

; 366  : 		TlenP2PEstablishOutgoingConnection(ft, FALSE);

  000b0	57		 push	 edi
  000b1	56		 push	 esi
  000b2	e8 00 00 00 00	 call	 _TlenP2PEstablishOutgoingConnection
  000b7	83 c4 10	 add	 esp, 16			; 00000010H

; 367  : 		if (ft->state!=FT_ERROR) {

  000ba	83 7e 0c 04	 cmp	 DWORD PTR [esi+12], 4
  000be	74 57		 je	 SHORT $L83674

; 368  : 			playbackControl = NULL;
; 369  : 			recordingControl = TlenVoiceCreateVC(ft->proto, 3);

  000c0	6a 03		 push	 3
  000c2	89 3d 00 00 00
	00		 mov	 DWORD PTR _playbackControl, edi
  000c8	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  000ce	e8 00 00 00 00	 call	 _TlenVoiceCreateVC
  000d3	a3 00 00 00 00	 mov	 DWORD PTR _recordingControl, eax

; 370  : 			recordingControl->ft = ft;

  000d8	89 70 40	 mov	 DWORD PTR [eax+64], esi

; 371  : 			TlenVoiceRecordingStart(recordingControl);

  000db	ff 35 00 00 00
	00		 push	 DWORD PTR _recordingControl
  000e1	e8 00 00 00 00	 call	 _TlenVoiceRecordingStart
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH
$L84497:

; 372  : 			while (ft->state!=FT_DONE && ft->state!=FT_ERROR) {

  000e9	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000ec	83 f8 03	 cmp	 eax, 3
  000ef	74 0e		 je	 SHORT $L83678
  000f1	83 f8 04	 cmp	 eax, 4
  000f4	74 09		 je	 SHORT $L83678

; 373  : 				TlenVoiceReceiveParse(ft);

  000f6	56		 push	 esi
  000f7	e8 00 00 00 00	 call	 _TlenVoiceReceiveParse
  000fc	59		 pop	 ecx
  000fd	eb ea		 jmp	 SHORT $L84497
$L83678:

; 374  : 			}
; 375  : 			TlenVoiceFreeVc(recordingControl);

  000ff	ff 35 00 00 00
	00		 push	 DWORD PTR _recordingControl
  00105	e8 00 00 00 00	 call	 _TlenVoiceFreeVc
  0010a	59		 pop	 ecx

; 376  : 			playbackControl = NULL;

  0010b	89 3d 00 00 00
	00		 mov	 DWORD PTR _playbackControl, edi

; 377  : 			recordingControl = NULL;

  00111	89 3d 00 00 00
	00		 mov	 DWORD PTR _recordingControl, edi
$L83674:

; 378  : 		}
; 379  : 		if (ft->s) {

  00117	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  0011a	74 15		 je	 SHORT $L84490

; 380  : 			Netlib_CloseHandle(s);

  0011c	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00121	57		 push	 edi
  00122	ff 74 24 34	 push	 DWORD PTR _s$[esp+44]
  00126	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@ ; `string'
  0012b	ff 50 24	 call	 DWORD PTR [eax+36]
  0012e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L84490:

; 381  : 		}
; 382  : 		ft->s = NULL;

  00131	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 383  : 	} else {

  00134	e9 f7 00 00 00	 jmp	 $L83698
$L83672:

; 384  : 		JabberLog(ft->proto, "Connection failed - receiving as server");

  00139	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@OFJJ@Connection?5failed?5?9?5receiving?5as@ ; `string'
  0013e	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  00144	e8 00 00 00 00	 call	 _JabberLog

; 385  : 		ft->pfnNewConnectionV2 = TlenVoiceReceivingConnection;
; 386  : 		s = TlenP2PListen(ft);

  00149	56		 push	 esi
  0014a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET FLAT:_TlenVoiceReceivingConnection
  00151	e8 00 00 00 00	 call	 _TlenP2PListen
  00156	83 c4 0c	 add	 esp, 12			; 0000000cH

; 387  : 		if (s != NULL) {

  00159	3b c7		 cmp	 eax, edi
  0015b	89 44 24 30	 mov	 DWORD PTR _s$[esp+40], eax
  0015f	0f 84 c4 00 00
	00		 je	 $L83686

; 388  : 			HANDLE hEvent;
; 389  : 			char *nick;
; 390  : 			SetDlgItemText(voiceDlgHWND, IDC_STATUS, TranslateT("...Waiting for connection..."));

  00165	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0016a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DK@CHIL@?$AA?4?$AA?4?$AA?4?$AAW?$AAa?$AAi?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAc?$AAo?$AAn?$AAn?$AAe@ ; `string'
  0016f	53		 push	 ebx
  00170	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@MKNL@LangPack?1TranslateString?$AA@ ; `string'
  00175	ff 50 24	 call	 DWORD PTR [eax+36]
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017b	50		 push	 eax
  0017c	68 86 05 00 00	 push	 1414			; 00000586H
  00181	ff 35 00 00 00
	00		 push	 DWORD PTR _voiceDlgHWND
  00187	ff d5		 call	 ebp

; 391  : 			ft->s = s;

  00189	8b 44 24 30	 mov	 eax, DWORD PTR _s$[esp+40]

; 392  : 			hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  0018d	57		 push	 edi
  0018e	57		 push	 edi
  0018f	57		 push	 edi
  00190	57		 push	 edi
  00191	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00194	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateEventW@16

; 393  : 			ft->hFileEvent = hEvent;
; 394  : 			ft->currentFile = 0;
; 395  : 			ft->state = FT_CONNECTING;
; 396  : 			nick = JabberNickFromJID(ft->jid);

  0019a	ff 76 10	 push	 DWORD PTR [esi+16]
  0019d	8b d8		 mov	 ebx, eax
  0019f	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx
  001a2	89 7e 58	 mov	 DWORD PTR [esi+88], edi
  001a5	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  001a8	e8 00 00 00 00	 call	 _JabberNickFromJID

; 397  : 			JabberSend(ft->proto, "<v t='%s' i='%s' e='7' a='%s' p='%d'/>", nick, ft->iqId, ft->localName, ft->wLocalPort);

  001ad	0f b7 4e 2c	 movzx	 ecx, WORD PTR [esi+44]
  001b1	51		 push	 ecx
  001b2	89 44 24 18	 mov	 DWORD PTR _nick$83688[esp+52], eax
  001b6	ff 76 28	 push	 DWORD PTR [esi+40]
  001b9	ff 76 18	 push	 DWORD PTR [esi+24]
  001bc	50		 push	 eax
  001bd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@FGBA@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?87?8?5a?$DN?8?$CFs?8?5p?$DN@ ; `string'
  001c2	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  001c8	e8 00 00 00 00	 call	 _JabberSend

; 398  : 			mir_free(nick);

  001cd	ff 74 24 2c	 push	 DWORD PTR _nick$83688[esp+72]
  001d1	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12

; 399  : 			JabberLog(ft->proto, "Waiting for the file to be received...");

  001d7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@MMNC@Waiting?5for?5the?5file?5to?5be?5recei@ ; `string'
  001dc	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  001e2	e8 00 00 00 00	 call	 _JabberLog
  001e7	83 c4 28	 add	 esp, 40			; 00000028H

; 400  : 			WaitForSingleObject(hEvent, INFINITE);

  001ea	6a ff		 push	 -1
  001ec	53		 push	 ebx
  001ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 401  : 			ft->hFileEvent = NULL;
; 402  : 			CloseHandle(hEvent);

  001f3	53		 push	 ebx
  001f4	89 7e 3c	 mov	 DWORD PTR [esi+60], edi
  001f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 403  : 			JabberLog(ft->proto, "Finish all files");

  001fd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@NFGI@Finish?5all?5files?$AA@ ; `string'
  00202	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  00208	e8 00 00 00 00	 call	 _JabberLog

; 404  : 			Netlib_CloseHandle(s);

  0020d	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00212	57		 push	 edi
  00213	ff 74 24 3c	 push	 DWORD PTR _s$[esp+52]
  00217	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@ ; `string'
  0021c	ff 50 24	 call	 DWORD PTR [eax+36]
  0021f	83 c4 14	 add	 esp, 20			; 00000014H

; 405  : 		} else {

  00222	bb 00 10 00 00	 mov	 ebx, 4096		; 00001000H
  00227	eb 07		 jmp	 SHORT $L83698
$L83686:

; 406  : 			ft->state = FT_ERROR;

  00229	c7 46 0c 04 00
	00 00		 mov	 DWORD PTR [esi+12], 4
$L83698:

; 407  : 		}
; 408  : 	}
; 409  : 	JabberListRemove(ft->proto, LIST_VOICE, ft->iqId);

  00230	ff 76 18	 push	 DWORD PTR [esi+24]
  00233	6a 05		 push	 5
  00235	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  0023b	e8 00 00 00 00	 call	 _JabberListRemove
  00240	83 c4 0c	 add	 esp, 12			; 0000000cH

; 410  : 	if (ft->state==FT_DONE) {

  00243	83 7e 0c 03	 cmp	 DWORD PTR [esi+12], 3
  00247	75 18		 jne	 SHORT $L83699

; 411  : 		SetDlgItemText(voiceDlgHWND, IDC_STATUS, TranslateT("...Finished..."));

  00249	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0024e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BO@LFEK@?$AA?4?$AA?4?$AA?4?$AAF?$AAi?$AAn?$AAi?$AAs?$AAh?$AAe?$AAd?$AA?4?$AA?4?$AA?4?$AA?$AA@ ; `string'
  00253	53		 push	 ebx
  00254	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@MKNL@LangPack?1TranslateString?$AA@ ; `string'
  00259	ff 50 24	 call	 DWORD PTR [eax+36]
  0025c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 412  : 		//ProtoBroadcastAck(iface.m_szModuleName, ft->hContact, ACKTYPE_FILE, ACKRESULT_SUCCESS, ft, 0);
; 413  : 	} else {

  0025f	eb 3b		 jmp	 SHORT $L84498
$L83699:

; 414  : 		char *nick;
; 415  : 		nick = JabberNickFromJID(ft->jid);

  00261	ff 76 10	 push	 DWORD PTR [esi+16]
  00264	e8 00 00 00 00	 call	 _JabberNickFromJID

; 416  : 		JabberSend(ft->proto, "<f t='%s' i='%s' e='8'/>", nick, ft->iqId);

  00269	ff 76 18	 push	 DWORD PTR [esi+24]
  0026c	8b f8		 mov	 edi, eax
  0026e	57		 push	 edi
  0026f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@EFIH@?$DMf?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?88?8?1?$DO?$AA@ ; `string'
  00274	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  0027a	e8 00 00 00 00	 call	 _JabberSend

; 417  : 		mir_free(nick);

  0027f	57		 push	 edi
  00280	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12

; 418  : 		SetDlgItemText(voiceDlgHWND, IDC_STATUS, TranslateT("...Error..."));

  00286	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0028b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@LPHK@?$AA?4?$AA?4?$AA?4?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?4?$AA?4?$AA?4?$AA?$AA@ ; `string'
  00290	53		 push	 ebx
  00291	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@MKNL@LangPack?1TranslateString?$AA@ ; `string'
  00296	ff 50 24	 call	 DWORD PTR [eax+36]
  00299	83 c4 24	 add	 esp, 36			; 00000024H
$L84498:
  0029c	50		 push	 eax
  0029d	68 86 05 00 00	 push	 1414			; 00000586H
  002a2	ff 35 00 00 00
	00		 push	 DWORD PTR _voiceDlgHWND
  002a8	ff d5		 call	 ebp

; 419  : 		//ProtoBroadcastAck(iface.m_szModuleName, ft->hContact, ACKTYPE_FILE, ACKRESULT_FAILED, ft, 0);
; 420  : 	}
; 421  : 	JabberLog(ft->proto, "Thread ended: type=file_receive server='%s'", ft->hostName);

  002aa	ff 76 20	 push	 DWORD PTR [esi+32]
  002ad	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CM@ENML@Thread?5ended?3?5type?$DNfile_receive?5@ ; `string'
  002b2	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  002b8	e8 00 00 00 00	 call	 _JabberLog

; 422  : 
; 423  : 	TlenP2PFreeFileTransfer(ft);

  002bd	56		 push	 esi
  002be	e8 00 00 00 00	 call	 _TlenP2PFreeFileTransfer
  002c3	83 c4 10	 add	 esp, 16			; 00000010H
  002c6	5f		 pop	 edi
  002c7	5e		 pop	 esi
  002c8	5d		 pop	 ebp
  002c9	5b		 pop	 ebx

; 424  : }

  002ca	83 c4 1c	 add	 esp, 28			; 0000001cH
  002cd	c3		 ret	 0
_TlenVoiceReceiveThread ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@	; `string'
PUBLIC	??_C@_0O@EBHE@VoiceDeviceIn?$AA@		; `string'
PUBLIC	??_C@_0BO@PNKF@Recording?5device?5ID?5?$CD?$CFu?3?5?$CFs?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@JLOF@TlenVoiceStart?5FAILED?5?$CFd?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BK@MAGB@TlenVoiceStart?5FAILED?5?$CD2?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BE@HLBB@TlenVoiceRStart?5OK?$CB?$AA@	; `string'
EXTRN	__imp__waveInGetNumDevs@0:NEAR
EXTRN	__imp__waveInGetDevCapsW@12:NEAR
EXTRN	__imp__waveInOpen@24:NEAR
EXTRN	__imp__waveInClose@4:NEAR
EXTRN	__imp__waveInPrepareHeader@12:NEAR
EXTRN	__imp__waveInAddBuffer@12:NEAR
EXTRN	__imp__waveInStart@4:NEAR
EXTRN	_memset:NEAR
EXTRN	__imp__PostThreadMessageW@16:NEAR
EXTRN	__imp__CreateThread@24:NEAR
EXTRN	__imp__SetThreadPriority@8:NEAR
;	COMDAT ??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_database.h
_DATA	SEGMENT
??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@ DB 'DB/Contact/GetSetting', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@EBHE@VoiceDeviceIn?$AA@
_DATA	SEGMENT
??_C@_0O@EBHE@VoiceDeviceIn?$AA@ DB 'VoiceDeviceIn', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@PNKF@Recording?5device?5ID?5?$CD?$CFu?3?5?$CFs?$AN?6?$AA@
_DATA	SEGMENT
??_C@_0BO@PNKF@Recording?5device?5ID?5?$CD?$CFu?3?5?$CFs?$AN?6?$AA@ DB 'R'
	DB	'ecording device ID #%u: %s', 0dH, 0aH, 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@JLOF@TlenVoiceStart?5FAILED?5?$CFd?$CB?$AA@
_DATA	SEGMENT
??_C@_0BK@JLOF@TlenVoiceStart?5FAILED?5?$CFd?$CB?$AA@ DB 'TlenVoiceStart '
	DB	'FAILED %d!', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@MAGB@TlenVoiceStart?5FAILED?5?$CD2?$CB?$AA@
_DATA	SEGMENT
??_C@_0BK@MAGB@TlenVoiceStart?5FAILED?5?$CD2?$CB?$AA@ DB 'TlenVoiceStart '
	DB	'FAILED #2!', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HLBB@TlenVoiceRStart?5OK?$CB?$AA@
_DATA	SEGMENT
??_C@_0BE@HLBB@TlenVoiceRStart?5OK?$CB?$AA@ DB 'TlenVoiceRStart OK!', 00H ; `string'
_DATA	ENDS
;	COMDAT _TlenVoiceRecordingStart
_TEXT	SEGMENT
_dbv$84503 = -56
_cgs$84504 = -44
_control$ = 8
_wfm$ = -32
_mmres$ = 8
_i$ = 8
_j$ = -8
_iNumDevs$ = -12
_iSelDev$ = -4
_wic$ = -136
_TlenVoiceRecordingStart PROC NEAR			; COMDAT

; 205  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 206  : 	WAVEFORMATEX wfm;
; 207  : 	MMRESULT mmres;
; 208  : 	int i, j;
; 209  : 	int iNumDevs, iSelDev;
; 210  : 	WAVEINCAPS     wic;
; 211  : 
; 212  :     memset(&wfm, 0, sizeof(wfm));

  0000c	33 ff		 xor	 edi, edi
  0000e	6a 12		 push	 18			; 00000012H
  00010	8d 45 e0	 lea	 eax, DWORD PTR _wfm$[ebp]
  00013	57		 push	 edi
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _memset

; 213  :     wfm.cbSize          = sizeof(WAVEFORMATEX);
; 214  :     wfm.nChannels       = 1;
; 215  :     wfm.wBitsPerSample  = 16;
; 216  :     wfm.nSamplesPerSec  = modeFrequency[control->codec];

  0001a	8b 75 08	 mov	 esi, DWORD PTR _control$[ebp]
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	66 c7 45 f0 12
	00		 mov	 WORD PTR _wfm$[ebp+16], 18 ; 00000012H
  00026	66 c7 45 e2 01
	00		 mov	 WORD PTR _wfm$[ebp+2], 1
  0002c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 217  :     wfm.nAvgBytesPerSec = wfm.nSamplesPerSec * wfm.nChannels * wfm.wBitsPerSample/8;
; 218  :     wfm.nBlockAlign     = 2 * wfm.nChannels;

  0002f	6a 02		 push	 2
  00031	c1 e0 02	 shl	 eax, 2

; 219  :     wfm.wFormatTag      = WAVE_FORMAT_PCM;
; 220  : 
; 221  : 
; 222  : 	control->waveMode		= 0;
; 223  : //	control->isRunning	= 1;
; 224  : 	control->waveFrameSize = modeFrameSize[control->codec] * 160 * wfm.nChannels;// * wfm.wBitsPerSample / 8;
; 225  : 	control->waveHeadersPos = 0;
; 226  : 	control->waveHeadersNum = 2;
; 227  : 
; 228  : 	control->hThread = CreateThread( NULL,
; 229  :                             0,
; 230  :                             (LPTHREAD_START_ROUTINE)TlenVoiceRecordingThreadProc,
; 231  :                             control,
; 232  :                             0,
; 233  :                             (LPDWORD)&control->threadID);

  00034	8d 5e 28	 lea	 ebx, DWORD PTR [esi+40]
  00037	66 c7 45 ee 10
	00		 mov	 WORD PTR _wfm$[ebp+14], 16 ; 00000010H
  0003d	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _modeFrequency[eax]
  00043	89 3e		 mov	 DWORD PTR [esi], edi
  00045	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _modeFrameSize[eax]
  0004b	89 4d e4	 mov	 DWORD PTR _wfm$[ebp+4], ecx
  0004e	c1 e1 04	 shl	 ecx, 4
  00051	c1 e9 03	 shr	 ecx, 3
  00054	89 4d e8	 mov	 DWORD PTR _wfm$[ebp+8], ecx
  00057	59		 pop	 ecx
  00058	53		 push	 ebx
  00059	57		 push	 edi
  0005a	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0005d	56		 push	 esi
  0005e	68 00 00 00 00	 push	 OFFSET FLAT:_TlenVoiceRecordingThreadProc@4
  00063	57		 push	 edi
  00064	c1 e0 05	 shl	 eax, 5
  00067	57		 push	 edi
  00068	66 89 4d ec	 mov	 WORD PTR _wfm$[ebp+12], cx
  0006c	66 c7 45 e0 01
	00		 mov	 WORD PTR _wfm$[ebp], 1
  00072	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00075	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00078	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24

; 234  : 
; 235  : 
; 236  : 	SetThreadPriority(control->hThread, THREAD_PRIORITY_ABOVE_NORMAL);

  00081	6a 01		 push	 1
  00083	50		 push	 eax
  00084	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadPriority@8

; 237  : 
; 238  : 	j = DBGetContactSettingWord(NULL, control->proto->iface.m_szModuleName, "VoiceDeviceIn", 0);

  0008d	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00090	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _cgs$84504[ebp+4], OFFSET FLAT:??_C@_0O@EBHE@VoiceDeviceIn?$AA@ ; `string'
  00097	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0009a	89 45 d4	 mov	 DWORD PTR _cgs$84504[ebp], eax
  0009d	8d 45 c8	 lea	 eax, DWORD PTR _dbv$84503[ebp]
  000a0	89 45 dc	 mov	 DWORD PTR _cgs$84504[ebp+8], eax
  000a3	8d 45 d4	 lea	 eax, DWORD PTR _cgs$84504[ebp]
  000a6	50		 push	 eax
  000a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  000ac	57		 push	 edi
  000ad	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@ ; `string'
  000b2	ff 50 24	 call	 DWORD PTR [eax+36]
  000b5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b8	85 c0		 test	 eax, eax
  000ba	74 05		 je	 SHORT $L84505
  000bc	89 7d f8	 mov	 DWORD PTR _j$[ebp], edi
  000bf	eb 07		 jmp	 SHORT $L84502
$L84505:
  000c1	0f b7 45 cc	 movzx	 eax, WORD PTR _dbv$84503[ebp+4]
  000c5	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$L84502:

; 239  : 	iSelDev = WAVE_MAPPER;

  000c8	83 4d fc ff	 or	 DWORD PTR _iSelDev$[ebp], -1

; 240  : 	if (j!=0) {

  000cc	39 7d f8	 cmp	 DWORD PTR _j$[ebp], edi
  000cf	74 43		 je	 SHORT $L83572

; 241  : 		iNumDevs = waveInGetNumDevs();

  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveInGetNumDevs@0

; 242  : 		for (i = 0; i < iNumDevs; i++) {

  000d7	3b c7		 cmp	 eax, edi
  000d9	89 45 f4	 mov	 DWORD PTR _iNumDevs$[ebp], eax
  000dc	89 7d 08	 mov	 DWORD PTR _i$[ebp], edi
  000df	7e 33		 jle	 SHORT $L83572
$L83570:

; 243  : 			if (!waveInGetDevCaps(i, &wic, sizeof(WAVEINCAPS))) {

  000e1	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _wic$[ebp]
  000e7	6a 50		 push	 80			; 00000050H
  000e9	50		 push	 eax
  000ea	ff 75 08	 push	 DWORD PTR _i$[ebp]
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveInGetDevCapsW@12
  000f3	85 c0		 test	 eax, eax
  000f5	75 0a		 jne	 SHORT $L83571

; 244  : 				if (wic.dwFormats != 0) {

  000f7	39 7d c0	 cmp	 DWORD PTR _wic$[ebp+72], edi
  000fa	74 05		 je	 SHORT $L83571

; 245  : 					j--;

  000fc	ff 4d f8	 dec	 DWORD PTR _j$[ebp]

; 246  : 					if (j == 0) {

  000ff	74 0d		 je	 SHORT $L84512
$L83571:

; 242  : 		for (i = 0; i < iNumDevs; i++) {

  00101	ff 45 08	 inc	 DWORD PTR _i$[ebp]
  00104	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00107	3b 45 f4	 cmp	 eax, DWORD PTR _iNumDevs$[ebp]
  0010a	7c d5		 jl	 SHORT $L83570

; 273  : 		if (mmres!=MMSYSERR_NOERROR) {

  0010c	eb 06		 jmp	 SHORT $L83572
$L84512:

; 247  : 						iSelDev = i;

  0010e	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00111	89 45 fc	 mov	 DWORD PTR _iSelDev$[ebp], eax
$L83572:

; 248  : 						break;
; 249  : 					}
; 250  : 				}
; 251  : 			}
; 252  : 		}
; 253  : 	}
; 254  : 	if (!waveInGetDevCaps(iSelDev, &wic, sizeof(WAVEINCAPS))) {

  00114	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _wic$[ebp]
  0011a	6a 50		 push	 80			; 00000050H
  0011c	50		 push	 eax
  0011d	ff 75 fc	 push	 DWORD PTR _iSelDev$[ebp]
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveInGetDevCapsW@12
  00126	85 c0		 test	 eax, eax
  00128	75 17		 jne	 SHORT $L83578

; 255  : 		JabberLog(control->proto, "Recording device ID #%u: %s\r\n", iSelDev, wic.szPname);

  0012a	8d 45 80	 lea	 eax, DWORD PTR _wic$[ebp+8]
  0012d	50		 push	 eax
  0012e	ff 75 fc	 push	 DWORD PTR _iSelDev$[ebp]
  00131	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@PNKF@Recording?5device?5ID?5?$CD?$CFu?3?5?$CFs?$AN?6?$AA@ ; `string'
  00136	ff 76 4c	 push	 DWORD PTR [esi+76]
  00139	e8 00 00 00 00	 call	 _JabberLog
  0013e	83 c4 10	 add	 esp, 16			; 00000010H
$L83578:

; 256  : 	}
; 257  : 
; 258  : 	mmres = waveInOpen(&control->hWaveIn, iSelDev, &wfm, (DWORD) control->threadID, 0, CALLBACK_THREAD);

  00141	68 00 00 02 00	 push	 131072			; 00020000H
  00146	57		 push	 edi
  00147	ff 33		 push	 DWORD PTR [ebx]
  00149	8d 4d e0	 lea	 ecx, DWORD PTR _wfm$[ebp]
  0014c	8d 46 30	 lea	 eax, DWORD PTR [esi+48]
  0014f	51		 push	 ecx
  00150	ff 75 fc	 push	 DWORD PTR _iSelDev$[ebp]
  00153	50		 push	 eax
  00154	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveInOpen@24

; 259  : //	mmres = waveInOpen(&control->hWaveIn, 3, &wfm, (DWORD) &TlenVoiceRecordingCallback, (DWORD) control, CALLBACK_FUNCTION);
; 260  : 	if (mmres!=MMSYSERR_NOERROR) {

  0015a	3b c7		 cmp	 eax, edi
  0015c	89 45 08	 mov	 DWORD PTR _mmres$[ebp], eax
  0015f	74 27		 je	 SHORT $L83581

; 261  : 		PostThreadMessage(control->threadID, WIM_CLOSE, 0, 0);

  00161	57		 push	 edi
  00162	57		 push	 edi
  00163	68 bf 03 00 00	 push	 959			; 000003bfH
  00168	ff 33		 push	 DWORD PTR [ebx]
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostThreadMessageW@16

; 262  : 		JabberLog(control->proto, "TlenVoiceStart FAILED %d!", mmres);

  00170	ff 75 08	 push	 DWORD PTR _mmres$[ebp]
  00173	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@JLOF@TlenVoiceStart?5FAILED?5?$CFd?$CB?$AA@ ; `string'
  00178	ff 76 4c	 push	 DWORD PTR [esi+76]
  0017b	e8 00 00 00 00	 call	 _JabberLog
  00180	83 c4 0c	 add	 esp, 12			; 0000000cH

; 263  : 		return 1;

  00183	e9 e2 00 00 00	 jmp	 $L84520
$L83581:

; 264  : 	}
; 265  : 	control->waveData = (short *)mir_alloc(control->waveHeadersNum * control->waveFrameSize * 2);

  00188	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0018b	0f af 46 18	 imul	 eax, DWORD PTR [esi+24]
  0018f	d1 e0		 shl	 eax, 1
  00191	50		 push	 eax
  00192	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4

; 266  : 	memset(control->waveData, 0, control->waveHeadersNum * control->waveFrameSize * 2);

  00198	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0019b	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0019e	0f af 4e 18	 imul	 ecx, DWORD PTR [esi+24]
  001a2	d1 e1		 shl	 ecx, 1
  001a4	51		 push	 ecx
  001a5	57		 push	 edi
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 _memset

; 267  : 	control->waveHeaders = (WAVEHDR *)mir_alloc(control->waveHeadersNum * sizeof(WAVEHDR));

  001ac	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  001af	c1 e0 05	 shl	 eax, 5
  001b2	50		 push	 eax
  001b3	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  001b9	83 c4 14	 add	 esp, 20			; 00000014H

; 268  : 	for (i=0;i<control->waveHeadersNum;i++) {

  001bc	39 7e 20	 cmp	 DWORD PTR [esi+32], edi
  001bf	89 46 14	 mov	 DWORD PTR [esi+20], eax
  001c2	89 7d 08	 mov	 DWORD PTR _i$[ebp], edi
  001c5	7e 4b		 jle	 SHORT $L83588

; 264  : 	}
; 265  : 	control->waveData = (short *)mir_alloc(control->waveHeadersNum * control->waveFrameSize * 2);

  001c7	33 db		 xor	 ebx, ebx
$L83586:

; 269  : 		control->waveHeaders[i].dwFlags = 0;//WHDR_DONE;

  001c9	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 270  : 		control->waveHeaders[i].lpData = (char *) (control->waveData + i * control->waveFrameSize);
; 271  : 		control->waveHeaders[i].dwBufferLength = control->waveFrameSize *2;
; 272  : 		mmres = waveInPrepareHeader(control->hWaveIn, &control->waveHeaders[i], sizeof(WAVEHDR));

  001cc	6a 20		 push	 32			; 00000020H
  001ce	89 7c 03 10	 mov	 DWORD PTR [ebx+eax+16], edi
  001d2	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  001d5	0f af 45 08	 imul	 eax, DWORD PTR _i$[ebp]
  001d9	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  001dc	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  001df	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  001e2	89 04 0b	 mov	 DWORD PTR [ebx+ecx], eax
  001e5	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  001e8	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  001eb	d1 e0		 shl	 eax, 1
  001ed	89 44 0b 04	 mov	 DWORD PTR [ebx+ecx+4], eax
  001f1	8b c3		 mov	 eax, ebx
  001f3	03 46 14	 add	 eax, DWORD PTR [esi+20]
  001f6	50		 push	 eax
  001f7	ff 76 30	 push	 DWORD PTR [esi+48]
  001fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveInPrepareHeader@12

; 273  : 		if (mmres!=MMSYSERR_NOERROR) {

  00200	85 c0		 test	 eax, eax
  00202	75 4e		 jne	 SHORT $L84513
  00204	ff 45 08	 inc	 DWORD PTR _i$[ebp]
  00207	83 c3 20	 add	 ebx, 32			; 00000020H
  0020a	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0020d	3b 46 20	 cmp	 eax, DWORD PTR [esi+32]
  00210	7c b7		 jl	 SHORT $L83586
$L83588:

; 278  : 	   	}
; 279  : 	}
; 280  : 	for (i=0;i<control->waveHeadersNum;i++) {

  00212	33 db		 xor	 ebx, ebx
  00214	39 7e 20	 cmp	 DWORD PTR [esi+32], edi
  00217	7e 1a		 jle	 SHORT $L83595
$L83593:
  00219	8b c7		 mov	 eax, edi

; 281  : 		waveInAddBuffer(control->hWaveIn, &control->waveHeaders[i], sizeof(WAVEHDR));

  0021b	6a 20		 push	 32			; 00000020H
  0021d	03 46 14	 add	 eax, DWORD PTR [esi+20]
  00220	50		 push	 eax
  00221	ff 76 30	 push	 DWORD PTR [esi+48]
  00224	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveInAddBuffer@12
  0022a	43		 inc	 ebx
  0022b	83 c7 20	 add	 edi, 32			; 00000020H
  0022e	3b 5e 20	 cmp	 ebx, DWORD PTR [esi+32]
  00231	7c e6		 jl	 SHORT $L83593
$L83595:

; 282  : 	}
; 283  : 	waveInStart(control->hWaveIn);

  00233	ff 76 30	 push	 DWORD PTR [esi+48]
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveInStart@4

; 284  : 	JabberLog(control->proto, "TlenVoiceRStart OK!");

  0023c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@HLBB@TlenVoiceRStart?5OK?$CB?$AA@ ; `string'
  00241	ff 76 4c	 push	 DWORD PTR [esi+76]
  00244	e8 00 00 00 00	 call	 _JabberLog
  00249	59		 pop	 ecx

; 285  : 	return 0;

  0024a	33 c0		 xor	 eax, eax
  0024c	59		 pop	 ecx
$L83554:
  0024d	5f		 pop	 edi
  0024e	5e		 pop	 esi
  0024f	5b		 pop	 ebx

; 286  : }

  00250	c9		 leave
  00251	c3		 ret	 0
$L84513:

; 274  : 			waveInClose(control->hWaveIn);

  00252	ff 76 30	 push	 DWORD PTR [esi+48]
  00255	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveInClose@4

; 275  : //			PostThreadMessage(control->threadID, WIM_CLOSE, 0, 0);
; 276  : 			JabberLog(control->proto, "TlenVoiceStart FAILED #2!");

  0025b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@MAGB@TlenVoiceStart?5FAILED?5?$CD2?$CB?$AA@ ; `string'
  00260	ff 76 4c	 push	 DWORD PTR [esi+76]
  00263	e8 00 00 00 00	 call	 _JabberLog
  00268	59		 pop	 ecx
  00269	59		 pop	 ecx
$L84520:

; 277  : 			return 1;

  0026a	6a 01		 push	 1
  0026c	58		 pop	 eax
  0026d	eb de		 jmp	 SHORT $L83554
_TlenVoiceRecordingStart ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@OEMO@recording?5thread?5ended?4?4?4?$AA@ ; `string'
EXTRN	__imp__waveInUnprepareHeader@12:NEAR
EXTRN	__imp__GetMessageW@16:NEAR
;	COMDAT ??_C@_0BK@OEMO@recording?5thread?5ended?4?4?4?$AA@
; File E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\tlen_voice.c
_DATA	SEGMENT
??_C@_0BK@OEMO@recording?5thread?5ended?4?4?4?$AA@ DB 'recording thread e'
	DB	'nded...', 00H				; `string'
_DATA	ENDS
;	COMDAT _TlenVoiceRecordingThreadProc@4
_TEXT	SEGMENT
_control$ = 8
_msg$ = -28
_TlenVoiceRecordingThreadProc@4 PROC NEAR		; COMDAT

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 104  : 	MSG		msg;
; 105  : 	HWAVEIN hWaveIn;
; 106  : 	WAVEHDR *hWaveHdr;
; 107  : 	control->isRunning = 1;

  00008	8b 75 08	 mov	 esi, DWORD PTR _control$[ebp]
  0000b	57		 push	 edi

; 108  : 	control->stopThread = 0;

  0000c	83 66 38 00	 and	 DWORD PTR [esi+56], 0
  00010	c7 46 34 01 00
	00 00		 mov	 DWORD PTR [esi+52], 1
$L83501:

; 110  : 		GetMessage(&msg,NULL,0,0);

  00017	33 ff		 xor	 edi, edi
  00019	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  0001c	57		 push	 edi
  0001d	57		 push	 edi
  0001e	57		 push	 edi
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessageW@16

; 111  : 		if (msg.message == MM_WIM_DATA) {

  00026	81 7d e8 c0 03
	00 00		 cmp	 DWORD PTR _msg$[ebp+4], 960 ; 000003c0H
  0002d	75 63		 jne	 SHORT $L83504

; 112  : //			JabberLog("recording thread running...%d", msg.message);
; 113  : 			hWaveIn = (HWAVEIN) msg.wParam;
; 114  : 			hWaveHdr = (WAVEHDR *) msg.lParam;

  0002f	8b 7d f0	 mov	 edi, DWORD PTR _msg$[ebp+12]
  00032	8b 5d ec	 mov	 ebx, DWORD PTR _msg$[ebp+8]

; 115  : 			waveInUnprepareHeader(hWaveIn, hWaveHdr, sizeof(WAVEHDR));

  00035	6a 20		 push	 32			; 00000020H
  00037	57		 push	 edi
  00038	53		 push	 ebx
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveInUnprepareHeader@12

; 116  : 			if (hWaveHdr->dwBytesRecorded>0 && !control->bDisable) {

  0003f	83 7f 08 00	 cmp	 DWORD PTR [edi+8], 0
  00043	76 14		 jbe	 SHORT $L83508
  00045	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  00049	75 0e		 jne	 SHORT $L83508

; 117  : 				control->recordingData = (short *)hWaveHdr->lpData;

  0004b	8b 07		 mov	 eax, DWORD PTR [edi]

; 118  : 				TlenVoiceSendParse(control->ft);

  0004d	ff 76 40	 push	 DWORD PTR [esi+64]
  00050	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00053	e8 00 00 00 00	 call	 _TlenVoiceSendParse
  00058	59		 pop	 ecx
$L83508:

; 119  : 			}
; 120  : 			if (!control->stopThread) {

  00059	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  0005d	75 b8		 jne	 SHORT $L83501

; 121  : 				waveInPrepareHeader(hWaveIn, &control->waveHeaders[control->waveHeadersPos], sizeof(WAVEHDR));

  0005f	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00062	6a 20		 push	 32			; 00000020H
  00064	c1 e0 05	 shl	 eax, 5
  00067	03 46 14	 add	 eax, DWORD PTR [esi+20]
  0006a	50		 push	 eax
  0006b	53		 push	 ebx
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveInPrepareHeader@12

; 122  : 				waveInAddBuffer(hWaveIn, &control->waveHeaders[control->waveHeadersPos], sizeof(WAVEHDR));

  00072	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00075	6a 20		 push	 32			; 00000020H
  00077	c1 e0 05	 shl	 eax, 5
  0007a	03 46 14	 add	 eax, DWORD PTR [esi+20]
  0007d	50		 push	 eax
  0007e	53		 push	 ebx
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveInAddBuffer@12

; 123  : 				control->waveHeadersPos = (control->waveHeadersPos +1) % control->waveHeadersNum;

  00085	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00088	40		 inc	 eax
  00089	99		 cdq
  0008a	f7 7e 20	 idiv	 DWORD PTR [esi+32]
  0008d	89 56 1c	 mov	 DWORD PTR [esi+28], edx

; 124  : 			}
; 125  : 		}
; 126  : 		else if (msg.message == MM_WIM_CLOSE) {

  00090	eb 85		 jmp	 SHORT $L83501
$L83504:
  00092	81 7d e8 bf 03
	00 00		 cmp	 DWORD PTR _msg$[ebp+4], 959 ; 000003bfH

; 109  : 	while (TRUE) {

  00099	0f 85 78 ff ff
	ff		 jne	 $L83501

; 127  : 			break;
; 128  : 		}
; 129  : 	}
; 130  : 	control->isRunning = 0;
; 131  : 	JabberLog(control->proto, "recording thread ended...");

  0009f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@OEMO@recording?5thread?5ended?4?4?4?$AA@ ; `string'
  000a4	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  000a7	ff 76 4c	 push	 DWORD PTR [esi+76]
  000aa	e8 00 00 00 00	 call	 _JabberLog
  000af	59		 pop	 ecx

; 132  : 	return 0;

  000b0	33 c0		 xor	 eax, eax
  000b2	59		 pop	 ecx
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx

; 133  : }

  000b6	c9		 leave
  000b7	c2 04 00	 ret	 4
_TlenVoiceRecordingThreadProc@4 ENDP
_TEXT	ENDS
EXTRN	_gsm_create:NEAR
;	COMDAT _TlenVoiceCreateVC
_TEXT	SEGMENT
_proto$ = 8
_codec$ = 12
_TlenVoiceCreateVC PROC NEAR				; COMDAT

; 290  : {

  00000	56		 push	 esi

; 291  : 	TLEN_VOICE_CONTROL *vc;
; 292  : 	vc = (TLEN_VOICE_CONTROL *) mir_alloc(sizeof (TLEN_VOICE_CONTROL));

  00001	6a 50		 push	 80			; 00000050H
  00003	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  00009	8b f0		 mov	 esi, eax

; 293  : 	memset(vc, 0, sizeof(TLEN_VOICE_CONTROL));

  0000b	6a 50		 push	 80			; 00000050H
  0000d	6a 00		 push	 0
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memset
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 294  : 	vc->gsmstate = gsm_create();

  00018	e8 00 00 00 00	 call	 _gsm_create
  0001d	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 295  : 	vc->codec = codec;

  00020	8b 44 24 0c	 mov	 eax, DWORD PTR _codec$[esp]
  00024	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 296  :     vc->proto = proto;

  00027	8b 44 24 08	 mov	 eax, DWORD PTR _proto$[esp]
  0002b	89 46 4c	 mov	 DWORD PTR [esi+76], eax

; 297  : 	return vc;

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi

; 298  : }

  00031	c3		 ret	 0
_TlenVoiceCreateVC ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@GCEN@?9?$DO?5TlenVoiceFreeVc?$AA@	; `string'
PUBLIC	??_C@_0BD@HGIF@?$DM?9?5TlenVoiceFreeVc?$AA@	; `string'
EXTRN	__imp__waveOutClose@4:NEAR
EXTRN	__imp__waveOutUnprepareHeader@12:NEAR
EXTRN	__imp__Sleep@4:NEAR
EXTRN	_gsm_release:NEAR
;	COMDAT ??_C@_0BD@GCEN@?9?$DO?5TlenVoiceFreeVc?$AA@
; File E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\tlen_voice.c
_DATA	SEGMENT
??_C@_0BD@GCEN@?9?$DO?5TlenVoiceFreeVc?$AA@ DB '-> TlenVoiceFreeVc', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@HGIF@?$DM?9?5TlenVoiceFreeVc?$AA@
_DATA	SEGMENT
??_C@_0BD@HGIF@?$DM?9?5TlenVoiceFreeVc?$AA@ DB '<- TlenVoiceFreeVc', 00H ; `string'
_DATA	ENDS
;	COMDAT _TlenVoiceFreeVc
_TEXT	SEGMENT
_vc$ = 8
_i$ = 8
_TlenVoiceFreeVc PROC NEAR				; COMDAT

; 300  : {

  00000	55		 push	 ebp
  00001	56		 push	 esi

; 301  : 	int i;
; 302  : 	JabberLog(vc->proto, "-> TlenVoiceFreeVc");

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _vc$[esp+4]
  00006	57		 push	 edi
  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@GCEN@?9?$DO?5TlenVoiceFreeVc?$AA@ ; `string'
  0000c	ff 76 4c	 push	 DWORD PTR [esi+76]
  0000f	e8 00 00 00 00	 call	 _JabberLog
  00014	59		 pop	 ecx

; 303  : 	vc->stopThread = 1;
; 304  : 	PostThreadMessage(vc->threadID, MM_WIM_CLOSE, 0, 0);

  00015	33 ed		 xor	 ebp, ebp
  00017	59		 pop	 ecx
  00018	c7 46 38 01 00
	00 00		 mov	 DWORD PTR [esi+56], 1
  0001f	55		 push	 ebp
  00020	55		 push	 ebp
  00021	68 bf 03 00 00	 push	 959			; 000003bfH
  00026	ff 76 28	 push	 DWORD PTR [esi+40]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostThreadMessageW@16

; 305  : 	while(vc->isRunning) {

  0002f	39 6e 34	 cmp	 DWORD PTR [esi+52], ebp
  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__Sleep@4
  00038	74 09		 je	 SHORT $L83616
$L83615:

; 306  : 		Sleep(50);

  0003a	6a 32		 push	 50			; 00000032H
  0003c	ff d7		 call	 edi
  0003e	39 6e 34	 cmp	 DWORD PTR [esi+52], ebp
  00041	75 f7		 jne	 SHORT $L83615
$L83616:

; 307  : 	}
; 308  : 	if (vc->hThread!=NULL) CloseHandle(vc->hThread);

  00043	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00046	3b c5		 cmp	 eax, ebp
  00048	74 07		 je	 SHORT $L83618
  0004a	50		 push	 eax
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$L83618:

; 309  : 	if (vc->hWaveIn) {

  00051	39 6e 30	 cmp	 DWORD PTR [esi+48], ebp
  00054	53		 push	 ebx
  00055	74 52		 je	 SHORT $L83629

; 310  : 		for (i=0;i<vc->waveHeadersNum;i++) {

  00057	39 6e 20	 cmp	 DWORD PTR [esi+32], ebp
  0005a	89 6c 24 14	 mov	 DWORD PTR _i$[esp+12], ebp
  0005e	7e 30		 jle	 SHORT $L84532
  00060	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__waveInUnprepareHeader@12
$L84546:
  00066	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 311  : 			while(waveInUnprepareHeader(vc->hWaveIn, &vc->waveHeaders[i], sizeof(WAVEHDR)) == WAVERR_STILLPLAYING) {

  00069	6a 20		 push	 32			; 00000020H
  0006b	03 c5		 add	 eax, ebp
  0006d	50		 push	 eax
  0006e	ff 76 30	 push	 DWORD PTR [esi+48]
  00071	ff d3		 call	 ebx
  00073	83 f8 21	 cmp	 eax, 33			; 00000021H
  00076	75 06		 jne	 SHORT $L83621

; 312  : 				Sleep(50);

  00078	6a 32		 push	 50			; 00000032H
  0007a	ff d7		 call	 edi
  0007c	eb e8		 jmp	 SHORT $L84546
$L83621:

; 310  : 		for (i=0;i<vc->waveHeadersNum;i++) {

  0007e	ff 44 24 14	 inc	 DWORD PTR _i$[esp+12]
  00082	83 c5 20	 add	 ebp, 32			; 00000020H
  00085	8b 44 24 14	 mov	 eax, DWORD PTR _i$[esp+12]
  00089	3b 46 20	 cmp	 eax, DWORD PTR [esi+32]
  0008c	7c d8		 jl	 SHORT $L84546
  0008e	33 ed		 xor	 ebp, ebp
$L84532:

; 313  : 			}
; 314  : 		}
; 315  : 		while(waveInClose(vc->hWaveIn) == WAVERR_STILLPLAYING) {

  00090	ff 76 30	 push	 DWORD PTR [esi+48]
  00093	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__waveInClose@4
$L84547:
  00099	ff d3		 call	 ebx
  0009b	83 f8 21	 cmp	 eax, 33			; 00000021H
  0009e	75 09		 jne	 SHORT $L83629

; 316  : 			Sleep(50);

  000a0	6a 32		 push	 50			; 00000032H
  000a2	ff d7		 call	 edi
  000a4	ff 76 30	 push	 DWORD PTR [esi+48]
  000a7	eb f0		 jmp	 SHORT $L84547
$L83629:

; 317  : 		}
; 318  : 	}
; 319  : 	if (vc->hWaveOut) {

  000a9	39 6e 2c	 cmp	 DWORD PTR [esi+44], ebp
  000ac	74 52		 je	 SHORT $L83640

; 320  : 		for (i=0;i<vc->waveHeadersNum;i++) {

  000ae	39 6e 20	 cmp	 DWORD PTR [esi+32], ebp
  000b1	89 6c 24 14	 mov	 DWORD PTR _i$[esp+12], ebp
  000b5	7e 30		 jle	 SHORT $L84535
  000b7	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__waveOutUnprepareHeader@12
$L84548:
  000bd	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 321  : 			while(waveOutUnprepareHeader(vc->hWaveOut, &vc->waveHeaders[i], sizeof(WAVEHDR)) == WAVERR_STILLPLAYING) {

  000c0	6a 20		 push	 32			; 00000020H
  000c2	03 c5		 add	 eax, ebp
  000c4	50		 push	 eax
  000c5	ff 76 2c	 push	 DWORD PTR [esi+44]
  000c8	ff d3		 call	 ebx
  000ca	83 f8 21	 cmp	 eax, 33			; 00000021H
  000cd	75 06		 jne	 SHORT $L83632

; 322  : 				Sleep(50);

  000cf	6a 32		 push	 50			; 00000032H
  000d1	ff d7		 call	 edi
  000d3	eb e8		 jmp	 SHORT $L84548
$L83632:

; 320  : 		for (i=0;i<vc->waveHeadersNum;i++) {

  000d5	ff 44 24 14	 inc	 DWORD PTR _i$[esp+12]
  000d9	83 c5 20	 add	 ebp, 32			; 00000020H
  000dc	8b 44 24 14	 mov	 eax, DWORD PTR _i$[esp+12]
  000e0	3b 46 20	 cmp	 eax, DWORD PTR [esi+32]
  000e3	7c d8		 jl	 SHORT $L84548
  000e5	33 ed		 xor	 ebp, ebp
$L84535:

; 323  : 			}
; 324  : 		}
; 325  : 		while(waveOutClose(vc->hWaveOut) == WAVERR_STILLPLAYING) {

  000e7	ff 76 2c	 push	 DWORD PTR [esi+44]
  000ea	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__waveOutClose@4
$L84549:
  000f0	ff d3		 call	 ebx
  000f2	83 f8 21	 cmp	 eax, 33			; 00000021H
  000f5	75 09		 jne	 SHORT $L83640

; 326  : 			Sleep(50);

  000f7	6a 32		 push	 50			; 00000032H
  000f9	ff d7		 call	 edi
  000fb	ff 76 2c	 push	 DWORD PTR [esi+44]
  000fe	eb f0		 jmp	 SHORT $L84549
$L83640:

; 327  : 		}
; 328  : 	}
; 329  : 	if (vc->waveData) mir_free(vc->waveData);

  00100	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00103	5b		 pop	 ebx
  00104	3b c5		 cmp	 eax, ebp
  00106	74 08		 je	 SHORT $L83641
  00108	50		 push	 eax
  00109	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  0010f	59		 pop	 ecx
$L83641:

; 330  : 	if (vc->waveHeaders) mir_free(vc->waveHeaders);

  00110	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00113	3b c5		 cmp	 eax, ebp
  00115	74 08		 je	 SHORT $L83642
  00117	50		 push	 eax
  00118	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  0011e	59		 pop	 ecx
$L83642:

; 331  : 	if (vc->gsmstate) gsm_release(vc->gsmstate);

  0011f	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00122	3b c5		 cmp	 eax, ebp
  00124	74 07		 je	 SHORT $L83643
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 _gsm_release
  0012c	59		 pop	 ecx
$L83643:

; 332  : 	JabberLog(vc->proto, "<- TlenVoiceFreeVc");

  0012d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@HGIF@?$DM?9?5TlenVoiceFreeVc?$AA@ ; `string'
  00132	ff 76 4c	 push	 DWORD PTR [esi+76]
  00135	e8 00 00 00 00	 call	 _JabberLog

; 333  : 	mir_free(vc);

  0013a	56		 push	 esi
  0013b	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00141	83 c4 0c	 add	 esp, 12			; 0000000cH
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5d		 pop	 ebp

; 334  : }

  00147	c3		 ret	 0
_TlenVoiceFreeVc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@NHEE@Set?5ft?9?$DOs?5to?5?$CFd?5?$CIsaving?5?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0EG@JOAE@Entering?5send?5loop?5for?5this?5file@ ; `string'
PUBLIC	??_C@_0EC@KHJJ@Closing?5connection?5for?5this?5file@ ; `string'
PUBLIC	??_C@_0BI@CBPP@ft?9?$DOs?5is?5restored?5to?5?$CFd?$AA@ ; `string'
EXTRN	__imp__SetEvent@4:NEAR
EXTRN	_TlenP2PEstablishIncomingConnection:NEAR
;	COMDAT ??_C@_0BM@NHEE@Set?5ft?9?$DOs?5to?5?$CFd?5?$CIsaving?5?$CFd?$CJ?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_netlib.h
_DATA	SEGMENT
??_C@_0BM@NHEE@Set?5ft?9?$DOs?5to?5?$CFd?5?$CIsaving?5?$CFd?$CJ?$AA@ DB 'S'
	DB	'et ft->s to %d (saving %d)', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EG@JOAE@Entering?5send?5loop?5for?5this?5file@
_DATA	SEGMENT
??_C@_0EG@JOAE@Entering?5send?5loop?5for?5this?5file@ DB 'Entering send l'
	DB	'oop for this file connection... (ft->s is hConnection)', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EC@KHJJ@Closing?5connection?5for?5this?5file@
_DATA	SEGMENT
??_C@_0EC@KHJJ@Closing?5connection?5for?5this?5file@ DB 'Closing connecti'
	DB	'on for this file transfer... (ft->s is now hBind)', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@CBPP@ft?9?$DOs?5is?5restored?5to?5?$CFd?$AA@
_DATA	SEGMENT
??_C@_0BI@CBPP@ft?9?$DOs?5is?5restored?5to?5?$CFd?$AA@ DB 'ft->s is resto'
	DB	'red to %d', 00H				; `string'
_DATA	ENDS
;	COMDAT _TlenVoiceReceivingConnection
_TEXT	SEGMENT
_hConnection$ = 8
_pExtra$ = 16
_TlenVoiceReceivingConnection PROC NEAR			; COMDAT

; 427  : {

  00000	53		 push	 ebx

; 428  : 	JABBER_SOCKET slisten;
; 429  : 	TLEN_FILE_TRANSFER *ft;
; 430  : 	TlenProtocol *proto = (TlenProtocol *)pExtra;
; 431  : 
; 432  : 	ft = TlenP2PEstablishIncomingConnection(proto, hConnection, LIST_VOICE, FALSE);

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _hConnection$[esp]
  00005	56		 push	 esi
  00006	6a 00		 push	 0
  00008	6a 05		 push	 5
  0000a	53		 push	 ebx
  0000b	ff 74 24 20	 push	 DWORD PTR _pExtra$[esp+16]
  0000f	e8 00 00 00 00	 call	 _TlenP2PEstablishIncomingConnection
  00014	8b f0		 mov	 esi, eax
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 433  : 	if (ft != NULL) {

  00019	85 f6		 test	 esi, esi
  0001b	0f 84 e2 00 00
	00		 je	 $L83722
  00021	57		 push	 edi

; 434  : 		slisten = ft->s;

  00022	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 435  : 		ft->s = hConnection;
; 436  : 		JabberLog(ft->proto, "Set ft->s to %d (saving %d)", hConnection, slisten);

  00025	57		 push	 edi
  00026	53		 push	 ebx
  00027	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@NHEE@Set?5ft?9?$DOs?5to?5?$CFd?5?$CIsaving?5?$CFd?$CJ?$AA@ ; `string'
  0002c	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0002f	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  00035	e8 00 00 00 00	 call	 _JabberLog

; 437  : 		JabberLog(ft->proto, "Entering send loop for this file connection... (ft->s is hConnection)");

  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EG@JOAE@Entering?5send?5loop?5for?5this?5file@ ; `string'
  0003f	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  00045	e8 00 00 00 00	 call	 _JabberLog

; 438  : 		playbackControl = NULL;

  0004a	83 25 00 00 00
	00 00		 and	 DWORD PTR _playbackControl, 0

; 439  : 		recordingControl = TlenVoiceCreateVC(proto, 3);

  00051	6a 03		 push	 3
  00053	ff 74 24 34	 push	 DWORD PTR _pExtra$[esp+36]
  00057	e8 00 00 00 00	 call	 _TlenVoiceCreateVC
  0005c	a3 00 00 00 00	 mov	 DWORD PTR _recordingControl, eax

; 440  : 		recordingControl->ft = ft;

  00061	89 70 40	 mov	 DWORD PTR [eax+64], esi

; 441  : 		TlenVoiceRecordingStart(recordingControl);

  00064	ff 35 00 00 00
	00		 push	 DWORD PTR _recordingControl
  0006a	e8 00 00 00 00	 call	 _TlenVoiceRecordingStart
  0006f	83 c4 24	 add	 esp, 36			; 00000024H
$L84557:

; 442  : 		while (ft->state!=FT_DONE && ft->state!=FT_ERROR) {

  00072	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00075	83 f8 03	 cmp	 eax, 3
  00078	74 0e		 je	 SHORT $L83728
  0007a	83 f8 04	 cmp	 eax, 4
  0007d	74 09		 je	 SHORT $L83728

; 443  : 			TlenVoiceReceiveParse(ft);

  0007f	56		 push	 esi
  00080	e8 00 00 00 00	 call	 _TlenVoiceReceiveParse
  00085	59		 pop	 ecx
  00086	eb ea		 jmp	 SHORT $L84557
$L83728:

; 444  : 		}
; 445  : 		TlenVoiceFreeVc(recordingControl);

  00088	ff 35 00 00 00
	00		 push	 DWORD PTR _recordingControl
  0008e	e8 00 00 00 00	 call	 _TlenVoiceFreeVc

; 446  : 		playbackControl = NULL;

  00093	83 25 00 00 00
	00 00		 and	 DWORD PTR _playbackControl, 0

; 447  : 		recordingControl = NULL;

  0009a	83 25 00 00 00
	00 00		 and	 DWORD PTR _recordingControl, 0

; 448  : 		if (ft->state==FT_DONE) {

  000a1	83 7e 0c 03	 cmp	 DWORD PTR [esi+12], 3
  000a5	59		 pop	 ecx
  000a6	75 07		 jne	 SHORT $L83731

; 449  : 			SetDlgItemText(voiceDlgHWND, IDC_STATUS, TranslateT("...Finished..."));

  000a8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BO@LFEK@?$AA?4?$AA?4?$AA?4?$AAF?$AAi?$AAn?$AAi?$AAs?$AAh?$AAe?$AAd?$AA?4?$AA?4?$AA?4?$AA?$AA@ ; `string'

; 450  : //			ProtoBroadcastAck(iface.m_szModuleName, ft->hContact, ACKTYPE_FILE, ACKRESULT_SUCCESS, ft, 0);
; 451  : 		} else {

  000ad	eb 05		 jmp	 SHORT $L84558
$L83731:

; 452  : //			ProtoBroadcastAck(iface.m_szModuleName, ft->hContact, ACKTYPE_FILE, ACKRESULT_FAILED, ft, 0);
; 453  : 			SetDlgItemText(voiceDlgHWND, IDC_STATUS, TranslateT("...Error..."));

  000af	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@LPHK@?$AA?4?$AA?4?$AA?4?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?4?$AA?4?$AA?4?$AA?$AA@ ; `string'
$L84558:
  000b4	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  000b9	68 00 10 00 00	 push	 4096			; 00001000H
  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@MKNL@LangPack?1TranslateString?$AA@ ; `string'
  000c3	ff 50 24	 call	 DWORD PTR [eax+36]
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	50		 push	 eax
  000ca	68 86 05 00 00	 push	 1414			; 00000586H
  000cf	ff 35 00 00 00
	00		 push	 DWORD PTR _voiceDlgHWND
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemTextW@12

; 454  : 		}
; 455  : 		JabberLog(ft->proto, "Closing connection for this file transfer... (ft->s is now hBind)");

  000db	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EC@KHJJ@Closing?5connection?5for?5this?5file@ ; `string'
  000e0	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  000e6	e8 00 00 00 00	 call	 _JabberLog

; 456  : 		ft->s = slisten;
; 457  : 		JabberLog(ft->proto, "ft->s is restored to %d", ft->s);

  000eb	57		 push	 edi
  000ec	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@CBPP@ft?9?$DOs?5is?5restored?5to?5?$CFd?$AA@ ; `string'
  000f1	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  000f7	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  000fa	e8 00 00 00 00	 call	 _JabberLog
  000ff	83 c4 14	 add	 esp, 20			; 00000014H
  00102	5f		 pop	 edi
$L83722:

; 458  : 	}
; 459  : 	Netlib_CloseHandle(hConnection);

  00103	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00108	6a 00		 push	 0
  0010a	53		 push	 ebx
  0010b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@ ; `string'
  00110	ff 50 24	 call	 DWORD PTR [eax+36]
  00113	83 c4 0c	 add	 esp, 12			; 0000000cH

; 460  : 	if (ft!=NULL && ft->hFileEvent != NULL)

  00116	85 f6		 test	 esi, esi
  00118	74 0e		 je	 SHORT $L83741
  0011a	8b 76 3c	 mov	 esi, DWORD PTR [esi+60]
  0011d	85 f6		 test	 esi, esi
  0011f	74 07		 je	 SHORT $L83741

; 461  : 		SetEvent(ft->hFileEvent);

  00121	56		 push	 esi
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$L83741:
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx

; 462  : }

  0012a	c3		 ret	 0
_TlenVoiceReceivingConnection ENDP
_TEXT	ENDS
PUBLIC	__real@8@40018000000000000000
PUBLIC	__real@8@40009666666666666800
PUBLIC	??_C@_0BB@NMB@?5Unknown?5packet?5?$AA@		; `string'
PUBLIC	??_C@_04HHNC@?5OK?5?$AA@			; `string'
PUBLIC	??_C@_0BA@FDGN@?5Unknown?5codec?5?$AA@		; `string'
PUBLIC	??_C@_0BF@EBIO@?$CB?$CB?5Skipping?5frame?5?$CB?$CB?$AA@ ; `string'
PUBLIC	??_C@_09HLBN@?$CFs?5?$CFd?5?$CFd?5?$AA@		; `string'
EXTRN	__imp__waveOutPrepareHeader@12:NEAR
EXTRN	__imp__waveOutWrite@12:NEAR
EXTRN	__imp__SleepEx@8:NEAR
EXTRN	_log10:NEAR
EXTRN	__imp__SetDlgItemTextA@12:NEAR
EXTRN	_gsm_decode:NEAR
EXTRN	_TlenP2PPacketFree:NEAR
EXTRN	_TlenP2PPacketReceive:NEAR
EXTRN	__imp__sprintf:NEAR
EXTRN	__ftol:NEAR
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_0BB@NMB@?5Unknown?5packet?5?$AA@
; File E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\tlen_voice.c
_DATA	SEGMENT
??_C@_0BB@NMB@?5Unknown?5packet?5?$AA@ DB ' Unknown packet ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04HHNC@?5OK?5?$AA@
_DATA	SEGMENT
??_C@_04HHNC@?5OK?5?$AA@ DB ' OK ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FDGN@?5Unknown?5codec?5?$AA@
_DATA	SEGMENT
??_C@_0BA@FDGN@?5Unknown?5codec?5?$AA@ DB ' Unknown codec ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@EBIO@?$CB?$CB?5Skipping?5frame?5?$CB?$CB?$AA@
_DATA	SEGMENT
??_C@_0BF@EBIO@?$CB?$CB?5Skipping?5frame?5?$CB?$CB?$AA@ DB '!! Skipping f'
	DB	'rame !!', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_09HLBN@?$CFs?5?$CFd?5?$CFd?5?$AA@
_DATA	SEGMENT
??_C@_09HLBN@?$CFs?5?$CFd?5?$CFd?5?$AA@ DB '%s %d %d ', 00H ; `string'
_DATA	ENDS
;	COMDAT __real@8@40018000000000000000
CONST	SEGMENT
__real@8@40018000000000000000 DQ 04010000000000000r ; 4
CONST	ENDS
;	COMDAT __real@8@40009666666666666800
CONST	SEGMENT
__real@8@40009666666666666800 DQ 04002cccccccccccdr ; 2.35
CONST	ENDS
;	COMDAT _TlenVoiceReceiveParse
_TEXT	SEGMENT
_ft$ = 8
_statusTxt$ = 8
_i$ = -4
_out$83755 = -12
_ttt$83795 = -2060
_TlenVoiceReceiveParse PROC NEAR			; COMDAT

; 465  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 08 00
	00		 sub	 esp, 2060		; 0000080cH
  00009	53		 push	 ebx
  0000a	57		 push	 edi

; 466  : 	char *statusTxt;
; 467  : 	int i, j;
; 468  : 	char *p;
; 469  : 	float val;
; 470  : 	TLEN_FILE_PACKET  *packet;
; 471  : 	packet = TlenP2PPacketReceive(ft->s);

  0000b	8b 7d 08	 mov	 edi, DWORD PTR _ft$[ebp]
  0000e	ff 77 04	 push	 DWORD PTR [edi+4]
  00011	e8 00 00 00 00	 call	 _TlenP2PPacketReceive
  00016	8b d8		 mov	 ebx, eax
  00018	59		 pop	 ecx

; 472  : 	if (packet != NULL) {

  00019	85 db		 test	 ebx, ebx
  0001b	0f 84 f6 02 00
	00		 je	 $L83752

; 473  : 		statusTxt = " Unknown packet ";
; 474  : 		p = packet->packet;
; 475  : 		if (packet->type == TLEN_VOICE_PACKET) {

  00021	81 7b 08 96 00
	00 00		 cmp	 DWORD PTR [ebx+8], 150	; 00000096H
  00028	56		 push	 esi
  00029	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _statusTxt$[ebp], OFFSET FLAT:??_C@_0BB@NMB@?5Unknown?5packet?5?$AA@ ; `string'
  00030	0f 85 9b 02 00
	00		 jne	 $L83793

; 476  : 			short *out;
; 477  : 			int codec, chunkNum;
; 478  : 			statusTxt = " OK ";
; 479  : 			TlenVoiceCrypt(packet->packet+4, packet->len-4);

  00036	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00039	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _statusTxt$[ebp], OFFSET FLAT:??_C@_04HHNC@?5OK?5?$AA@ ; `string'
  00040	83 e8 04	 sub	 eax, 4
  00043	50		 push	 eax
  00044	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00047	83 c0 04	 add	 eax, 4
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _TlenVoiceCrypt

; 480  : 			codec = *((int *)packet->packet);

  00050	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00053	59		 pop	 ecx
  00054	59		 pop	 ecx
  00055	8b 30		 mov	 esi, DWORD PTR [eax]

; 481  : 			if (codec<2 || codec>5) {

  00057	83 fe 02	 cmp	 esi, 2
  0005a	0f 8c 6a 02 00
	00		 jl	 $L83761
  00060	83 fe 05	 cmp	 esi, 5
  00063	0f 8f 61 02 00
	00		 jg	 $L83761

; 483  : 			} else {
; 484  : 				if (playbackControl == NULL) {

  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR _playbackControl
  0006e	85 c0		 test	 eax, eax
  00070	75 1c		 jne	 SHORT $L83765

; 485  : 					playbackControl = TlenVoiceCreateVC(ft->proto, codec);

  00072	56		 push	 esi
  00073	ff b7 7c 02 00
	00		 push	 DWORD PTR [edi+636]
  00079	e8 00 00 00 00	 call	 _TlenVoiceCreateVC

; 486  : 					TlenVoicePlaybackStart(playbackControl);

  0007e	50		 push	 eax
  0007f	a3 00 00 00 00	 mov	 DWORD PTR _playbackControl, eax
  00084	e8 00 00 00 00	 call	 _TlenVoicePlaybackStart
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH

; 487  : 					availPlayback = 0;
; 488  : 					availOverrun = 0;
; 489  : 					availLimit = availLimitMax;
; 490  : 				} else if (playbackControl->codec != codec) {

  0008c	eb 25		 jmp	 SHORT $L84581
$L83765:
  0008e	39 70 04	 cmp	 DWORD PTR [eax+4], esi
  00091	74 3d		 je	 SHORT $L83767

; 491  : 					TlenVoiceFreeVc(playbackControl);

  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _TlenVoiceFreeVc

; 492  : 					playbackControl = TlenVoiceCreateVC(ft->proto, codec);

  00099	56		 push	 esi
  0009a	ff b7 7c 02 00
	00		 push	 DWORD PTR [edi+636]
  000a0	e8 00 00 00 00	 call	 _TlenVoiceCreateVC

; 493  : 					TlenVoicePlaybackStart(playbackControl);

  000a5	50		 push	 eax
  000a6	a3 00 00 00 00	 mov	 DWORD PTR _playbackControl, eax
  000ab	e8 00 00 00 00	 call	 _TlenVoicePlaybackStart
  000b0	83 c4 10	 add	 esp, 16			; 00000010H
$L84581:

; 494  : 					availPlayback = 0;
; 495  : 					availOverrun = 0;
; 496  : 					availLimit = availLimitMax;

  000b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _availLimitMax
  000b8	83 25 00 00 00
	00 00		 and	 DWORD PTR _availPlayback, 0
  000bf	83 25 00 00 00
	00 00		 and	 DWORD PTR _availOverrun, 0
  000c6	a3 00 00 00 00	 mov	 DWORD PTR _availLimit, eax
  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR _playbackControl
$L83767:

; 497  : 				}
; 498  : 				if (!playbackControl->bDisable) {

  000d0	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000d4	0f 85 f7 01 00
	00		 jne	 $L83793

; 499  : 					playbackControl->waveHeaders[playbackControl->waveHeadersPos].dwFlags =  WHDR_DONE;

  000da	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000dd	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  000e0	c1 e1 05	 shl	 ecx, 5

; 500  : 					playbackControl->waveHeaders[playbackControl->waveHeadersPos].lpData = (char *) (playbackControl->waveData + playbackControl->waveHeadersPos * playbackControl->waveFrameSize);
; 501  : 					playbackControl->waveHeaders[playbackControl->waveHeadersPos].dwBufferLength = playbackControl->waveFrameSize * 2;
; 502  : 						/*
; 503  : 					if (availPlayback == 0) {
; 504  : 						statusTxt = "!! Buffer is empty !!";
; 505  : 						availPlayback++;
; 506  : 						waveOutPrepareHeader(playbackControl->hWaveOut, &playbackControl->waveHeaders[playbackControl->waveHeadersPos], sizeof(WAVEHDR));
; 507  : 						waveOutWrite(playbackControl->hWaveOut, &playbackControl->waveHeaders[playbackControl->waveHeadersPos], sizeof(WAVEHDR));
; 508  : 						playbackControl->waveHeadersPos = (playbackControl->waveHeadersPos +1) % playbackControl->waveHeadersNum;
; 509  : 						playbackControl->waveHeaders[playbackControl->waveHeadersPos].dwFlags =  WHDR_DONE;
; 510  : 						playbackControl->waveHeaders[playbackControl->waveHeadersPos].lpData = (char *) (playbackControl->waveData + playbackControl->waveHeadersPos * playbackControl->waveFrameSize);
; 511  : 						playbackControl->waveHeaders[playbackControl->waveHeadersPos].dwBufferLength = playbackControl->waveFrameSize * 2;
; 512  : 					}
; 513  : 						*/
; 514  : 					chunkNum = min(modeFrameSize[codec], (int)(packet->len - 4) / 33);

  000e3	6a 21		 push	 33			; 00000021H
  000e5	8d 34 b5 00 00
	00 00		 lea	 esi, DWORD PTR _modeFrameSize[esi*4]
  000ec	c7 44 01 10 01
	00 00 00	 mov	 DWORD PTR [ecx+eax+16], 1
  000f4	a1 00 00 00 00	 mov	 eax, DWORD PTR _playbackControl
  000f9	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000fc	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000ff	0f af d1	 imul	 edx, ecx
  00102	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  00105	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00108	c1 e1 05	 shl	 ecx, 5
  0010b	8d 14 57	 lea	 edx, DWORD PTR [edi+edx*2]
  0010e	89 14 01	 mov	 DWORD PTR [ecx+eax], edx
  00111	a1 00 00 00 00	 mov	 eax, DWORD PTR _playbackControl
  00116	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00119	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0011c	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0011f	c1 e2 05	 shl	 edx, 5
  00122	d1 e1		 shl	 ecx, 1
  00124	89 4c 02 04	 mov	 DWORD PTR [edx+eax+4], ecx
  00128	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0012b	83 e8 04	 sub	 eax, 4
  0012e	59		 pop	 ecx
  0012f	99		 cdq
  00130	f7 f9		 idiv	 ecx
  00132	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00134	3b c8		 cmp	 ecx, eax
  00136	7c 02		 jl	 SHORT $L84562
  00138	8b c8		 mov	 ecx, eax
$L84562:

; 515  : 					out = (short *)playbackControl->waveHeaders[playbackControl->waveHeadersPos].lpData;

  0013a	a1 00 00 00 00	 mov	 eax, DWORD PTR _playbackControl
  0013f	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00142	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
  00145	c1 e2 05	 shl	 edx, 5

; 516  : 					for (i=0; i<chunkNum; i++) {

  00148	85 c9		 test	 ecx, ecx
  0014a	8b 14 3a	 mov	 edx, DWORD PTR [edx+edi]
  0014d	89 55 f4	 mov	 DWORD PTR _out$83755[ebp], edx
  00150	7e 53		 jle	 SHORT $L83775
  00152	83 65 fc 00	 and	 DWORD PTR -4+[ebp], 0
  00156	89 4d f8	 mov	 DWORD PTR -8+[ebp], ecx
$L83773:

; 517  : 						for (j=0;j<33;j++) {

  00159	33 c9		 xor	 ecx, ecx
  0015b	eb 05		 jmp	 SHORT $L83776
$L84578:
  0015d	a1 00 00 00 00	 mov	 eax, DWORD PTR _playbackControl
$L83776:

; 518  : 							playbackControl->gsmstate->gsmFrame[j] = packet->packet[i*33 +j +4];

  00162	8b 55 fc	 mov	 edx, DWORD PTR -4+[ebp]
  00165	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00168	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  0016b	03 d1		 add	 edx, ecx
  0016d	41		 inc	 ecx
  0016e	8a 54 3a 04	 mov	 dl, BYTE PTR [edx+edi+4]
  00172	83 f9 21	 cmp	 ecx, 33			; 00000021H
  00175	88 94 08 7f 06
	00 00		 mov	 BYTE PTR [eax+ecx+1663], dl
  0017c	7c df		 jl	 SHORT $L84578

; 519  : 						}
; 520  : 						gsm_decode(playbackControl->gsmstate, out);

  0017e	ff 75 f4	 push	 DWORD PTR _out$83755[ebp]
  00181	a1 00 00 00 00	 mov	 eax, DWORD PTR _playbackControl
  00186	ff 70 3c	 push	 DWORD PTR [eax+60]
  00189	e8 00 00 00 00	 call	 _gsm_decode

; 521  : 						out += 160;

  0018e	81 45 f4 40 01
	00 00		 add	 DWORD PTR _out$83755[ebp], 320 ; 00000140H
  00195	83 45 fc 21	 add	 DWORD PTR -4+[ebp], 33	; 00000021H
  00199	ff 4d f8	 dec	 DWORD PTR -8+[ebp]
  0019c	a1 00 00 00 00	 mov	 eax, DWORD PTR _playbackControl
  001a1	59		 pop	 ecx
  001a2	59		 pop	 ecx
  001a3	75 b4		 jne	 SHORT $L83773
$L83775:

; 522  : 					}
; 523  : 					out = (short *)playbackControl->waveHeaders[playbackControl->waveHeadersPos].lpData;

  001a5	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  001a8	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  001ab	c1 e1 05	 shl	 ecx, 5

; 524  : 					val = 0;
; 525  : 					for (i=0; i<modeFrameSize[codec] * 160; i+=modeFrameSize[codec]) {

  001ae	83 65 fc 00	 and	 DWORD PTR _i$[ebp], 0
  001b2	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  001b5	8b 06		 mov	 eax, DWORD PTR [esi]
  001b7	d9 ee		 fldz
  001b9	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  001bc	c1 e1 05	 shl	 ecx, 5
  001bf	85 c9		 test	 ecx, ecx
  001c1	7e 1d		 jle	 SHORT $L83782

; 522  : 					}
; 523  : 					out = (short *)playbackControl->waveHeaders[playbackControl->waveHeadersPos].lpData;

  001c3	8b f2		 mov	 esi, edx
$L83780:

; 526  : 						val += out[i]*out[i];

  001c5	0f bf 16	 movsx	 edx, WORD PTR [esi]
  001c8	8b fa		 mov	 edi, edx
  001ca	01 45 fc	 add	 DWORD PTR _i$[ebp], eax
  001cd	0f af fa	 imul	 edi, edx
  001d0	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]
  001d3	89 7d f8	 mov	 DWORD PTR -8+[ebp], edi
  001d6	da 45 f8	 fiadd	 DWORD PTR -8+[ebp]
  001d9	03 f2		 add	 esi, edx
  001db	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  001de	7c e5		 jl	 SHORT $L83780
$L83782:

; 527  : 					}
; 528  : 					j = (int)((log10(val) - 4) * 2.35);

  001e0	51		 push	 ecx
  001e1	51		 push	 ecx
  001e2	dd 1c 24	 fstp	 QWORD PTR [esp]
  001e5	e8 00 00 00 00	 call	 _log10
  001ea	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@8@40018000000000000000
  001f0	59		 pop	 ecx
  001f1	59		 pop	 ecx
  001f2	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@8@40009666666666666800
  001f8	e8 00 00 00 00	 call	 __ftol

; 529  : 					if (j > vuMeterLevels - 1 ) {

  001fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _vuMeterLevels
  00203	49		 dec	 ecx
  00204	3b c1		 cmp	 eax, ecx
  00206	7e 04		 jle	 SHORT $L83784

; 530  : 						j = vuMeterLevels - 1;

  00208	8b c1		 mov	 eax, ecx

; 531  : 					} else if (j<0) {

  0020a	eb 06		 jmp	 SHORT $L83786
$L83784:
  0020c	85 c0		 test	 eax, eax
  0020e	7d 02		 jge	 SHORT $L83786

; 532  : 						j = 0;

  00210	33 c0		 xor	 eax, eax
$L83786:

; 533  : 					}
; 534  : 					playbackControl->vuMeter = j;

  00212	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _playbackControl
  00218	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 535  : 					playbackControl->bytesSum  += 8 + packet->len;

  0021b	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0021e	a1 00 00 00 00	 mov	 eax, DWORD PTR _playbackControl
  00223	83 c1 08	 add	 ecx, 8
  00226	01 48 48	 add	 DWORD PTR [eax+72], ecx

; 536  : 					/* Simple logic to avoid huge delays. If a delay is detected a frame is not played */
; 537  : 					j = availOverrun > 0 ? -1 : 0;

  00229	33 c0		 xor	 eax, eax
  0022b	39 05 00 00 00
	00		 cmp	 DWORD PTR _availOverrun, eax
  00231	0f 9e c0	 setle	 al
  00234	48		 dec	 eax
  00235	8b f0		 mov	 esi, eax

; 538  : 					while (availPlayback > availLimitMin) {

  00237	a1 00 00 00 00	 mov	 eax, DWORD PTR _availPlayback
  0023c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _availLimitMin
  00242	7e 1a		 jle	 SHORT $L83789

; 539  : 						j = 1;

  00244	6a 01		 push	 1
  00246	5e		 pop	 esi
$L83788:

; 540  : 						SleepEx(5, FALSE);

  00247	6a 00		 push	 0
  00249	6a 05		 push	 5
  0024b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SleepEx@8
  00251	a1 00 00 00 00	 mov	 eax, DWORD PTR _availPlayback
  00256	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _availLimitMin
  0025c	7f e9		 jg	 SHORT $L83788
$L83789:

; 541  : 					}
; 542  : 					availOverrun += j;

  0025e	01 35 00 00 00
	00		 add	 DWORD PTR _availOverrun, esi

; 543  : 					/* 40 frames - 800ms/8kHz */
; 544  : 					if (availOverrun < 40) {

  00264	83 3d 00 00 00
	00 28		 cmp	 DWORD PTR _availOverrun, 40 ; 00000028H
  0026b	7d 4d		 jge	 SHORT $L83790

; 545  : 						availPlayback++;
; 546  : 						waveOutPrepareHeader(playbackControl->hWaveOut, &playbackControl->waveHeaders[playbackControl->waveHeadersPos], sizeof(WAVEHDR));

  0026d	a1 00 00 00 00	 mov	 eax, DWORD PTR _playbackControl
  00272	ff 05 00 00 00
	00		 inc	 DWORD PTR _availPlayback
  00278	6a 20		 push	 32			; 00000020H
  0027a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0027d	c1 e1 05	 shl	 ecx, 5
  00280	03 48 14	 add	 ecx, DWORD PTR [eax+20]
  00283	51		 push	 ecx
  00284	ff 70 2c	 push	 DWORD PTR [eax+44]
  00287	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutPrepareHeader@12

; 547  : 						waveOutWrite(playbackControl->hWaveOut, &playbackControl->waveHeaders[playbackControl->waveHeadersPos], sizeof(WAVEHDR));

  0028d	a1 00 00 00 00	 mov	 eax, DWORD PTR _playbackControl
  00292	6a 20		 push	 32			; 00000020H
  00294	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00297	c1 e1 05	 shl	 ecx, 5
  0029a	03 48 14	 add	 ecx, DWORD PTR [eax+20]
  0029d	51		 push	 ecx
  0029e	ff 70 2c	 push	 DWORD PTR [eax+44]
  002a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutWrite@12

; 548  : 						playbackControl->waveHeadersPos = (playbackControl->waveHeadersPos +1) % playbackControl->waveHeadersNum;

  002a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _playbackControl
  002ad	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  002b0	40		 inc	 eax
  002b1	99		 cdq
  002b2	f7 79 20	 idiv	 DWORD PTR [ecx+32]
  002b5	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 549  : 					} else {

  002b8	eb 17		 jmp	 SHORT $L83793
$L83790:

; 550  : 						availOverrun -= 10;

  002ba	83 2d 00 00 00
	00 0a		 sub	 DWORD PTR _availOverrun, 10 ; 0000000aH

; 551  : 						statusTxt = "!! Skipping frame !!";

  002c1	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _statusTxt$[ebp], OFFSET FLAT:??_C@_0BF@EBIO@?$CB?$CB?5Skipping?5frame?5?$CB?$CB?$AA@ ; `string'
  002c8	eb 07		 jmp	 SHORT $L83793
$L83761:

; 482  : 				statusTxt = " Unknown codec ";

  002ca	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _statusTxt$[ebp], OFFSET FLAT:??_C@_0BA@FDGN@?5Unknown?5codec?5?$AA@ ; `string'
$L83793:

; 552  : 					}
; 553  : 				}
; 554  : 			}
; 555  : 		}
; 556  : 		{
; 557  : 			char ttt[2048];
; 558  : 			sprintf(ttt, "%s %d %d ", statusTxt, availPlayback, availOverrun);

  002d1	ff 35 00 00 00
	00		 push	 DWORD PTR _availOverrun
  002d7	8d 85 f4 f7 ff
	ff		 lea	 eax, DWORD PTR _ttt$83795[ebp]
  002dd	ff 35 00 00 00
	00		 push	 DWORD PTR _availPlayback
  002e3	ff 75 08	 push	 DWORD PTR _statusTxt$[ebp]
  002e6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09HLBN@?$CFs?5?$CFd?5?$CFd?5?$AA@ ; `string'
  002eb	50		 push	 eax
  002ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  002f2	83 c4 14	 add	 esp, 20			; 00000014H

; 559  : 			SetDlgItemTextA(voiceDlgHWND, IDC_STATUS, ttt);

  002f5	8d 85 f4 f7 ff
	ff		 lea	 eax, DWORD PTR _ttt$83795[ebp]
  002fb	50		 push	 eax
  002fc	68 86 05 00 00	 push	 1414			; 00000586H
  00301	ff 35 00 00 00
	00		 push	 DWORD PTR _voiceDlgHWND
  00307	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemTextA@12

; 560  : 		}
; 561  : 		TlenP2PPacketFree(packet);

  0030d	53		 push	 ebx
  0030e	e8 00 00 00 00	 call	 _TlenP2PPacketFree
  00313	59		 pop	 ecx
  00314	5e		 pop	 esi

; 562  : 	}
; 563  : 	else {

  00315	eb 1e		 jmp	 SHORT $L83797
$L83752:

; 564  : 		if (playbackControl!=NULL) {

  00317	a1 00 00 00 00	 mov	 eax, DWORD PTR _playbackControl
  0031c	85 c0		 test	 eax, eax
  0031e	74 0e		 je	 SHORT $L83799

; 565  : 			TlenVoiceFreeVc(playbackControl);

  00320	50		 push	 eax
  00321	e8 00 00 00 00	 call	 _TlenVoiceFreeVc

; 566  : 			playbackControl = NULL;

  00326	83 25 00 00 00
	00 00		 and	 DWORD PTR _playbackControl, 0
  0032d	59		 pop	 ecx
$L83799:

; 567  : 		}
; 568  : 		ft->state = FT_ERROR;

  0032e	c7 47 0c 04 00
	00 00		 mov	 DWORD PTR [edi+12], 4
$L83797:
  00335	5f		 pop	 edi
  00336	5b		 pop	 ebx

; 569  : 	}
; 570  : }

  00337	c9		 leave
  00338	c3		 ret	 0
_TlenVoiceReceiveParse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@OODI@VoiceDeviceOut?$AA@		; `string'
PUBLIC	??_C@_0BN@MJGN@Playback?5device?5ID?5?$CD?$CFu?3?5?$CFs?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@OELG@TlenVoiceStart?5FAILED?$CB?$AA@	; `string'
PUBLIC	??_C@_0BD@NBHN@TlenVoiceStart?5OK?$CB?$AA@	; `string'
EXTRN	__imp__waveOutOpen@24:NEAR
EXTRN	__imp__waveOutGetNumDevs@0:NEAR
EXTRN	__imp__waveOutGetDevCapsW@12:NEAR
;	COMDAT ??_C@_0P@OODI@VoiceDeviceOut?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_database.h
_DATA	SEGMENT
??_C@_0P@OODI@VoiceDeviceOut?$AA@ DB 'VoiceDeviceOut', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@MJGN@Playback?5device?5ID?5?$CD?$CFu?3?5?$CFs?$AN?6?$AA@
_DATA	SEGMENT
??_C@_0BN@MJGN@Playback?5device?5ID?5?$CD?$CFu?3?5?$CFs?$AN?6?$AA@ DB 'Pl'
	DB	'ayback device ID #%u: %s', 0dH, 0aH, 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@OELG@TlenVoiceStart?5FAILED?$CB?$AA@
_DATA	SEGMENT
??_C@_0BH@OELG@TlenVoiceStart?5FAILED?$CB?$AA@ DB 'TlenVoiceStart FAILED!'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@NBHN@TlenVoiceStart?5OK?$CB?$AA@
_DATA	SEGMENT
??_C@_0BD@NBHN@TlenVoiceStart?5OK?$CB?$AA@ DB 'TlenVoiceStart OK!', 00H ; `string'
_DATA	ENDS
;	COMDAT _TlenVoicePlaybackStart
_TEXT	SEGMENT
_control$ = 8
_wfm$ = -32
_i$ = 8
_j$ = -8
_iNumDevs$ = -12
_iSelDev$ = -4
_wic$ = -140
_dbv$84586 = -56
_cgs$84587 = -44
_TlenVoicePlaybackStart PROC NEAR			; COMDAT

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 151  : 	WAVEFORMATEX wfm;
; 152  : 	MMRESULT mmres;
; 153  : 	int i, j;
; 154  : 	int iNumDevs, iSelDev;
; 155  : 	WAVEOUTCAPS     wic;
; 156  : 
; 157  :     memset(&wfm, 0, sizeof(wfm));

  0000b	33 ff		 xor	 edi, edi
  0000d	6a 12		 push	 18			; 00000012H
  0000f	8d 45 e0	 lea	 eax, DWORD PTR _wfm$[ebp]
  00012	57		 push	 edi
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _memset

; 158  :     wfm.cbSize          = sizeof(WAVEFORMATEX);
; 159  :     wfm.nChannels       = 1;
; 160  :     wfm.wBitsPerSample  = 16;
; 161  :     wfm.nSamplesPerSec  = modeFrequency[control->codec];

  00019	8b 75 08	 mov	 esi, DWORD PTR _control$[ebp]
  0001c	66 c7 45 f0 12
	00		 mov	 WORD PTR _wfm$[ebp+16], 18 ; 00000012H
  00022	66 c7 45 e2 01
	00		 mov	 WORD PTR _wfm$[ebp+2], 1
  00028	66 c7 45 ee 10
	00		 mov	 WORD PTR _wfm$[ebp+14], 16 ; 00000010H
  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 162  :     wfm.nAvgBytesPerSec = wfm.nSamplesPerSec * wfm.nChannels * wfm.wBitsPerSample/8;
; 163  :     wfm.nBlockAlign     = 2 * wfm.nChannels;

  00031	66 c7 45 ec 02
	00		 mov	 WORD PTR _wfm$[ebp+12], 2
  00037	c1 e0 02	 shl	 eax, 2

; 164  :     wfm.wFormatTag      = WAVE_FORMAT_PCM;

  0003a	66 c7 45 e0 01
	00		 mov	 WORD PTR _wfm$[ebp], 1

; 165  : 
; 166  : 	control->waveMode	= 0;
; 167  : 	control->waveFrameSize = modeFrameSize[control->codec] * 160 * wfm.nChannels;// * wfm.wBitsPerSample / 8;
; 168  : 	control->waveHeadersPos = 0;
; 169  : 	control->waveHeadersNum = availLimitMin + 2;
; 170  : 
; 171  : 	j = DBGetContactSettingWord(NULL, control->proto->iface.m_szModuleName, "VoiceDeviceOut", 0);

  00040	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _cgs$84587[ebp+4], OFFSET FLAT:??_C@_0P@OODI@VoiceDeviceOut?$AA@ ; `string'
  00047	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _modeFrequency[eax]
  0004d	89 3e		 mov	 DWORD PTR [esi], edi
  0004f	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _modeFrameSize[eax]
  00055	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00058	89 4d e4	 mov	 DWORD PTR _wfm$[ebp+4], ecx
  0005b	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0005e	c1 e0 05	 shl	 eax, 5
  00061	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00064	a1 00 00 00 00	 mov	 eax, DWORD PTR _availLimitMin
  00069	83 c0 02	 add	 eax, 2
  0006c	c1 e1 04	 shl	 ecx, 4
  0006f	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00072	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00075	c1 e9 03	 shr	 ecx, 3
  00078	89 4d e8	 mov	 DWORD PTR _wfm$[ebp+8], ecx
  0007b	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0007e	89 45 d4	 mov	 DWORD PTR _cgs$84587[ebp], eax
  00081	8d 45 c8	 lea	 eax, DWORD PTR _dbv$84586[ebp]
  00084	89 45 dc	 mov	 DWORD PTR _cgs$84587[ebp+8], eax
  00087	8d 45 d4	 lea	 eax, DWORD PTR _cgs$84587[ebp]
  0008a	50		 push	 eax
  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00090	57		 push	 edi
  00091	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@ ; `string'
  00096	ff 50 24	 call	 DWORD PTR [eax+36]
  00099	83 c4 18	 add	 esp, 24			; 00000018H
  0009c	85 c0		 test	 eax, eax
  0009e	74 05		 je	 SHORT $L84588
  000a0	89 7d f8	 mov	 DWORD PTR _j$[ebp], edi
  000a3	eb 07		 jmp	 SHORT $L84585
$L84588:
  000a5	0f b7 45 cc	 movzx	 eax, WORD PTR _dbv$84586[ebp+4]
  000a9	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$L84585:

; 172  : 	iSelDev = WAVE_MAPPER;

  000ac	83 4d fc ff	 or	 DWORD PTR _iSelDev$[ebp], -1

; 173  : 	if (j!=0) {

  000b0	39 7d f8	 cmp	 DWORD PTR _j$[ebp], edi
  000b3	53		 push	 ebx
  000b4	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__waveOutGetDevCapsW@12
  000ba	74 3f		 je	 SHORT $L83535

; 174  : 		iNumDevs = waveOutGetNumDevs();

  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetNumDevs@0

; 175  : 		for (i = 0; i < iNumDevs; i++) {

  000c2	3b c7		 cmp	 eax, edi
  000c4	89 45 f4	 mov	 DWORD PTR _iNumDevs$[ebp], eax
  000c7	89 7d 08	 mov	 DWORD PTR _i$[ebp], edi
  000ca	7e 2f		 jle	 SHORT $L83535
$L83533:

; 176  : 			if (!waveOutGetDevCaps(i, &wic, sizeof(WAVEOUTCAPS))) {

  000cc	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _wic$[ebp]
  000d2	6a 54		 push	 84			; 00000054H
  000d4	50		 push	 eax
  000d5	ff 75 08	 push	 DWORD PTR _i$[ebp]
  000d8	ff d3		 call	 ebx
  000da	85 c0		 test	 eax, eax
  000dc	75 0a		 jne	 SHORT $L83534

; 177  : 				if (wic.dwFormats != 0) {

  000de	39 7d bc	 cmp	 DWORD PTR _wic$[ebp+72], edi
  000e1	74 05		 je	 SHORT $L83534

; 178  : 					j--;

  000e3	ff 4d f8	 dec	 DWORD PTR _j$[ebp]

; 179  : 					if (j == 0) {

  000e6	74 0d		 je	 SHORT $L84593
$L83534:

; 175  : 		for (i = 0; i < iNumDevs; i++) {

  000e8	ff 45 08	 inc	 DWORD PTR _i$[ebp]
  000eb	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  000ee	3b 45 f4	 cmp	 eax, DWORD PTR _iNumDevs$[ebp]
  000f1	7c d9		 jl	 SHORT $L83533

; 179  : 					if (j == 0) {

  000f3	eb 06		 jmp	 SHORT $L83535
$L84593:

; 180  : 						iSelDev = i;

  000f5	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  000f8	89 45 fc	 mov	 DWORD PTR _iSelDev$[ebp], eax
$L83535:

; 181  : 						break;
; 182  : 					}
; 183  : 				}
; 184  : 			}
; 185  : 		}
; 186  : 	}
; 187  : 	if (!waveOutGetDevCaps(iSelDev, &wic, sizeof(WAVEOUTCAPS))) {

  000fb	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _wic$[ebp]
  00101	6a 54		 push	 84			; 00000054H
  00103	50		 push	 eax
  00104	ff 75 fc	 push	 DWORD PTR _iSelDev$[ebp]
  00107	ff d3		 call	 ebx
  00109	85 c0		 test	 eax, eax
  0010b	5b		 pop	 ebx
  0010c	75 1a		 jne	 SHORT $L83541

; 188  : 		JabberLog(control->proto, "Playback device ID #%u: %s\r\n", iSelDev, wic.szPname);

  0010e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _wic$[ebp+8]
  00114	50		 push	 eax
  00115	ff 75 fc	 push	 DWORD PTR _iSelDev$[ebp]
  00118	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@MJGN@Playback?5device?5ID?5?$CD?$CFu?3?5?$CFs?$AN?6?$AA@ ; `string'
  0011d	ff 76 4c	 push	 DWORD PTR [esi+76]
  00120	e8 00 00 00 00	 call	 _JabberLog
  00125	83 c4 10	 add	 esp, 16			; 00000010H
$L83541:

; 189  : 	}
; 190  : 
; 191  : 	mmres = waveOutOpen(&control->hWaveOut, iSelDev, &wfm, (DWORD) &TlenVoicePlaybackCallback, (DWORD) control, CALLBACK_FUNCTION);

  00128	68 00 00 03 00	 push	 196608			; 00030000H
  0012d	56		 push	 esi
  0012e	8d 45 e0	 lea	 eax, DWORD PTR _wfm$[ebp]
  00131	68 00 00 00 00	 push	 OFFSET FLAT:_TlenVoicePlaybackCallback@20
  00136	50		 push	 eax
  00137	8d 46 2c	 lea	 eax, DWORD PTR [esi+44]
  0013a	ff 75 fc	 push	 DWORD PTR _iSelDev$[ebp]
  0013d	50		 push	 eax
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutOpen@24

; 192  : 	if (mmres!=MMSYSERR_NOERROR) {

  00144	85 c0		 test	 eax, eax
  00146	74 14		 je	 SHORT $L83545

; 193  : 		JabberLog(control->proto, "TlenVoiceStart FAILED!");

  00148	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@OELG@TlenVoiceStart?5FAILED?$CB?$AA@ ; `string'
  0014d	ff 76 4c	 push	 DWORD PTR [esi+76]
  00150	e8 00 00 00 00	 call	 _JabberLog
  00155	59		 pop	 ecx
  00156	59		 pop	 ecx

; 194  : 		return 1;

  00157	6a 01		 push	 1
  00159	58		 pop	 eax
  0015a	eb 46		 jmp	 SHORT $L83519
$L83545:

; 195  : 	}
; 196  : 	control->waveData = (short *)mir_alloc(control->waveHeadersNum * control->waveFrameSize * 2);

  0015c	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0015f	0f af 46 20	 imul	 eax, DWORD PTR [esi+32]
  00163	d1 e0		 shl	 eax, 1
  00165	50		 push	 eax
  00166	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4

; 197  : 	memset(control->waveData, 0, control->waveHeadersNum * control->waveFrameSize * 2);

  0016c	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  0016f	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00172	0f af 4e 20	 imul	 ecx, DWORD PTR [esi+32]
  00176	d1 e1		 shl	 ecx, 1
  00178	51		 push	 ecx
  00179	57		 push	 edi
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 _memset

; 198  : 	control->waveHeaders = (WAVEHDR *)mir_alloc(control->waveHeadersNum * sizeof(WAVEHDR));

  00180	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00183	c1 e0 05	 shl	 eax, 5
  00186	50		 push	 eax
  00187	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4

; 199  : 	JabberLog(control->proto, "TlenVoiceStart OK!");

  0018d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@NBHN@TlenVoiceStart?5OK?$CB?$AA@ ; `string'
  00192	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00195	ff 76 4c	 push	 DWORD PTR [esi+76]
  00198	e8 00 00 00 00	 call	 _JabberLog
  0019d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 200  : 	return 0;

  001a0	33 c0		 xor	 eax, eax
$L83519:
  001a2	5f		 pop	 edi
  001a3	5e		 pop	 esi

; 201  : }

  001a4	c9		 leave
  001a5	c3		 ret	 0
_TlenVoicePlaybackStart ENDP
_TEXT	ENDS
;	COMDAT _TlenVoicePlaybackCallback@20
_TEXT	SEGMENT
_hwo$ = 8
_uMsg$ = 12
_dwParam1$ = 20
_TlenVoicePlaybackCallback@20 PROC NEAR			; COMDAT

; 87   : 	if (uMsg == WOM_DONE) {

  00000	81 7c 24 08 bd
	03 00 00	 cmp	 DWORD PTR _uMsg$[esp-4], 957 ; 000003bdH
  00008	75 1f		 jne	 SHORT $L83492

; 88   : 		//TLEN_VOICE_CONTROL *control = (TLEN_VOICE_CONTROL *) dwInstance;
; 89   : 		waveOutUnprepareHeader(hwo, (WAVEHDR *) dwParam1, sizeof(WAVEHDR));

  0000a	6a 20		 push	 32			; 00000020H
  0000c	ff 74 24 14	 push	 DWORD PTR _dwParam1$[esp]
  00010	ff 74 24 0c	 push	 DWORD PTR _hwo$[esp+4]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutUnprepareHeader@12

; 90   : 		if (availPlayback > 0) {

  0001a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _availPlayback, 0
  00021	7e 06		 jle	 SHORT $L83492

; 91   : 			availPlayback--;

  00023	ff 0d 00 00 00
	00		 dec	 DWORD PTR _availPlayback
$L83492:

; 92   : 		}
; 93   : //		playbackControl->waveHeaders[playbackControl->waveHeadersPos].dwFlags =  WHDR_DONE;
; 94   : //		playbackControl->waveHeaders[playbackControl->waveHeadersPos].lpData = (char *) (playbackControl->waveData + playbackControl->waveHeadersPos * playbackControl->waveFrameSize);
; 95   : //		playbackControl->waveHeaders[playbackControl->waveHeadersPos].dwBufferLength = playbackControl->waveFrameSize * 2;
; 96   : //		waveOutPrepareHeader(playbackControl->hWaveOut, &playbackControl->waveHeaders[playbackControl->waveHeadersPos], sizeof(WAVEHDR));
; 97   : //		waveOutWrite(playbackControl->hWaveOut, &playbackControl->waveHeaders[playbackControl->waveHeadersPos], sizeof(WAVEHDR));
; 98   : 
; 99   : 	}
; 100  : }

  00029	c2 14 00	 ret	 20			; 00000014H
_TlenVoicePlaybackCallback@20 ENDP
_TEXT	ENDS
;	COMDAT _TlenVoiceCrypt
_TEXT	SEGMENT
_buffer$ = 8
_len$ = 12
_TlenVoiceCrypt PROC NEAR				; COMDAT

; 338  : 	int i, j, k;
; 339  : 	j = 0x71;
; 340  : 	for (i=0;i<len;i++) {

  00000	33 d2		 xor	 edx, edx
  00002	6a 71		 push	 113			; 00000071H
  00004	39 54 24 0c	 cmp	 DWORD PTR _len$[esp], edx
  00008	59		 pop	 ecx
  00009	7e 1b		 jle	 SHORT $L83656
$L83654:

; 341  : 		k = j;
; 342  : 		j = j << 6;
; 343  : 		j += k;
; 344  : 		j = k + (j << 1);
; 345  : 		j += 0xBB;

  0000b	69 c9 83 00 00
	00		 imul	 ecx, 131		; 00000083H
  00011	8b 44 24 04	 mov	 eax, DWORD PTR _buffer$[esp-4]
  00015	81 c1 bb 00 00
	00		 add	 ecx, 187		; 000000bbH
  0001b	03 c2		 add	 eax, edx

; 346  : 		buffer[i]^=j;

  0001d	30 08		 xor	 BYTE PTR [eax], cl
  0001f	42		 inc	 edx
  00020	3b 54 24 08	 cmp	 edx, DWORD PTR _len$[esp-4]
  00024	7c e5		 jl	 SHORT $L83654
$L83656:

; 347  : 	}
; 348  : }

  00026	c3		 ret	 0
_TlenVoiceCrypt ENDP
_TEXT	ENDS
PUBLIC	_TlenVoiceSendingThread
PUBLIC	??_C@_0CA@OEBH@Thread?5started?3?5type?$DNvoice_send?$AA@ ; `string'
PUBLIC	??_C@_0CH@EDOE@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?86?8?5a?$DN?8?$CFs?8?5p?$DN@ ; `string'
PUBLIC	??_C@_0CJ@NBAC@Waiting?5for?5the?5voice?5data?5to?5be@ ; `string'
PUBLIC	??_C@_0N@LDFM@Finish?5voice?$AA@		; `string'
PUBLIC	??_C@_0O@IMLC@ft?9?$DOs?5is?5NULL?$AA@		; `string'
PUBLIC	??_C@_0BF@IPEE@Sending?5as?5client?4?4?4?$AA@	; `string'
PUBLIC	??_C@_0CP@CNGK@Entering?5send?5loop?5for?5this?5file@ ; `string'
PUBLIC	??_C@_0CO@DACA@Closing?5connection?5for?5this?5file@ ; `string'
PUBLIC	??_C@_0ED@MCPA@Cannot?5allocate?5port?5to?5bind?5for@ ; `string'
PUBLIC	??_C@_0BE@NAKP@Finish?5successfully?$AA@	; `string'
PUBLIC	??_C@_1BK@OCHC@?$AA?4?$AA?4?$AA?4?$AAD?$AAe?$AAn?$AAi?$AAe?$AAd?$AA?4?$AA?4?$AA?4?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BJ@HICO@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?88?8?1?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BD@FGGL@Finish?5with?5errors?$AA@	; `string'
PUBLIC	??_C@_0BO@JLOP@Thread?5ended?3?5type?$DNvoice_send?$AA@ ; `string'
;	COMDAT ??_C@_0CA@OEBH@Thread?5started?3?5type?$DNvoice_send?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_netlib.h
_DATA	SEGMENT
??_C@_0CA@OEBH@Thread?5started?3?5type?$DNvoice_send?$AA@ DB 'Thread star'
	DB	'ted: type=voice_send', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CH@EDOE@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?86?8?5a?$DN?8?$CFs?8?5p?$DN@
_DATA	SEGMENT
??_C@_0CH@EDOE@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?86?8?5a?$DN?8?$CFs?8?5p?$DN@ DB '<'
	DB	'v t=''%s'' i=''%s'' e=''6'' a=''%s'' p=''%d''/>', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@NBAC@Waiting?5for?5the?5voice?5data?5to?5be@
_DATA	SEGMENT
??_C@_0CJ@NBAC@Waiting?5for?5the?5voice?5data?5to?5be@ DB 'Waiting for th'
	DB	'e voice data to be sent...', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@LDFM@Finish?5voice?$AA@
_DATA	SEGMENT
??_C@_0N@LDFM@Finish?5voice?$AA@ DB 'Finish voice', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@IMLC@ft?9?$DOs?5is?5NULL?$AA@
_DATA	SEGMENT
??_C@_0O@IMLC@ft?9?$DOs?5is?5NULL?$AA@ DB 'ft->s is NULL', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@IPEE@Sending?5as?5client?4?4?4?$AA@
_DATA	SEGMENT
??_C@_0BF@IPEE@Sending?5as?5client?4?4?4?$AA@ DB 'Sending as client...', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CP@CNGK@Entering?5send?5loop?5for?5this?5file@
_DATA	SEGMENT
??_C@_0CP@CNGK@Entering?5send?5loop?5for?5this?5file@ DB 'Entering send l'
	DB	'oop for this file connection...', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CO@DACA@Closing?5connection?5for?5this?5file@
_DATA	SEGMENT
??_C@_0CO@DACA@Closing?5connection?5for?5this?5file@ DB 'Closing connecti'
	DB	'on for this file transfer... ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0ED@MCPA@Cannot?5allocate?5port?5to?5bind?5for@
_DATA	SEGMENT
??_C@_0ED@MCPA@Cannot?5allocate?5port?5to?5bind?5for@ DB 'Cannot allocate'
	DB	' port to bind for file server thread, thread ended.', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@NAKP@Finish?5successfully?$AA@
_DATA	SEGMENT
??_C@_0BE@NAKP@Finish?5successfully?$AA@ DB 'Finish successfully', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_1BK@OCHC@?$AA?4?$AA?4?$AA?4?$AAD?$AAe?$AAn?$AAi?$AAe?$AAd?$AA?4?$AA?4?$AA?4?$AA?$AA@
_DATA	SEGMENT
??_C@_1BK@OCHC@?$AA?4?$AA?4?$AA?4?$AAD?$AAe?$AAn?$AAi?$AAe?$AAd?$AA?4?$AA?4?$AA?4?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '.', 00H, 'D', 00H, 'e', 00H, 'n', 00H, 'i', 00H
	DB	'e', 00H, 'd', 00H, '.', 00H, '.', 00H, '.', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@HICO@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?88?8?1?$DO?$AA@
_DATA	SEGMENT
??_C@_0BJ@HICO@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?88?8?1?$DO?$AA@ DB '<'
	DB	'v t=''%s'' i=''%s'' e=''8''/>', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@FGGL@Finish?5with?5errors?$AA@
_DATA	SEGMENT
??_C@_0BD@FGGL@Finish?5with?5errors?$AA@ DB 'Finish with errors', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@JLOP@Thread?5ended?3?5type?$DNvoice_send?$AA@
_DATA	SEGMENT
??_C@_0BO@JLOP@Thread?5ended?3?5type?$DNvoice_send?$AA@ DB 'Thread ended:'
	DB	' type=voice_send', 00H			; `string'
_DATA	ENDS
;	COMDAT _TlenVoiceSendingThread
_TEXT	SEGMENT
_ft$ = 8
_s$ = -28
_hEvent$ = -32
_nick$ = 8
_nloc$83822 = -24
_s$83823 = 8
_TlenVoiceSendingThread PROC NEAR			; COMDAT

; 574  : {

  00000	83 ec 20	 sub	 esp, 32			; 00000020H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 575  : 	JABBER_SOCKET s = NULL;
; 576  : 	HANDLE hEvent;
; 577  : 	char *nick;
; 578  : 
; 579  : 	JabberLog(ft->proto, "Thread started: type=voice_send");

  00006	8b 74 24 30	 mov	 esi, DWORD PTR _ft$[esp+40]
  0000a	57		 push	 edi
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CA@OEBH@Thread?5started?3?5type?$DNvoice_send?$AA@ ; `string'
  00010	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  00016	e8 00 00 00 00	 call	 _JabberLog

; 580  : 	ft->pfnNewConnectionV2 = TlenVoiceReceivingConnection;
; 581  : 	s = TlenP2PListen(ft);

  0001b	56		 push	 esi
  0001c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET FLAT:_TlenVoiceReceivingConnection
  00023	e8 00 00 00 00	 call	 _TlenP2PListen

; 582  : 	if (s != NULL) {

  00028	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetDlgItemTextW@12
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00031	85 c0		 test	 eax, eax
  00033	89 44 24 14	 mov	 DWORD PTR _s$[esp+48], eax
  00037	bd 00 00 00 00	 mov	 ebp, OFFSET FLAT:??_C@_0BJ@MKNL@LangPack?1TranslateString?$AA@ ; `string'
  0003c	bb 86 05 00 00	 mov	 ebx, 1414		; 00000586H
  00041	0f 84 f2 01 00
	00		 je	 $L83810

; 583  : 		SetDlgItemText(voiceDlgHWND, IDC_STATUS, TranslateT("...Waiting for connection..."));

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0004c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DK@CHIL@?$AA?4?$AA?4?$AA?4?$AAW?$AAa?$AAi?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAc?$AAo?$AAn?$AAn?$AAe@ ; `string'
  00051	68 00 10 00 00	 push	 4096			; 00001000H
  00056	55		 push	 ebp
  00057	ff 50 24	 call	 DWORD PTR [eax+36]
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005d	50		 push	 eax
  0005e	53		 push	 ebx
  0005f	ff 35 00 00 00
	00		 push	 DWORD PTR _voiceDlgHWND
  00065	ff d7		 call	 edi

; 584  : 		//ProtoBroadcastAck(iface.m_szModuleName, ft->hContact, ACKTYPE_FILE, ACKRESULT_CONNECTING, ft, 0);
; 585  : 		ft->s = s;

  00067	8b 44 24 14	 mov	 eax, DWORD PTR _s$[esp+48]
  0006b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 586  : 		//JabberLog("ft->s = %d", s);
; 587  : 		//JabberLog("fileCount = %d", ft->fileCount);
; 588  : 
; 589  : 		hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  0006e	33 c0		 xor	 eax, eax
  00070	50		 push	 eax
  00071	50		 push	 eax
  00072	50		 push	 eax
  00073	50		 push	 eax
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateEventW@16

; 590  : 		ft->hFileEvent = hEvent;
; 591  : 		ft->currentFile = 0;
; 592  : 		ft->state = FT_CONNECTING;
; 593  : 
; 594  : 		nick = JabberNickFromJID(ft->jid);

  0007a	ff 76 10	 push	 DWORD PTR [esi+16]
  0007d	83 66 58 00	 and	 DWORD PTR [esi+88], 0
  00081	83 66 0c 00	 and	 DWORD PTR [esi+12], 0
  00085	89 44 24 14	 mov	 DWORD PTR _hEvent$[esp+52], eax
  00089	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0008c	e8 00 00 00 00	 call	 _JabberNickFromJID

; 595  : 		JabberSend(ft->proto, "<v t='%s' i='%s' e='6' a='%s' p='%d'/>", nick, ft->iqId, ft->localName, ft->wLocalPort);

  00091	0f b7 4e 2c	 movzx	 ecx, WORD PTR [esi+44]
  00095	51		 push	 ecx
  00096	89 44 24 3c	 mov	 DWORD PTR _nick$[esp+52], eax
  0009a	ff 76 28	 push	 DWORD PTR [esi+40]
  0009d	ff 76 18	 push	 DWORD PTR [esi+24]
  000a0	50		 push	 eax
  000a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CH@EDOE@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?86?8?5a?$DN?8?$CFs?8?5p?$DN@ ; `string'
  000a6	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  000ac	e8 00 00 00 00	 call	 _JabberSend

; 596  : 		mir_free(nick);

  000b1	ff 74 24 50	 push	 DWORD PTR _nick$[esp+72]
  000b5	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12

; 597  : 		JabberLog(ft->proto, "Waiting for the voice data to be sent...");

  000bb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CJ@NBAC@Waiting?5for?5the?5voice?5data?5to?5be@ ; `string'
  000c0	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  000c6	e8 00 00 00 00	 call	 _JabberLog
  000cb	83 c4 28	 add	 esp, 40			; 00000028H

; 598  : 		WaitForSingleObject(hEvent, INFINITE);

  000ce	6a ff		 push	 -1
  000d0	ff 74 24 14	 push	 DWORD PTR _hEvent$[esp+52]
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 599  : 		ft->hFileEvent = NULL;
; 600  : 		CloseHandle(hEvent);

  000da	ff 74 24 10	 push	 DWORD PTR _hEvent$[esp+48]
  000de	83 66 3c 00	 and	 DWORD PTR [esi+60], 0
  000e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 601  : 		JabberLog(ft->proto, "Finish voice");

  000e8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@LDFM@Finish?5voice?$AA@ ; `string'
  000ed	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  000f3	e8 00 00 00 00	 call	 _JabberLog

; 602  : 		Netlib_CloseHandle(s);

  000f8	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  000fd	6a 00		 push	 0
  000ff	ff 74 24 20	 push	 DWORD PTR _s$[esp+60]
  00103	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@ ; `string'
  00108	ff 50 24	 call	 DWORD PTR [eax+36]

; 603  : 		ft->s = NULL;

  0010b	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 604  : 		JabberLog(ft->proto, "ft->s is NULL");

  0010f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@IMLC@ft?9?$DOs?5is?5NULL?$AA@ ; `string'
  00114	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  0011a	e8 00 00 00 00	 call	 _JabberLog
  0011f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 605  : 
; 606  : 		if (ft->state == FT_SWITCH) {

  00122	83 7e 0c 06	 cmp	 DWORD PTR [esi+12], 6
  00126	0f 85 26 01 00
	00		 jne	 $L83840

; 607  : 			NETLIBOPENCONNECTION nloc;
; 608  : 			JABBER_SOCKET s;
; 609  : 			JabberLog(ft->proto, "Sending as client...");

  0012c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@IPEE@Sending?5as?5client?4?4?4?$AA@ ; `string'
  00131	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  00137	e8 00 00 00 00	 call	 _JabberLog

; 610  : 			ft->state = FT_CONNECTING;
; 611  : 			nloc.cbSize = NETLIBOPENCONNECTION_V1_SIZE;//sizeof(NETLIBOPENCONNECTION);
; 612  : 			nloc.szHost = ft->hostName;

  0013c	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0013f	83 66 0c 00	 and	 DWORD PTR [esi+12], 0
  00143	89 44 24 24	 mov	 DWORD PTR _nloc$83822[esp+60], eax

; 613  : 			nloc.wPort = ft->wPort;

  00147	66 8b 46 24	 mov	 ax, WORD PTR [esi+36]

; 614  : 			nloc.flags = 0;

  0014b	83 64 24 2c 00	 and	 DWORD PTR _nloc$83822[esp+68], 0
  00150	66 89 44 24 28	 mov	 WORD PTR _nloc$83822[esp+64], ax

; 615  : 			s = (HANDLE) CallService(MS_NETLIB_OPENCONNECTION, (WPARAM) ft->proto->hNetlibUser, (LPARAM) &nloc);

  00155	8d 44 24 20	 lea	 eax, DWORD PTR _nloc$83822[esp+56]
  00159	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR _nloc$83822[esp+56], 16 ; 00000010H
  00161	50		 push	 eax
  00162	8b 86 7c 02 00
	00		 mov	 eax, DWORD PTR [esi+636]
  00168	ff b0 c0 00 00
	00		 push	 DWORD PTR [eax+192]
  0016e	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00173	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@JEKK@Netlib?1OpenConnection?$AA@ ; `string'
  00178	ff 50 24	 call	 DWORD PTR [eax+36]
  0017b	83 c4 14	 add	 esp, 20			; 00000014H
  0017e	89 44 24 34	 mov	 DWORD PTR _s$83823[esp+44], eax

; 616  : 			if (s != NULL) {

  00182	85 c0		 test	 eax, eax
  00184	0f 84 c1 00 00
	00		 je	 $L83829

; 617  : 				SetDlgItemText(voiceDlgHWND, IDC_STATUS, TranslateT("...Connecting..."));

  0018a	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0018f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CC@CDEO@?$AA?4?$AA?4?$AA?4?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAi?$AAn?$AAg?$AA?4?$AA?4?$AA?4?$AA?$AA@ ; `string'
  00194	68 00 10 00 00	 push	 4096			; 00001000H
  00199	55		 push	 ebp
  0019a	ff 50 24	 call	 DWORD PTR [eax+36]
  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a0	50		 push	 eax
  001a1	53		 push	 ebx
  001a2	ff 35 00 00 00
	00		 push	 DWORD PTR _voiceDlgHWND
  001a8	ff d7		 call	 edi

; 618  : 				//ProtoBroadcastAck(iface.m_szModuleName, ft->hContact, ACKTYPE_FILE, ACKRESULT_CONNECTING, ft, 0);
; 619  : 				ft->s = s;

  001aa	8b 44 24 34	 mov	 eax, DWORD PTR _s$83823[esp+44]

; 620  : 				TlenP2PEstablishOutgoingConnection(ft, FALSE);

  001ae	6a 00		 push	 0
  001b0	56		 push	 esi
  001b1	89 46 04	 mov	 DWORD PTR [esi+4], eax
  001b4	e8 00 00 00 00	 call	 _TlenP2PEstablishOutgoingConnection

; 621  : 				if (ft->state!=FT_ERROR) {

  001b9	83 7e 0c 04	 cmp	 DWORD PTR [esi+12], 4
  001bd	59		 pop	 ecx
  001be	59		 pop	 ecx
  001bf	74 50		 je	 SHORT $L83837

; 622  : 					JabberLog(ft->proto, "Entering send loop for this file connection...");

  001c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CP@CNGK@Entering?5send?5loop?5for?5this?5file@ ; `string'
  001c6	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  001cc	e8 00 00 00 00	 call	 _JabberLog

; 623  : 					playbackControl = NULL;

  001d1	83 25 00 00 00
	00 00		 and	 DWORD PTR _playbackControl, 0

; 624  : 					recordingControl = TlenVoiceCreateVC(ft->proto, 3);

  001d8	6a 03		 push	 3
  001da	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  001e0	e8 00 00 00 00	 call	 _TlenVoiceCreateVC
  001e5	a3 00 00 00 00	 mov	 DWORD PTR _recordingControl, eax

; 625  : 					recordingControl->ft = ft;

  001ea	89 70 40	 mov	 DWORD PTR [eax+64], esi

; 626  : 					TlenVoiceRecordingStart(recordingControl);

  001ed	ff 35 00 00 00
	00		 push	 DWORD PTR _recordingControl
  001f3	e8 00 00 00 00	 call	 _TlenVoiceRecordingStart
  001f8	83 c4 14	 add	 esp, 20			; 00000014H
$L84613:

; 627  : 					while (ft->state!=FT_DONE && ft->state!=FT_ERROR) {

  001fb	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  001fe	83 f8 03	 cmp	 eax, 3
  00201	74 0e		 je	 SHORT $L83837
  00203	83 f8 04	 cmp	 eax, 4
  00206	74 09		 je	 SHORT $L83837

; 628  : 						TlenVoiceReceiveParse(ft);

  00208	56		 push	 esi
  00209	e8 00 00 00 00	 call	 _TlenVoiceReceiveParse
  0020e	59		 pop	 ecx
  0020f	eb ea		 jmp	 SHORT $L84613
$L83837:

; 629  : 					}
; 630  : 				}
; 631  : 				JabberLog(ft->proto, "Closing connection for this file transfer... ");

  00211	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CO@DACA@Closing?5connection?5for?5this?5file@ ; `string'
  00216	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  0021c	e8 00 00 00 00	 call	 _JabberLog

; 632  : 				Netlib_CloseHandle(s);

  00221	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00226	6a 00		 push	 0
  00228	ff 74 24 40	 push	 DWORD PTR _s$83823[esp+56]
  0022c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@ ; `string'
  00231	ff 50 24	 call	 DWORD PTR [eax+36]
  00234	83 c4 14	 add	 esp, 20			; 00000014H

; 633  : 			} else {

  00237	eb 19		 jmp	 SHORT $L83840
$L83810:

; 634  : 				ft->state = FT_ERROR;
; 635  : 			}
; 636  : 		}
; 637  : 	} else {
; 638  : 		JabberLog(ft->proto, "Cannot allocate port to bind for file server thread, thread ended.");

  00239	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0ED@MCPA@Cannot?5allocate?5port?5to?5bind?5for@ ; `string'
  0023e	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  00244	e8 00 00 00 00	 call	 _JabberLog
  00249	59		 pop	 ecx
  0024a	59		 pop	 ecx
$L83829:

; 639  : 		ft->state = FT_ERROR;

  0024b	c7 46 0c 04 00
	00 00		 mov	 DWORD PTR [esi+12], 4
$L83840:

; 640  : 	}
; 641  : 	JabberListRemove(ft->proto, LIST_VOICE, ft->iqId);

  00252	ff 76 18	 push	 DWORD PTR [esi+24]
  00255	6a 05		 push	 5
  00257	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  0025d	e8 00 00 00 00	 call	 _JabberListRemove

; 642  : 	switch (ft->state) {

  00262	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00265	83 c4 0c	 add	 esp, 12			; 0000000cH
  00268	83 e8 03	 sub	 eax, 3
  0026b	74 6e		 je	 SHORT $L83846
  0026d	48		 dec	 eax
  0026e	48		 dec	 eax
  0026f	74 52		 je	 SHORT $L83850

; 652  : 	default: // FT_ERROR:
; 653  : 		nick = JabberNickFromJID(ft->jid);

  00271	ff 76 10	 push	 DWORD PTR [esi+16]
  00274	e8 00 00 00 00	 call	 _JabberNickFromJID

; 654  : 		JabberSend(ft->proto, "<v t='%s' i='%s' e='8'/>", nick, ft->iqId);

  00279	ff 76 18	 push	 DWORD PTR [esi+24]
  0027c	89 44 24 3c	 mov	 DWORD PTR _nick$[esp+52], eax
  00280	50		 push	 eax
  00281	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@HICO@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?88?8?1?$DO?$AA@ ; `string'
  00286	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  0028c	e8 00 00 00 00	 call	 _JabberSend

; 655  : 		mir_free(nick);

  00291	ff 74 24 48	 push	 DWORD PTR _nick$[esp+64]
  00295	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12

; 656  : 		JabberLog(ft->proto, "Finish with errors");

  0029b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@FGGL@Finish?5with?5errors?$AA@ ; `string'
  002a0	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  002a6	e8 00 00 00 00	 call	 _JabberLog

; 657  : 		SetDlgItemText(voiceDlgHWND, IDC_STATUS, TranslateT("...Error..."));

  002ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  002b0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@LPHK@?$AA?4?$AA?4?$AA?4?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?4?$AA?4?$AA?4?$AA?$AA@ ; `string'
  002b5	68 00 10 00 00	 push	 4096			; 00001000H
  002ba	55		 push	 ebp
  002bb	ff 50 24	 call	 DWORD PTR [eax+36]
  002be	83 c4 2c	 add	 esp, 44			; 0000002cH

; 658  : 		//ProtoBroadcastAck(iface.m_szModuleName, ft->hContact, ACKTYPE_FILE, ACKRESULT_FAILED, ft, 0);
; 659  : 		break;

  002c1	eb 3e		 jmp	 SHORT $L84614
$L83850:

; 646  : 		//ProtoBroadcastAck(iface.m_szModuleName, ft->hContact, ACKTYPE_FILE, ACKRESULT_SUCCESS, ft, 0);
; 647  : 		break;
; 648  : 	case FT_DENIED:
; 649  : 		SetDlgItemText(voiceDlgHWND, IDC_STATUS, TranslateT("...Denied..."));

  002c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  002c8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@OCHC@?$AA?4?$AA?4?$AA?4?$AAD?$AAe?$AAn?$AAi?$AAe?$AAd?$AA?4?$AA?4?$AA?4?$AA?$AA@ ; `string'
  002cd	68 00 10 00 00	 push	 4096			; 00001000H
  002d2	55		 push	 ebp
  002d3	ff 50 24	 call	 DWORD PTR [eax+36]
  002d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 650  : 		//ProtoBroadcastAck(iface.m_szModuleName, ft->hContact, ACKTYPE_FILE, ACKRESULT_DENIED, ft, 0);
; 651  : 		break;

  002d9	eb 26		 jmp	 SHORT $L84614
$L83846:

; 643  : 	case FT_DONE:
; 644  : 		JabberLog(ft->proto, "Finish successfully");

  002db	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@NAKP@Finish?5successfully?$AA@ ; `string'
  002e0	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  002e6	e8 00 00 00 00	 call	 _JabberLog

; 645  : 		SetDlgItemText(voiceDlgHWND, IDC_STATUS, TranslateT("...Finished..."));

  002eb	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  002f0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BO@LFEK@?$AA?4?$AA?4?$AA?4?$AAF?$AAi?$AAn?$AAi?$AAs?$AAh?$AAe?$AAd?$AA?4?$AA?4?$AA?4?$AA?$AA@ ; `string'
  002f5	68 00 10 00 00	 push	 4096			; 00001000H
  002fa	55		 push	 ebp
  002fb	ff 50 24	 call	 DWORD PTR [eax+36]
  002fe	83 c4 14	 add	 esp, 20			; 00000014H
$L84614:
  00301	50		 push	 eax
  00302	53		 push	 ebx
  00303	ff 35 00 00 00
	00		 push	 DWORD PTR _voiceDlgHWND
  00309	ff d7		 call	 edi

; 660  : 	}
; 661  : 	JabberLog(ft->proto, "Thread ended: type=voice_send");

  0030b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@JLOP@Thread?5ended?3?5type?$DNvoice_send?$AA@ ; `string'
  00310	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  00316	e8 00 00 00 00	 call	 _JabberLog

; 662  : 	TlenP2PFreeFileTransfer(ft);

  0031b	56		 push	 esi
  0031c	e8 00 00 00 00	 call	 _TlenP2PFreeFileTransfer
  00321	83 c4 0c	 add	 esp, 12			; 0000000cH
  00324	5f		 pop	 edi
  00325	5e		 pop	 esi
  00326	5d		 pop	 ebp
  00327	5b		 pop	 ebx

; 663  : }

  00328	83 c4 20	 add	 esp, 32			; 00000020H
  0032b	c3		 ret	 0
_TlenVoiceSendingThread ENDP
_TEXT	ENDS
EXTRN	_gsm_encode:NEAR
EXTRN	_TlenP2PPacketCreate:NEAR
EXTRN	_TlenP2PPacketSetType:NEAR
EXTRN	_TlenP2PPacketPackDword:NEAR
EXTRN	_TlenP2PPacketPackBuffer:NEAR
EXTRN	_TlenP2PPacketSend:NEAR
;	COMDAT _TlenVoiceSendParse
_TEXT	SEGMENT
_ft$ = 8
_i$ = -8
_in$83869 = -12
_TlenVoiceSendParse PROC NEAR				; COMDAT

; 666  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 667  : 	int codec, i;
; 668  : 	TLEN_FILE_PACKET *packet;
; 669  : 
; 670  : 	codec = recordingControl->codec;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _recordingControl
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]

; 671  : 	if ((packet=TlenP2PPacketCreate(sizeof(DWORD)+modeFrameSize[codec]*33)) != NULL) {

  00011	8b 04 9d 00 00
	00 00		 mov	 eax, DWORD PTR _modeFrameSize[ebx*4]
  00018	6b c0 21	 imul	 eax, 33			; 00000021H
  0001b	8d 34 9d 00 00
	00 00		 lea	 esi, DWORD PTR _modeFrameSize[ebx*4]
  00022	83 c0 04	 add	 eax, 4
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _TlenP2PPacketCreate
  0002b	8b f8		 mov	 edi, eax
  0002d	59		 pop	 ecx
  0002e	85 ff		 test	 edi, edi
  00030	0f 84 19 01 00
	00		 je	 $L83868

; 672  : 		short *in;
; 673  : 		float val;
; 674  : 		in = recordingControl->recordingData;

  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR _recordingControl

; 675  : 		TlenP2PPacketSetType(packet, 0x96);

  0003b	68 96 00 00 00	 push	 150			; 00000096H
  00040	57		 push	 edi
  00041	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00044	89 45 f4	 mov	 DWORD PTR _in$83869[ebp], eax
  00047	e8 00 00 00 00	 call	 _TlenP2PPacketSetType

; 676  : 		packet->packet[0] = codec;

  0004c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 677  : 		TlenP2PPacketPackDword(packet, codec);

  0004f	53		 push	 ebx
  00050	57		 push	 edi
  00051	88 18		 mov	 BYTE PTR [eax], bl
  00053	e8 00 00 00 00	 call	 _TlenP2PPacketPackDword

; 678  : 		val = 0;
; 679  : 		for (i=0; i<modeFrameSize[codec] * 160; i+=modeFrameSize[codec]) {

  00058	8b 06		 mov	 eax, DWORD PTR [esi]
  0005a	83 65 f8 00	 and	 DWORD PTR _i$[ebp], 0
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00064	c1 e1 05	 shl	 ecx, 5
  00067	85 c9		 test	 ecx, ecx
  00069	d9 ee		 fldz
  0006b	7e 25		 jle	 SHORT $L83873
  0006d	8b 55 f4	 mov	 edx, DWORD PTR _in$83869[ebp]
  00070	89 55 fc	 mov	 DWORD PTR -4+[ebp], edx
$L83871:

; 680  : 			val += in[i]*in[i];

  00073	8b 55 fc	 mov	 edx, DWORD PTR -4+[ebp]
  00076	01 45 f8	 add	 DWORD PTR _i$[ebp], eax
  00079	0f bf 12	 movsx	 edx, WORD PTR [edx]
  0007c	8b da		 mov	 ebx, edx
  0007e	0f af da	 imul	 ebx, edx
  00081	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]
  00084	89 5d f0	 mov	 DWORD PTR -16+[ebp], ebx
  00087	01 55 fc	 add	 DWORD PTR -4+[ebp], edx
  0008a	39 4d f8	 cmp	 DWORD PTR _i$[ebp], ecx
  0008d	da 45 f0	 fiadd	 DWORD PTR -16+[ebp]
  00090	7c e1		 jl	 SHORT $L83871
$L83873:

; 681  : 		}
; 682  : 		i = (int)((log10(val) - 4) * 2.35);

  00092	51		 push	 ecx
  00093	51		 push	 ecx
  00094	dd 1c 24	 fstp	 QWORD PTR [esp]
  00097	e8 00 00 00 00	 call	 _log10
  0009c	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@8@40018000000000000000
  000a2	59		 pop	 ecx
  000a3	59		 pop	 ecx
  000a4	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@8@40009666666666666800
  000aa	e8 00 00 00 00	 call	 __ftol

; 683  : 		if (i > vuMeterLevels - 1 ) {

  000af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _vuMeterLevels
  000b5	49		 dec	 ecx
  000b6	3b c1		 cmp	 eax, ecx
  000b8	7e 04		 jle	 SHORT $L83875

; 684  : 			i = vuMeterLevels - 1;

  000ba	8b c1		 mov	 eax, ecx

; 685  : 		} else if (i<0) {

  000bc	eb 06		 jmp	 SHORT $L83877
$L83875:
  000be	85 c0		 test	 eax, eax
  000c0	7d 02		 jge	 SHORT $L83877

; 686  : 			i = 0;

  000c2	33 c0		 xor	 eax, eax
$L83877:

; 687  : 		}
; 688  : 		recordingControl->vuMeter = i;

  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _recordingControl

; 689  : 		for (i=0; i<modeFrameSize[codec]; i++) {

  000ca	33 db		 xor	 ebx, ebx
  000cc	89 41 44	 mov	 DWORD PTR [ecx+68], eax
  000cf	39 1e		 cmp	 DWORD PTR [esi], ebx
  000d1	7e 3b		 jle	 SHORT $L83880
  000d3	8b 45 f4	 mov	 eax, DWORD PTR _in$83869[ebp]
  000d6	89 45 f8	 mov	 DWORD PTR -8+[ebp], eax
$L83878:

; 690  : 			gsm_encode(recordingControl->gsmstate, in + i * 160);

  000d9	ff 75 f8	 push	 DWORD PTR -8+[ebp]
  000dc	a1 00 00 00 00	 mov	 eax, DWORD PTR _recordingControl
  000e1	ff 70 3c	 push	 DWORD PTR [eax+60]
  000e4	e8 00 00 00 00	 call	 _gsm_encode

; 691  : 			TlenP2PPacketPackBuffer(packet, recordingControl->gsmstate->gsmFrame, 33);

  000e9	a1 00 00 00 00	 mov	 eax, DWORD PTR _recordingControl
  000ee	6a 21		 push	 33			; 00000021H
  000f0	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  000f3	05 80 06 00 00	 add	 eax, 1664		; 00000680H
  000f8	50		 push	 eax
  000f9	57		 push	 edi
  000fa	e8 00 00 00 00	 call	 _TlenP2PPacketPackBuffer
  000ff	81 45 f8 40 01
	00 00		 add	 DWORD PTR -8+[ebp], 320	; 00000140H
  00106	83 c4 14	 add	 esp, 20			; 00000014H
  00109	43		 inc	 ebx
  0010a	3b 1e		 cmp	 ebx, DWORD PTR [esi]
  0010c	7c cb		 jl	 SHORT $L83878
$L83880:

; 692  : 		}
; 693  : 		TlenVoiceCrypt(packet->packet+4, packet->len-4);

  0010e	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00111	6a 04		 push	 4
  00113	5b		 pop	 ebx
  00114	2b c3		 sub	 eax, ebx
  00116	50		 push	 eax
  00117	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0011a	03 c3		 add	 eax, ebx
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 _TlenVoiceCrypt

; 694  : 		if (!TlenP2PPacketSend(ft->s, packet)) {

  00122	8b 75 08	 mov	 esi, DWORD PTR _ft$[ebp]
  00125	57		 push	 edi
  00126	ff 76 04	 push	 DWORD PTR [esi+4]
  00129	e8 00 00 00 00	 call	 _TlenP2PPacketSend
  0012e	83 c4 10	 add	 esp, 16			; 00000010H
  00131	85 c0		 test	 eax, eax
  00133	75 03		 jne	 SHORT $L83881

; 695  : 			ft->state = FT_ERROR;

  00135	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
$L83881:

; 696  : 		}
; 697  : 		recordingControl->bytesSum  += 8 + packet->len;

  00138	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0013b	a1 00 00 00 00	 mov	 eax, DWORD PTR _recordingControl
  00140	83 c1 08	 add	 ecx, 8

; 698  : 		TlenP2PPacketFree(packet);

  00143	57		 push	 edi
  00144	01 48 48	 add	 DWORD PTR [eax+72], ecx
  00147	e8 00 00 00 00	 call	 _TlenP2PPacketFree
  0014c	59		 pop	 ecx

; 699  : 	} else {

  0014d	eb 0a		 jmp	 SHORT $L83882
$L83868:

; 700  : 		ft->state = FT_ERROR;

  0014f	8b 45 08	 mov	 eax, DWORD PTR _ft$[ebp]
  00152	c7 40 0c 04 00
	00 00		 mov	 DWORD PTR [eax+12], 4
$L83882:
  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	5b		 pop	 ebx

; 701  : 	}
; 702  : }

  0015c	c9		 leave
  0015d	c3		 ret	 0
_TlenVoiceSendParse ENDP
_TEXT	ENDS
PUBLIC	_TlenVoiceCancelAll
PUBLIC	??_C@_0BD@DINM@Closing?5ft?9?$DOs?5?$DN?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BG@CKCO@freeing?5?$CIV?$CJ?5ft?5struct?$AA@ ; `string'
EXTRN	__imp__EndDialog@8:NEAR
EXTRN	_JabberListRemoveByIndex:NEAR
EXTRN	_JabberListFindNext:NEAR
EXTRN	_JabberListGetItemPtrFromIndex:NEAR
;	COMDAT ??_C@_0BD@DINM@Closing?5ft?9?$DOs?5?$DN?5?$CFd?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_netlib.h
_DATA	SEGMENT
??_C@_0BD@DINM@Closing?5ft?9?$DOs?5?$DN?5?$CFd?$AA@ DB 'Closing ft->s = %'
	DB	'd', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@CKCO@freeing?5?$CIV?$CJ?5ft?5struct?$AA@
_DATA	SEGMENT
??_C@_0BG@CKCO@freeing?5?$CIV?$CJ?5ft?5struct?$AA@ DB 'freeing (V) ft str'
	DB	'uct', 00H					; `string'
_DATA	ENDS
;	COMDAT _TlenVoiceCancelAll
_TEXT	SEGMENT
_proto$ = 8
_TlenVoiceCancelAll PROC NEAR				; COMDAT

; 705  : {

  00000	53		 push	 ebx

; 706  : 	JABBER_LIST_ITEM *item;
; 707  : 	HANDLE hEvent;
; 708  : 	int i = 0;
; 709  : 
; 710  : 	while ((i=JabberListFindNext(proto, LIST_VOICE, 0)) >=0 ) {

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _proto$[esp]
  00005	55		 push	 ebp
  00006	33 ed		 xor	 ebp, ebp
  00008	57		 push	 edi
  00009	55		 push	 ebp
  0000a	6a 05		 push	 5
  0000c	53		 push	 ebx
  0000d	e8 00 00 00 00	 call	 _JabberListFindNext
  00012	8b f8		 mov	 edi, eax
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	3b fd		 cmp	 edi, ebp
  00019	0f 8c 97 00 00
	00		 jl	 $L83891
  0001f	56		 push	 esi
$L83890:

; 711  : 		if ((item=JabberListGetItemPtrFromIndex(proto, i)) != NULL) {

  00020	57		 push	 edi
  00021	53		 push	 ebx
  00022	e8 00 00 00 00	 call	 _JabberListGetItemPtrFromIndex
  00027	59		 pop	 ecx
  00028	3b c5		 cmp	 eax, ebp
  0002a	59		 pop	 ecx
  0002b	74 72		 je	 SHORT $L83903

; 712  : 			TLEN_FILE_TRANSFER *ft = item->ft;

  0002d	8b 70 58	 mov	 esi, DWORD PTR [eax+88]

; 713  : 			JabberListRemoveByIndex(proto, i);

  00030	57		 push	 edi
  00031	53		 push	 ebx
  00032	e8 00 00 00 00	 call	 _JabberListRemoveByIndex
  00037	59		 pop	 ecx

; 714  : 			if (ft != NULL) {

  00038	3b f5		 cmp	 esi, ebp
  0003a	59		 pop	 ecx
  0003b	74 62		 je	 SHORT $L83903

; 715  : 				if (ft->s) {

  0003d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00040	3b c5		 cmp	 eax, ebp
  00042	74 42		 je	 SHORT $L83897

; 716  : 					//ProtoBroadcastAck(iface.m_szModuleName, ft->hContact, ACKTYPE_FILE, ACKRESULT_FAILED, ft, 0);
; 717  : 					JabberLog(ft->proto, "Closing ft->s = %d", ft->s);

  00044	50		 push	 eax
  00045	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@DINM@Closing?5ft?9?$DOs?5?$DN?5?$CFd?$AA@ ; `string'
  0004a	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  00050	e8 00 00 00 00	 call	 _JabberLog

; 718  : 					ft->state = FT_ERROR;
; 719  : 					Netlib_CloseHandle(ft->s);

  00055	55		 push	 ebp
  00056	c7 46 0c 04 00
	00 00		 mov	 DWORD PTR [esi+12], 4
  0005d	ff 76 04	 push	 DWORD PTR [esi+4]
  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00065	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@ ; `string'
  0006a	ff 50 24	 call	 DWORD PTR [eax+36]

; 720  : 					ft->s = NULL;
; 721  : 					if (ft->hFileEvent != NULL) {

  0006d	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00070	83 c4 18	 add	 esp, 24			; 00000018H
  00073	3b c5		 cmp	 eax, ebp
  00075	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  00078	74 25		 je	 SHORT $L83903

; 722  : 						hEvent = ft->hFileEvent;
; 723  : 						ft->hFileEvent = NULL;
; 724  : 						SetEvent(hEvent);

  0007a	50		 push	 eax
  0007b	89 6e 3c	 mov	 DWORD PTR [esi+60], ebp
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 725  : 					}
; 726  : 				} else {

  00084	eb 19		 jmp	 SHORT $L83903
$L83897:

; 727  : 					JabberLog(ft->proto, "freeing (V) ft struct");

  00086	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@CKCO@freeing?5?$CIV?$CJ?5ft?5struct?$AA@ ; `string'
  0008b	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  00091	e8 00 00 00 00	 call	 _JabberLog

; 728  : 					TlenP2PFreeFileTransfer(ft);

  00096	56		 push	 esi
  00097	e8 00 00 00 00	 call	 _TlenP2PFreeFileTransfer
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L83903:
  0009f	55		 push	 ebp
  000a0	6a 05		 push	 5
  000a2	53		 push	 ebx
  000a3	e8 00 00 00 00	 call	 _JabberListFindNext
  000a8	8b f8		 mov	 edi, eax
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ad	3b fd		 cmp	 edi, ebp
  000af	0f 8d 6b ff ff
	ff		 jge	 $L83890
  000b5	5e		 pop	 esi
$L83891:

; 729  : 				}
; 730  : 			}
; 731  : 		}
; 732  : 	}
; 733  : 	if (voiceDlgHWND !=NULL) {

  000b6	a1 00 00 00 00	 mov	 eax, DWORD PTR _voiceDlgHWND
  000bb	3b c5		 cmp	 eax, ebp
  000bd	74 08		 je	 SHORT $L83906

; 734  : 		EndDialog(voiceDlgHWND, 0);

  000bf	55		 push	 ebp
  000c0	50		 push	 eax
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8
$L83906:
  000c7	5f		 pop	 edi
  000c8	5d		 pop	 ebp

; 735  : 	}
; 736  : 	return 0;

  000c9	33 c0		 xor	 eax, eax
  000cb	5b		 pop	 ebx

; 737  : }

  000cc	c3		 ret	 0
_TlenVoiceCancelAll ENDP
_TEXT	ENDS
PUBLIC	_TlenVoiceContactMenuHandleVoice
PUBLIC	_TlenVoiceStart
PUBLIC	??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@	; `string'
PUBLIC	??_C@_03HCJC@jid?$AA@				; `string'
PUBLIC	??_C@_02MECO@?$CFd?$AA@				; `string'
PUBLIC	??_C@_0BP@EMAL@?$DMv?5t?$DN?8?$CFs?8?5e?$DN?81?8?5i?$DN?8?$CFs?8?5v?$DN?81?8?1?$DO?$AA@ ; `string'
EXTRN	_JabberListAdd:NEAR
EXTRN	_TlenFileCreateFT:NEAR
EXTRN	_JabberSerialNext:NEAR
;	COMDAT ??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_database.h
_DATA	SEGMENT
??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@ DB 'DB/Contact/FreeVariant', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_03HCJC@jid?$AA@
_DATA	SEGMENT
??_C@_03HCJC@jid?$AA@ DB 'jid', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02MECO@?$CFd?$AA@
_DATA	SEGMENT
??_C@_02MECO@?$CFd?$AA@ DB '%d', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@EMAL@?$DMv?5t?$DN?8?$CFs?8?5e?$DN?81?8?5i?$DN?8?$CFs?8?5v?$DN?81?8?1?$DO?$AA@
_DATA	SEGMENT
??_C@_0BP@EMAL@?$DMv?5t?$DN?8?$CFs?8?5e?$DN?81?8?5i?$DN?8?$CFs?8?5v?$DN?81?8?1?$DO?$AA@ DB '<'
	DB	'v t=''%s'' e=''1'' i=''%s'' v=''1''/>', 00H	; `string'
_DATA	ENDS
;	COMDAT _TlenVoiceContactMenuHandleVoice
_TEXT	SEGMENT
_cgs$84634 = -12
_ptr$ = 8
_wParam$ = 12
_dbv$ = -24
_serialId$83926 = -56
_TlenVoiceContactMenuHandleVoice PROC NEAR		; COMDAT

; 740  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	56		 push	 esi

; 741  : 	HANDLE hContact;
; 742  : 	DBVARIANT dbv;
; 743  : 	JABBER_LIST_ITEM *item;
; 744  : 	TLEN_FILE_TRANSFER *ft;
; 745  :     TlenProtocol *proto =(TlenProtocol *)ptr;
; 746  : 	if (!proto->jabberOnline) {

  00007	8b 75 08	 mov	 esi, DWORD PTR _ptr$[ebp]
  0000a	83 be 78 01 00
	00 00		 cmp	 DWORD PTR [esi+376], 0
  00011	75 08		 jne	 SHORT $L83920

; 747  : 		return 1;

  00013	6a 01		 push	 1
  00015	58		 pop	 eax
  00016	e9 d0 00 00 00	 jmp	 $L83913
$L83920:

; 748  : 	}
; 749  : 	if ((hContact=(HANDLE) wParam)!=NULL) {

  0001b	83 7d 0c 00	 cmp	 DWORD PTR _wParam$[ebp], 0
  0001f	0f 84 c4 00 00
	00		 je	 $L84638

; 750  : 		if (!DBGetContactSetting(hContact, proto->iface.m_szModuleName, "jid", &dbv)) {

  00025	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cgs$84634[ebp+4], OFFSET FLAT:??_C@_03HCJC@jid?$AA@ ; `string'
  0002f	89 45 f4	 mov	 DWORD PTR _cgs$84634[ebp], eax
  00032	8d 45 e8	 lea	 eax, DWORD PTR _dbv$[ebp]
  00035	89 45 fc	 mov	 DWORD PTR _cgs$84634[ebp+8], eax
  00038	8d 45 f4	 lea	 eax, DWORD PTR _cgs$84634[ebp]
  0003b	50		 push	 eax
  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00041	ff 75 0c	 push	 DWORD PTR _wParam$[ebp]
  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@ ; `string'
  00049	ff 50 24	 call	 DWORD PTR [eax+36]
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	85 c0		 test	 eax, eax
  00051	0f 85 92 00 00
	00		 jne	 $L84638
  00057	57		 push	 edi

; 751  : 			char serialId[32];
; 752  : 			sprintf(serialId, "%d", JabberSerialNext(proto));

  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 _JabberSerialNext
  0005e	50		 push	 eax
  0005f	8d 45 c8	 lea	 eax, DWORD PTR _serialId$83926[ebp]
  00062	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@ ; `string'
  00067	50		 push	 eax
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf

; 753  : 			if ((item = JabberListAdd(proto, LIST_VOICE, serialId)) != NULL) {

  0006e	8d 45 c8	 lea	 eax, DWORD PTR _serialId$83926[ebp]
  00071	50		 push	 eax
  00072	6a 05		 push	 5
  00074	56		 push	 esi
  00075	e8 00 00 00 00	 call	 _JabberListAdd
  0007a	8b f8		 mov	 edi, eax
  0007c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0007f	85 ff		 test	 edi, edi
  00081	74 4f		 je	 SHORT $L83929
  00083	53		 push	 ebx

; 754  :                 char *jid = JabberNickFromJID(dbv.pszVal);

  00084	ff 75 ec	 push	 DWORD PTR _dbv$[ebp+4]
  00087	e8 00 00 00 00	 call	 _JabberNickFromJID
  0008c	8b d8		 mov	 ebx, eax

; 755  :                 ft = TlenFileCreateFT(proto, jid);

  0008e	53		 push	 ebx
  0008f	56		 push	 esi
  00090	e8 00 00 00 00	 call	 _TlenFileCreateFT

; 756  :                 mir_free(jid);

  00095	53		 push	 ebx
  00096	8b f0		 mov	 esi, eax
  00098	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12

; 757  : 				ft->iqId = mir_strdup(serialId);

  0009e	8d 45 c8	 lea	 eax, DWORD PTR _serialId$83926[ebp]
  000a1	50		 push	 eax
  000a2	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20

; 758  : 				item->ft = ft;
; 759  : //				JabberSend(ft->proto, "<iq to='%s'><query xmlns='voip'><voip k='1' s='1' v='1' i='51245604'/></query></iq>", ft->jid);
; 760  : //				Sleep(5000);
; 761  : 				TlenVoiceStart(NULL, 2);

  000a8	6a 02		 push	 2
  000aa	89 46 18	 mov	 DWORD PTR [esi+24], eax
  000ad	6a 00		 push	 0
  000af	89 77 58	 mov	 DWORD PTR [edi+88], esi
  000b2	e8 00 00 00 00	 call	 _TlenVoiceStart

; 762  : 				JabberSend(ft->proto, "<v t='%s' e='1' i='%s' v='1'/>", ft->jid, serialId);

  000b7	8d 45 c8	 lea	 eax, DWORD PTR _serialId$83926[ebp]
  000ba	50		 push	 eax
  000bb	ff 76 10	 push	 DWORD PTR [esi+16]
  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@EMAL@?$DMv?5t?$DN?8?$CFs?8?5e?$DN?81?8?5i?$DN?8?$CFs?8?5v?$DN?81?8?1?$DO?$AA@ ; `string'
  000c3	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  000c9	e8 00 00 00 00	 call	 _JabberSend
  000ce	83 c4 2c	 add	 esp, 44			; 0000002cH
  000d1	5b		 pop	 ebx
$L83929:

; 763  : 			}
; 764  : 			DBFreeVariant(&dbv);

  000d2	8d 45 e8	 lea	 eax, DWORD PTR _dbv$[ebp]
  000d5	50		 push	 eax
  000d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  000db	6a 00		 push	 0
  000dd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@ ; `string'
  000e2	ff 50 24	 call	 DWORD PTR [eax+36]
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e8	5f		 pop	 edi
$L84638:

; 765  : 		}
; 766  : 	}
; 767  : 	return 0;

  000e9	33 c0		 xor	 eax, eax
$L83913:
  000eb	5e		 pop	 esi

; 768  : }

  000ec	c9		 leave
  000ed	c3		 ret	 0
_TlenVoiceContactMenuHandleVoice ENDP
_TEXT	ENDS
PUBLIC	_TlenVoiceIsInUse
;	COMDAT _TlenVoiceIsInUse
_TEXT	SEGMENT
_proto$ = 8
_TlenVoiceIsInUse PROC NEAR				; COMDAT

; 771  : 	if (JabberListFindNext(proto, LIST_VOICE, 0) >= 0 || voiceDlgHWND!=NULL) {

  00000	6a 00		 push	 0
  00002	6a 05		 push	 5
  00004	ff 74 24 0c	 push	 DWORD PTR _proto$[esp+4]
  00008	e8 00 00 00 00	 call	 _JabberListFindNext
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00010	85 c0		 test	 eax, eax
  00012	7d 0c		 jge	 SHORT $L83938
  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _voiceDlgHWND, 0
  0001b	75 03		 jne	 SHORT $L83938

; 773  : 	}
; 774  : 	return 0;

  0001d	33 c0		 xor	 eax, eax

; 775  : }

  0001f	c3		 ret	 0
$L83938:

; 772  : 		return 1;

  00020	6a 01		 push	 1
  00022	58		 pop	 eax

; 775  : }

  00023	c3		 ret	 0
_TlenVoiceIsInUse ENDP
_TEXT	ENDS
EXTRN	_JabberForkThread:NEAR
;	COMDAT _TlenVoiceStart
_TEXT	SEGMENT
_ft$ = 8
_mode$ = 12
_TlenVoiceStart PROC NEAR				; COMDAT

; 965  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 966  : 
; 967  : 	if (mode==0) {

  00003	33 c0		 xor	 eax, eax
  00005	39 45 0c	 cmp	 DWORD PTR _mode$[ebp], eax
  00008	75 0b		 jne	 SHORT $L84105

; 968  : 		JabberForkThread((void (__cdecl *)(void*))TlenVoiceReceiveThread, 0, ft);

  0000a	ff 75 08	 push	 DWORD PTR _ft$[ebp]
  0000d	50		 push	 eax
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:_TlenVoiceReceiveThread

; 969  : 	} else if (mode==1) {

  00013	eb 16		 jmp	 SHORT $L84643
$L84105:

; 970  : 		JabberForkThread((void (__cdecl *)(void*))TlenVoiceSendingThread, 0, ft);

  00015	ff 75 08	 push	 DWORD PTR _ft$[ebp]
  00018	83 7d 0c 01	 cmp	 DWORD PTR _mode$[ebp], 1
  0001c	50		 push	 eax
  0001d	75 07		 jne	 SHORT $L84109
  0001f	68 00 00 00 00	 push	 OFFSET FLAT:_TlenVoiceSendingThread

; 971  : 	} else {

  00024	eb 05		 jmp	 SHORT $L84643
$L84109:

; 972  : 		JabberForkThread((void (__cdecl *)(void*))TlenVoiceDlgThread, 0, ft);

  00026	68 00 00 00 00	 push	 OFFSET FLAT:_TlenVoiceDlgThread
$L84643:
  0002b	e8 00 00 00 00	 call	 _JabberForkThread
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 973  : 	}
; 974  : 	return 0;

  00033	33 c0		 xor	 eax, eax

; 975  : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
_TlenVoiceStart ENDP
_TEXT	ENDS
EXTRN	__imp__DialogBoxParamW@20:NEAR
EXTRN	_hInst:DWORD
;	COMDAT _TlenVoiceDlgThread
_TEXT	SEGMENT
_ptr$ = 8
_TlenVoiceDlgThread PROC NEAR				; COMDAT

; 957  :     
; 958  :     TLEN_FILE_TRANSFER *ft = (TLEN_FILE_TRANSFER *)ptr;
; 959  : 	DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_VOICE), NULL, TlenVoiceDlgProc, (LPARAM) NULL);

  00000	6a 00		 push	 0
  00002	68 00 00 00 00	 push	 OFFSET FLAT:_TlenVoiceDlgProc@16
  00007	6a 00		 push	 0
  00009	68 9f 00 00 00	 push	 159			; 0000009fH
  0000e	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20

; 960  : 	voiceDlgHWND = NULL;
; 961  : 	TlenVoiceCancelAll(ft->proto);

  0001a	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  0001e	83 25 00 00 00
	00 00		 and	 DWORD PTR _voiceDlgHWND, 0
  00025	ff b0 7c 02 00
	00		 push	 DWORD PTR [eax+636]
  0002b	e8 00 00 00 00	 call	 _TlenVoiceCancelAll
  00030	59		 pop	 ecx

; 962  : }

  00031	c3		 ret	 0
_TlenVoiceDlgThread ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CI@MBGJ@?$AA8?$AA0?$AA0?$AA0?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA1?$AA3?$AA?4?$AA8?$AA?5?$AAk?$AAb?$AAp?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@BJKM@?$AA1?$AA1?$AA0?$AA2?$AA5?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA1?$AA9?$AA?4?$AA1?$AA?5?$AAk?$AAb?$AAp?$AAs@ ; `string'
PUBLIC	??_C@_1CK@CJED@?$AA2?$AA2?$AA0?$AA5?$AA0?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA3?$AA6?$AA?4?$AA8?$AA?5?$AAk?$AAb?$AAp?$AAs@ ; `string'
PUBLIC	??_C@_1CG@NCHG@?$AA4?$AA4?$AA1?$AA0?$AA0?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA7?$AA2?$AA?5?$AAk?$AAb?$AAp?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@FBJM@?$AA?4?$AA?4?$AA?4?$AA?$DP?$AA?$DP?$AA?$DP?$AA?4?$AA?4?$AA?4?$AA?$AA@ ; `string'
PUBLIC	??_C@_09PMKM@?$CF?41f?5kB?1s?$AA@		; `string'
PUBLIC	__real@4@3ff58000000000000000
EXTRN	__imp__GetDlgItem@8:NEAR
EXTRN	__imp__CheckDlgButton@12:NEAR
EXTRN	__imp__BitBlt@36:NEAR
EXTRN	__imp__IsDlgButtonChecked@8:NEAR
EXTRN	__imp__SendDlgItemMessageW@20:NEAR
EXTRN	__imp__CreateCompatibleDC@4:NEAR
EXTRN	__imp__GetDC@4:NEAR
EXTRN	__imp__ReleaseDC@8:NEAR
EXTRN	__imp__DeleteDC@4:NEAR
EXTRN	_tlenIcons:BYTE
EXTRN	__imp__SelectObject@8:NEAR
EXTRN	__imp__SetTimer@16:NEAR
_BSS	SEGMENT
_?counter@?1??TlenVoiceDlgProc@@9@9 DD 01H DUP (?)
_vuMeterBitmaps DD 064H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_1CI@MBGJ@?$AA8?$AA0?$AA0?$AA0?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA1?$AA3?$AA?4?$AA8?$AA?5?$AAk?$AAb?$AAp?$AAs?$AA?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_langpack.h
_DATA	SEGMENT
??_C@_1CI@MBGJ@?$AA8?$AA0?$AA0?$AA0?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA1?$AA3?$AA?4?$AA8?$AA?5?$AAk?$AAb?$AAp?$AAs?$AA?$AA@ DB '8'
	DB	00H, '0', 00H, '0', 00H, '0', 00H, ' ', 00H, 'H', 00H, 'z', 00H
	DB	' ', 00H, '/', 00H, ' ', 00H, '1', 00H, '3', 00H, '.', 00H, '8'
	DB	00H, ' ', 00H, 'k', 00H, 'b', 00H, 'p', 00H, 's', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_1CK@BJKM@?$AA1?$AA1?$AA0?$AA2?$AA5?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA1?$AA9?$AA?4?$AA1?$AA?5?$AAk?$AAb?$AAp?$AAs@
_DATA	SEGMENT
??_C@_1CK@BJKM@?$AA1?$AA1?$AA0?$AA2?$AA5?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA1?$AA9?$AA?4?$AA1?$AA?5?$AAk?$AAb?$AAp?$AAs@ DB '1'
	DB	00H, '1', 00H, '0', 00H, '2', 00H, '5', 00H, ' ', 00H, 'H', 00H
	DB	'z', 00H, ' ', 00H, '/', 00H, ' ', 00H, '1', 00H, '9', 00H, '.'
	DB	00H, '1', 00H, ' ', 00H, 'k', 00H, 'b', 00H, 'p', 00H, 's', 00H
	DB	00H, 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_1CK@CJED@?$AA2?$AA2?$AA0?$AA5?$AA0?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA3?$AA6?$AA?4?$AA8?$AA?5?$AAk?$AAb?$AAp?$AAs@
_DATA	SEGMENT
??_C@_1CK@CJED@?$AA2?$AA2?$AA0?$AA5?$AA0?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA3?$AA6?$AA?4?$AA8?$AA?5?$AAk?$AAb?$AAp?$AAs@ DB '2'
	DB	00H, '2', 00H, '0', 00H, '5', 00H, '0', 00H, ' ', 00H, 'H', 00H
	DB	'z', 00H, ' ', 00H, '/', 00H, ' ', 00H, '3', 00H, '6', 00H, '.'
	DB	00H, '8', 00H, ' ', 00H, 'k', 00H, 'b', 00H, 'p', 00H, 's', 00H
	DB	00H, 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_1CG@NCHG@?$AA4?$AA4?$AA1?$AA0?$AA0?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA7?$AA2?$AA?5?$AAk?$AAb?$AAp?$AAs?$AA?$AA@
_DATA	SEGMENT
??_C@_1CG@NCHG@?$AA4?$AA4?$AA1?$AA0?$AA0?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA7?$AA2?$AA?5?$AAk?$AAb?$AAp?$AAs?$AA?$AA@ DB '4'
	DB	00H, '4', 00H, '1', 00H, '0', 00H, '0', 00H, ' ', 00H, 'H', 00H
	DB	'z', 00H, ' ', 00H, '/', 00H, ' ', 00H, '7', 00H, '2', 00H, ' '
	DB	00H, 'k', 00H, 'b', 00H, 'p', 00H, 's', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_1BE@FBJM@?$AA?4?$AA?4?$AA?4?$AA?$DP?$AA?$DP?$AA?$DP?$AA?4?$AA?4?$AA?4?$AA?$AA@
_DATA	SEGMENT
??_C@_1BE@FBJM@?$AA?4?$AA?4?$AA?4?$AA?$DP?$AA?$DP?$AA?$DP?$AA?4?$AA?4?$AA?4?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '.', 00H, '?', 00H, '?', 00H, '?', 00H, '.', 00H
	DB	'.', 00H, '.', 00H, 00H, 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09PMKM@?$CF?41f?5kB?1s?$AA@
_DATA	SEGMENT
??_C@_09PMKM@?$CF?41f?5kB?1s?$AA@ DB '%.1f kB/s', 00H	; `string'
_DATA	ENDS
;	COMDAT __real@4@3ff58000000000000000
CONST	SEGMENT
__real@4@3ff58000000000000000 DD 03a800000r	; 0.000976563
CONST	ENDS
;	COMDAT _TlenVoiceDlgProc@16
_TEXT	SEGMENT
_hwndDlg$ = 8
_msg$ = 12
_wParam$ = 16
_v$ = 12
_str$84052 = -52
_TlenVoiceDlgProc@16 PROC NEAR				; COMDAT

; 839  : 	HDC hDC, hMemDC;
; 840  : 	int v;
; 841  : 	static int counter;
; 842  : 	switch (msg) {

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _msg$[esp-4]
  00004	83 ec 34	 sub	 esp, 52			; 00000034H
  00007	83 e8 10	 sub	 eax, 16			; 00000010H
  0000a	53		 push	 ebx
  0000b	55		 push	 ebp
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	0f 84 78 04 00
	00		 je	 $L84086
  00014	2d 00 01 00 00	 sub	 eax, 256		; 00000100H
  00019	0f 84 eb 02 00
	00		 je	 $L84013
  0001f	48		 dec	 eax
  00020	0f 84 df 01 00
	00		 je	 $L84063
  00026	48		 dec	 eax
  00027	48		 dec	 eax
  00028	0f 85 6a 04 00
	00		 jne	 $L84010

; 864  : 	case WM_TIMER:
; 865  : 		if (recordingControl != NULL && !recordingControl->bDisable) {

  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _recordingControl
  00034	33 ed		 xor	 ebp, ebp
  00036	3b cd		 cmp	 ecx, ebp
  00038	74 1f		 je	 SHORT $L84038
  0003a	39 69 08	 cmp	 DWORD PTR [ecx+8], ebp
  0003d	75 1a		 jne	 SHORT $L84038

; 866  : 			v = recordingControl->vuMeter % vuMeterLevels;

  0003f	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  00042	8b c6		 mov	 eax, esi
  00044	99		 cdq
  00045	f7 3d 00 00 00
	00		 idiv	 DWORD PTR _vuMeterLevels

; 867  : 			if (recordingControl->vuMeter >0) {

  0004b	3b f5		 cmp	 esi, ebp
  0004d	89 54 24 4c	 mov	 DWORD PTR _v$[esp+64], edx
  00051	7e 0a		 jle	 SHORT $L84040

; 868  : 				recordingControl->vuMeter--;

  00053	4e		 dec	 esi
  00054	89 71 44	 mov	 DWORD PTR [ecx+68], esi

; 869  : 			}
; 870  : 		} else {

  00057	eb 04		 jmp	 SHORT $L84040
$L84038:

; 871  : 			v = 0;

  00059	89 6c 24 4c	 mov	 DWORD PTR _v$[esp+64], ebp
$L84040:

; 872  : 		}
; 873  : 		hDC = GetDC(GetDlgItem(hwndDlg, IDC_VUMETERIN));

  0005d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  00063	68 4d 04 00 00	 push	 1101			; 0000044dH
  00068	ff 74 24 4c	 push	 DWORD PTR _hwndDlg$[esp+68]
  0006c	ff d6		 call	 esi
  0006e	50		 push	 eax
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  00075	8b d8		 mov	 ebx, eax

; 874  : 		if (NULL != (hMemDC = CreateCompatibleDC( hDC ))) {

  00077	53		 push	 ebx
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  0007e	8b f8		 mov	 edi, eax
  00080	3b fd		 cmp	 edi, ebp
  00082	74 36		 je	 SHORT $L84042

; 875  : 			SelectObject( hMemDC, vuMeterBitmaps[v]) ;

  00084	8b 44 24 4c	 mov	 eax, DWORD PTR _v$[esp+64]
  00088	ff 34 85 00 00
	00 00		 push	 DWORD PTR _vuMeterBitmaps[eax*4]
  0008f	57		 push	 edi
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 876  : 			BitBlt( hDC, 0, 0, vuMeterWidth, vuMeterHeight, hMemDC, 0, 0, SRCCOPY ) ;

  00096	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  0009b	55		 push	 ebp
  0009c	55		 push	 ebp
  0009d	57		 push	 edi
  0009e	ff 35 00 00 00
	00		 push	 DWORD PTR _vuMeterHeight
  000a4	ff 35 00 00 00
	00		 push	 DWORD PTR _vuMeterWidth
  000aa	55		 push	 ebp
  000ab	55		 push	 ebp
  000ac	53		 push	 ebx
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 877  : 			DeleteDC(hMemDC);

  000b3	57		 push	 edi
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
$L84042:

; 878  : 		}
; 879  : 		ReleaseDC(GetDlgItem(hwndDlg, IDC_PLAN), hDC);

  000ba	53		 push	 ebx
  000bb	68 87 05 00 00	 push	 1415			; 00000587H
  000c0	ff 74 24 50	 push	 DWORD PTR _hwndDlg$[esp+72]
  000c4	ff d6		 call	 esi
  000c6	50		 push	 eax
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 880  : 		if (playbackControl != NULL  && !playbackControl->bDisable) {

  000cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _playbackControl
  000d3	3b cd		 cmp	 ecx, ebp
  000d5	74 1f		 je	 SHORT $L84045
  000d7	39 69 08	 cmp	 DWORD PTR [ecx+8], ebp
  000da	75 1a		 jne	 SHORT $L84045

; 881  : 			v = playbackControl->vuMeter % vuMeterLevels;

  000dc	8b 79 44	 mov	 edi, DWORD PTR [ecx+68]
  000df	8b c7		 mov	 eax, edi
  000e1	99		 cdq
  000e2	f7 3d 00 00 00
	00		 idiv	 DWORD PTR _vuMeterLevels

; 882  : 			if (playbackControl->vuMeter >0) {

  000e8	3b fd		 cmp	 edi, ebp
  000ea	89 54 24 4c	 mov	 DWORD PTR _v$[esp+64], edx
  000ee	7e 0a		 jle	 SHORT $L84047

; 883  : 				playbackControl->vuMeter--;

  000f0	4f		 dec	 edi
  000f1	89 79 44	 mov	 DWORD PTR [ecx+68], edi

; 884  : 			}
; 885  : 		} else {

  000f4	eb 04		 jmp	 SHORT $L84047
$L84045:

; 886  : 			v = 0;

  000f6	89 6c 24 4c	 mov	 DWORD PTR _v$[esp+64], ebp
$L84047:

; 887  : 		}
; 888  : 		hDC = GetDC(GetDlgItem(hwndDlg, IDC_VUMETEROUT));

  000fa	68 4e 04 00 00	 push	 1102			; 0000044eH
  000ff	ff 74 24 4c	 push	 DWORD PTR _hwndDlg$[esp+68]
  00103	ff d6		 call	 esi
  00105	50		 push	 eax
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  0010c	8b d8		 mov	 ebx, eax

; 889  : 		if (NULL != (hMemDC = CreateCompatibleDC( hDC ))) {

  0010e	53		 push	 ebx
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  00115	8b f8		 mov	 edi, eax
  00117	3b fd		 cmp	 edi, ebp
  00119	74 36		 je	 SHORT $L84049

; 890  : 			SelectObject( hMemDC, vuMeterBitmaps[v]) ;

  0011b	8b 44 24 4c	 mov	 eax, DWORD PTR _v$[esp+64]
  0011f	ff 34 85 00 00
	00 00		 push	 DWORD PTR _vuMeterBitmaps[eax*4]
  00126	57		 push	 edi
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8

; 891  : 			BitBlt( hDC, 0, 0, vuMeterWidth, vuMeterHeight, hMemDC, 0, 0, SRCCOPY ) ;

  0012d	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  00132	55		 push	 ebp
  00133	55		 push	 ebp
  00134	57		 push	 edi
  00135	ff 35 00 00 00
	00		 push	 DWORD PTR _vuMeterHeight
  0013b	ff 35 00 00 00
	00		 push	 DWORD PTR _vuMeterWidth
  00141	55		 push	 ebp
  00142	55		 push	 ebp
  00143	53		 push	 ebx
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36

; 892  : 			DeleteDC(hMemDC);

  0014a	57		 push	 edi
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
$L84049:

; 893  : 		}
; 894  : 		ReleaseDC(GetDlgItem(hwndDlg, IDC_PLAN), hDC);

  00151	53		 push	 ebx
  00152	68 87 05 00 00	 push	 1415			; 00000587H
  00157	ff 74 24 50	 push	 DWORD PTR _hwndDlg$[esp+72]
  0015b	ff d6		 call	 esi
  0015d	50		 push	 eax
  0015e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 895  : 		counter ++;

  00164	ff 05 00 00 00
	00		 inc	 DWORD PTR _?counter@?1??TlenVoiceDlgProc@@9@9

; 896  : 		if (counter %10 == 0) {

  0016a	a1 00 00 00 00	 mov	 eax, DWORD PTR _?counter@?1??TlenVoiceDlgProc@@9@9
  0016f	6a 0a		 push	 10			; 0000000aH
  00171	99		 cdq
  00172	59		 pop	 ecx
  00173	f7 f9		 idiv	 ecx
  00175	85 d2		 test	 edx, edx
  00177	0f 85 1b 03 00
	00		 jne	 $L84010

; 897  : 			char str[50];
; 898  : 			float fv;
; 899  : 			if (recordingControl != NULL) {

  0017d	a1 00 00 00 00	 mov	 eax, DWORD PTR _recordingControl
  00182	3b c5		 cmp	 eax, ebp
  00184	74 08		 je	 SHORT $L84055

; 900  : 				fv = (float)recordingControl->bytesSum;

  00186	db 40 48	 fild	 DWORD PTR [eax+72]

; 901  : 				recordingControl->bytesSum = 0;

  00189	89 68 48	 mov	 DWORD PTR [eax+72], ebp

; 902  : 			} else {

  0018c	eb 02		 jmp	 SHORT $L84057
$L84055:

; 903  : 				fv = 0;

  0018e	d9 ee		 fldz
$L84057:

; 904  : 			}
; 905  : 			sprintf(str, "%.1f kB/s", fv / 1024);

  00190	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@4@3ff58000000000000000
  00196	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__sprintf
  0019c	51		 push	 ecx
  0019d	51		 push	 ecx
  0019e	bb 00 00 00 00	 mov	 ebx, OFFSET FLAT:??_C@_09PMKM@?$CF?41f?5kB?1s?$AA@ ; `string'
  001a3	8d 44 24 18	 lea	 eax, DWORD PTR _str$84052[esp+76]
  001a7	dd 1c 24	 fstp	 QWORD PTR [esp]
  001aa	53		 push	 ebx
  001ab	50		 push	 eax
  001ac	ff d6		 call	 esi

; 906  : 			SetDlgItemTextA(hwndDlg, IDC_BYTESOUT, str);

  001ae	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetDlgItemTextA@12
  001b4	83 c4 10	 add	 esp, 16			; 00000010H
  001b7	8d 44 24 10	 lea	 eax, DWORD PTR _str$84052[esp+68]
  001bb	50		 push	 eax
  001bc	68 50 04 00 00	 push	 1104			; 00000450H
  001c1	ff 74 24 50	 push	 DWORD PTR _hwndDlg$[esp+72]
  001c5	ff d7		 call	 edi

; 907  : 			if (playbackControl != NULL) {

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _playbackControl
  001cc	3b c5		 cmp	 eax, ebp
  001ce	74 08		 je	 SHORT $L84060

; 908  : 				fv = (float)playbackControl->bytesSum;

  001d0	db 40 48	 fild	 DWORD PTR [eax+72]

; 909  : 				playbackControl->bytesSum = 0;

  001d3	89 68 48	 mov	 DWORD PTR [eax+72], ebp

; 910  : 			} else {

  001d6	eb 02		 jmp	 SHORT $L84062
$L84060:

; 911  : 				fv = 0;

  001d8	d9 ee		 fldz
$L84062:

; 912  : 			}
; 913  : 			sprintf(str, "%.1f kB/s", fv / 1024);

  001da	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@4@3ff58000000000000000
  001e0	51		 push	 ecx
  001e1	51		 push	 ecx
  001e2	8d 44 24 18	 lea	 eax, DWORD PTR _str$84052[esp+76]
  001e6	dd 1c 24	 fstp	 QWORD PTR [esp]
  001e9	53		 push	 ebx
  001ea	50		 push	 eax
  001eb	ff d6		 call	 esi
  001ed	83 c4 10	 add	 esp, 16			; 00000010H

; 914  : 			SetDlgItemTextA(hwndDlg, IDC_BYTESIN, str);

  001f0	8d 44 24 10	 lea	 eax, DWORD PTR _str$84052[esp+68]
  001f4	50		 push	 eax
  001f5	68 4f 04 00 00	 push	 1103			; 0000044fH
  001fa	ff 74 24 50	 push	 DWORD PTR _hwndDlg$[esp+72]
  001fe	ff d7		 call	 edi

; 915  : 		}
; 916  : 		break;

  00200	e9 93 02 00 00	 jmp	 $L84010
$L84063:

; 917  : 	case WM_COMMAND:
; 918  : 		switch (LOWORD(wParam)) {

  00205	8b 4c 24 50	 mov	 ecx, DWORD PTR _wParam$[esp+64]
  00209	0f b7 c1	 movzx	 eax, cx
  0020c	48		 dec	 eax
  0020d	48		 dec	 eax
  0020e	0f 84 e2 00 00
	00		 je	 $L84070
  00214	2d 4a 04 00 00	 sub	 eax, 1098		; 0000044aH
  00219	74 3f		 je	 SHORT $L84071
  0021b	83 e8 05	 sub	 eax, 5
  0021e	0f 84 a6 00 00
	00		 je	 $L84650
  00224	48		 dec	 eax
  00225	0f 85 6d 02 00
	00		 jne	 $L84010

; 939  : 			}
; 940  : 			break;
; 941  : 		case IDC_SPEAKER:
; 942  : 			if (playbackControl!=NULL) {

  0022b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _playbackControl, 0
  00232	0f 84 60 02 00
	00		 je	 $L84010

; 943  : 				playbackControl->bDisable = !IsDlgButtonChecked(hwndDlg, IDC_SPEAKER);

  00238	68 52 04 00 00	 push	 1106			; 00000452H
  0023d	ff 74 24 4c	 push	 DWORD PTR _hwndDlg$[esp+68]
  00241	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDlgButtonChecked@8
  00247	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _playbackControl
  0024d	f7 d8		 neg	 eax
  0024f	1b c0		 sbb	 eax, eax
  00251	40		 inc	 eax
$L84651:
  00252	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 944  : 			}
; 945  : 			break;

  00255	e9 3e 02 00 00	 jmp	 $L84010
$L84071:

; 922  : 		case IDC_VCQUALITY:
; 923  : 			if (HIWORD(wParam)==CBN_SELCHANGE) {

  0025a	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0025d	66 83 f9 01	 cmp	 cx, 1
  00261	75 67		 jne	 SHORT $L84650

; 924  : 				if (recordingControl!=NULL) {

  00263	33 c0		 xor	 eax, eax
  00265	39 05 00 00 00
	00		 cmp	 DWORD PTR _recordingControl, eax
  0026b	0f 84 27 02 00
	00		 je	 $L84010

; 925  : 					int codec;
; 926  : 					codec = SendDlgItemMessage(hwndDlg, IDC_VCQUALITY, CB_GETCURSEL, 0, 0) + 2;

  00271	50		 push	 eax
  00272	50		 push	 eax
  00273	68 47 01 00 00	 push	 327			; 00000147H
  00278	68 4c 04 00 00	 push	 1100			; 0000044cH
  0027d	ff 74 24 58	 push	 DWORD PTR _hwndDlg$[esp+80]
  00281	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendDlgItemMessageW@20
  00287	8b f0		 mov	 esi, eax

; 927  : 					if (codec!=recordingControl->codec && codec>1 && codec<6) {

  00289	a1 00 00 00 00	 mov	 eax, DWORD PTR _recordingControl
  0028e	46		 inc	 esi
  0028f	46		 inc	 esi
  00290	3b 70 04	 cmp	 esi, DWORD PTR [eax+4]
  00293	74 3a		 je	 SHORT $L84078
  00295	83 fe 01	 cmp	 esi, 1
  00298	7e 35		 jle	 SHORT $L84078
  0029a	83 fe 06	 cmp	 esi, 6
  0029d	7d 30		 jge	 SHORT $L84078

; 928  : 						TLEN_FILE_TRANSFER *ft = recordingControl->ft;

  0029f	8b 78 40	 mov	 edi, DWORD PTR [eax+64]

; 929  : 						TlenVoiceFreeVc(recordingControl);

  002a2	50		 push	 eax
  002a3	e8 00 00 00 00	 call	 _TlenVoiceFreeVc

; 930  : 						recordingControl = TlenVoiceCreateVC(ft->proto, codec);

  002a8	56		 push	 esi
  002a9	ff b7 7c 02 00
	00		 push	 DWORD PTR [edi+636]
  002af	e8 00 00 00 00	 call	 _TlenVoiceCreateVC
  002b4	a3 00 00 00 00	 mov	 DWORD PTR _recordingControl, eax

; 931  : 						recordingControl->ft = ft;

  002b9	89 78 40	 mov	 DWORD PTR [eax+64], edi

; 932  : 						TlenVoiceRecordingStart(recordingControl);

  002bc	ff 35 00 00 00
	00		 push	 DWORD PTR _recordingControl
  002c2	e8 00 00 00 00	 call	 _TlenVoiceRecordingStart
  002c7	83 c4 10	 add	 esp, 16			; 00000010H
$L84650:
  002ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _recordingControl
$L84078:

; 933  : 					}
; 934  : 				}
; 935  : 			}
; 936  : 		case IDC_MICROPHONE:
; 937  : 			if (recordingControl!=NULL) {

  002cf	85 c0		 test	 eax, eax
  002d1	0f 84 c1 01 00
	00		 je	 $L84010

; 938  : 				recordingControl->bDisable = !IsDlgButtonChecked(hwndDlg, IDC_MICROPHONE);

  002d7	68 51 04 00 00	 push	 1105			; 00000451H
  002dc	ff 74 24 4c	 push	 DWORD PTR _hwndDlg$[esp+68]
  002e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDlgButtonChecked@8
  002e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _recordingControl
  002ec	f7 d8		 neg	 eax
  002ee	1b c0		 sbb	 eax, eax
  002f0	40		 inc	 eax

; 946  : 		}
; 947  : 		break;

  002f1	e9 5c ff ff ff	 jmp	 $L84651
$L84070:

; 919  : 		case IDCANCEL:
; 920  : 			EndDialog(hwndDlg, 0);

  002f6	6a 00		 push	 0
  002f8	ff 74 24 4c	 push	 DWORD PTR _hwndDlg$[esp+68]
  002fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8

; 921  : 			return TRUE;

  00302	6a 01		 push	 1
  00304	58		 pop	 eax
  00305	e9 90 01 00 00	 jmp	 $L84003
$L84013:

; 843  : 	case WM_INITDIALOG:
; 844  : 		voiceDlgHWND = hwndDlg;

  0030a	8b 7c 24 48	 mov	 edi, DWORD PTR _hwndDlg$[esp+64]

; 845  : 		TranslateDialogDefault(hwndDlg);

  0030e	57		 push	 edi
  0030f	89 3d 00 00 00
	00		 mov	 DWORD PTR _voiceDlgHWND, edi
  00315	e8 00 00 00 00	 call	 _TranslateDialogDefault

; 846  : 		SendDlgItemMessage(hwndDlg, IDC_VCQUALITY, CB_ADDSTRING, 0, (LPARAM) TranslateT("8000 Hz / 13.8 kbps"));

  0031a	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0031f	bd 00 10 00 00	 mov	 ebp, 4096		; 00001000H
  00324	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET FLAT:??_C@_1CI@MBGJ@?$AA8?$AA0?$AA0?$AA0?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA1?$AA3?$AA?4?$AA8?$AA?5?$AAk?$AAb?$AAp?$AAs?$AA?$AA@ ; `string'
  0032b	bb 00 00 00 00	 mov	 ebx, OFFSET FLAT:??_C@_0BJ@MKNL@LangPack?1TranslateString?$AA@ ; `string'
  00330	55		 push	 ebp
  00331	53		 push	 ebx
  00332	ff 50 24	 call	 DWORD PTR [eax+36]
  00335	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendDlgItemMessageW@20
  0033b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0033e	50		 push	 eax
  0033f	6a 00		 push	 0
  00341	68 43 01 00 00	 push	 323			; 00000143H
  00346	68 4c 04 00 00	 push	 1100			; 0000044cH
  0034b	57		 push	 edi
  0034c	ff d6		 call	 esi

; 847  : 		SendDlgItemMessage(hwndDlg, IDC_VCQUALITY, CB_ADDSTRING, 0, (LPARAM) TranslateT("11025 Hz / 19.1 kbps"));

  0034e	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00353	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CK@BJKM@?$AA1?$AA1?$AA0?$AA2?$AA5?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA1?$AA9?$AA?4?$AA1?$AA?5?$AAk?$AAb?$AAp?$AAs@ ; `string'
  00358	55		 push	 ebp
  00359	53		 push	 ebx
  0035a	ff 50 24	 call	 DWORD PTR [eax+36]
  0035d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00360	50		 push	 eax
  00361	6a 00		 push	 0
  00363	68 43 01 00 00	 push	 323			; 00000143H
  00368	68 4c 04 00 00	 push	 1100			; 0000044cH
  0036d	57		 push	 edi
  0036e	ff d6		 call	 esi

; 848  : 		SendDlgItemMessage(hwndDlg, IDC_VCQUALITY, CB_ADDSTRING, 0, (LPARAM) TranslateT("22050 Hz / 36.8 kbps"));

  00370	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00375	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CK@CJED@?$AA2?$AA2?$AA0?$AA5?$AA0?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA3?$AA6?$AA?4?$AA8?$AA?5?$AAk?$AAb?$AAp?$AAs@ ; `string'
  0037a	55		 push	 ebp
  0037b	53		 push	 ebx
  0037c	ff 50 24	 call	 DWORD PTR [eax+36]
  0037f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00382	50		 push	 eax
  00383	6a 00		 push	 0
  00385	68 43 01 00 00	 push	 323			; 00000143H
  0038a	68 4c 04 00 00	 push	 1100			; 0000044cH
  0038f	57		 push	 edi
  00390	ff d6		 call	 esi

; 849  : 		SendDlgItemMessage(hwndDlg, IDC_VCQUALITY, CB_ADDSTRING, 0, (LPARAM) TranslateT("44100 Hz / 72 kbps"));

  00392	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00397	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CG@NCHG@?$AA4?$AA4?$AA1?$AA0?$AA0?$AA?5?$AAH?$AAz?$AA?5?$AA?1?$AA?5?$AA7?$AA2?$AA?5?$AAk?$AAb?$AAp?$AAs?$AA?$AA@ ; `string'
  0039c	55		 push	 ebp
  0039d	53		 push	 ebx
  0039e	ff 50 24	 call	 DWORD PTR [eax+36]
  003a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a4	50		 push	 eax
  003a5	6a 00		 push	 0
  003a7	68 43 01 00 00	 push	 323			; 00000143H
  003ac	68 4c 04 00 00	 push	 1100			; 0000044cH
  003b1	57		 push	 edi
  003b2	ff d6		 call	 esi

; 850  : 		SendDlgItemMessage(hwndDlg, IDC_VCQUALITY, CB_SETCURSEL, 1, 0);

  003b4	6a 00		 push	 0
  003b6	6a 01		 push	 1
  003b8	68 4e 01 00 00	 push	 334			; 0000014eH
  003bd	68 4c 04 00 00	 push	 1100			; 0000044cH
  003c2	57		 push	 edi
  003c3	ff d6		 call	 esi

; 851  : 		SendDlgItemMessage(hwndDlg, IDC_MICROPHONE, BUTTONSETASFLATBTN, 0, 0);

  003c5	6a 00		 push	 0
  003c7	6a 00		 push	 0
  003c9	68 04 04 00 00	 push	 1028			; 00000404H
  003ce	68 51 04 00 00	 push	 1105			; 00000451H
  003d3	57		 push	 edi
  003d4	ff d6		 call	 esi

; 852  : 		SendDlgItemMessage(hwndDlg, IDC_SPEAKER, BUTTONSETASFLATBTN, 0, 0);

  003d6	6a 00		 push	 0
  003d8	6a 00		 push	 0
  003da	68 04 04 00 00	 push	 1028			; 00000404H
  003df	68 52 04 00 00	 push	 1106			; 00000452H
  003e4	57		 push	 edi
  003e5	ff d6		 call	 esi

; 853  : 		SendDlgItemMessage(hwndDlg, IDC_MICROPHONE, BUTTONSETASPUSHBTN, 0, 0);

  003e7	6a 00		 push	 0
  003e9	6a 00		 push	 0
  003eb	68 03 04 00 00	 push	 1027			; 00000403H
  003f0	68 51 04 00 00	 push	 1105			; 00000451H
  003f5	57		 push	 edi
  003f6	ff d6		 call	 esi

; 854  : 		SendDlgItemMessage(hwndDlg, IDC_SPEAKER, BUTTONSETASPUSHBTN, 0, 0);

  003f8	6a 00		 push	 0
  003fa	6a 00		 push	 0
  003fc	68 03 04 00 00	 push	 1027			; 00000403H
  00401	68 52 04 00 00	 push	 1106			; 00000452H
  00406	57		 push	 edi
  00407	ff d6		 call	 esi

; 855  : 		SendDlgItemMessage(hwndDlg, IDC_MICROPHONE, BM_SETIMAGE, IMAGE_ICON, (LPARAM) tlenIcons[TLEN_IDI_MICROPHONE]);

  00409	ff 35 1c 00 00
	00		 push	 DWORD PTR _tlenIcons+28
  0040f	6a 01		 push	 1
  00411	68 f7 00 00 00	 push	 247			; 000000f7H
  00416	68 51 04 00 00	 push	 1105			; 00000451H
  0041b	57		 push	 edi
  0041c	ff d6		 call	 esi

; 856  : 		SendDlgItemMessage(hwndDlg, IDC_SPEAKER, BM_SETIMAGE, IMAGE_ICON, (LPARAM) tlenIcons[TLEN_IDI_SPEAKER]);

  0041e	ff 35 20 00 00
	00		 push	 DWORD PTR _tlenIcons+32
  00424	6a 01		 push	 1
  00426	68 f7 00 00 00	 push	 247			; 000000f7H
  0042b	68 52 04 00 00	 push	 1106			; 00000452H
  00430	57		 push	 edi
  00431	ff d6		 call	 esi

; 857  : 		CheckDlgButton(hwndDlg, IDC_MICROPHONE, TRUE);

  00433	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CheckDlgButton@12
  00439	6a 01		 push	 1
  0043b	68 51 04 00 00	 push	 1105			; 00000451H
  00440	57		 push	 edi
  00441	ff d6		 call	 esi

; 858  : 		CheckDlgButton(hwndDlg, IDC_SPEAKER, TRUE);

  00443	6a 01		 push	 1
  00445	68 52 04 00 00	 push	 1106			; 00000452H
  0044a	57		 push	 edi
  0044b	ff d6		 call	 esi

; 859  : 		TlenVoiceInitVUMeters();

  0044d	e8 00 00 00 00	 call	 _TlenVoiceInitVUMeters

; 860  : 		SetDlgItemText(voiceDlgHWND, IDC_STATUS, TranslateT("...???..."));

  00452	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00457	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@FBJM@?$AA?4?$AA?4?$AA?4?$AA?$DP?$AA?$DP?$AA?$DP?$AA?4?$AA?4?$AA?4?$AA?$AA@ ; `string'
  0045c	55		 push	 ebp
  0045d	53		 push	 ebx
  0045e	ff 50 24	 call	 DWORD PTR [eax+36]
  00461	83 c4 0c	 add	 esp, 12			; 0000000cH
  00464	50		 push	 eax
  00465	68 86 05 00 00	 push	 1414			; 00000586H
  0046a	ff 35 00 00 00
	00		 push	 DWORD PTR _voiceDlgHWND
  00470	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemTextW@12

; 861  : 		counter = 0;

  00476	83 25 00 00 00
	00 00		 and	 DWORD PTR _?counter@?1??TlenVoiceDlgProc@@9@9, 0

; 862  : 		SetTimer(hwndDlg, 1, 100, NULL);

  0047d	6a 00		 push	 0
  0047f	6a 64		 push	 100			; 00000064H
  00481	6a 01		 push	 1
  00483	57		 push	 edi
  00484	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 863  : 		return FALSE;

  0048a	eb 0c		 jmp	 SHORT $L84010
$L84086:

; 948  : 	case WM_CLOSE:
; 949  : 		EndDialog(hwndDlg, 0);

  0048c	6a 00		 push	 0
  0048e	ff 74 24 4c	 push	 DWORD PTR _hwndDlg$[esp+68]
  00492	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8
$L84010:

; 950  : 		break;
; 951  : 	}
; 952  : 	return FALSE;

  00498	33 c0		 xor	 eax, eax
$L84003:
  0049a	5f		 pop	 edi
  0049b	5e		 pop	 esi
  0049c	5d		 pop	 ebp
  0049d	5b		 pop	 ebx

; 953  : }

  0049e	83 c4 34	 add	 esp, 52			; 00000034H
  004a1	c2 10 00	 ret	 16			; 00000010H
_TlenVoiceDlgProc@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GNEH@LangPack?1TranslateDialog?$AA@	; `string'
;	COMDAT ??_C@_0BJ@GNEH@LangPack?1TranslateDialog?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_langpack.h
_DATA	SEGMENT
??_C@_0BJ@GNEH@LangPack?1TranslateDialog?$AA@ DB 'LangPack/TranslateDialo'
	DB	'g', 00H					; `string'
_DATA	ENDS
;	COMDAT _TranslateDialogDefault
_TEXT	SEGMENT
_hwndDlg$ = 8
_lptd$ = -16
_TranslateDialogDefault PROC NEAR			; COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 82   : 	LANGPACKTRANSLATEDIALOG lptd;
; 83   : 	lptd.cbSize=sizeof(lptd);
; 84   : 	lptd.flags=0;
; 85   : 	lptd.hwndDlg=hwndDlg;

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _hwndDlg$[ebp]
  00009	33 c0		 xor	 eax, eax
  0000b	89 4d f8	 mov	 DWORD PTR _lptd$[ebp+8], ecx

; 86   : 	lptd.ignoreControls=NULL;
; 87   : 	return CallService(MS_LANGPACK_TRANSLATEDIALOG,0,(LPARAM)&lptd);

  0000e	8d 4d f0	 lea	 ecx, DWORD PTR _lptd$[ebp]
  00011	51		 push	 ecx
  00012	89 45 f4	 mov	 DWORD PTR _lptd$[ebp+4], eax
  00015	89 45 fc	 mov	 DWORD PTR _lptd$[ebp+12], eax
  00018	50		 push	 eax
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@GNEH@LangPack?1TranslateDialog?$AA@ ; `string'
  00023	c7 45 f0 10 00
	00 00		 mov	 DWORD PTR _lptd$[ebp], 16 ; 00000010H
  0002a	ff 50 24	 call	 DWORD PTR [eax+36]
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 88   : }

  00030	c9		 leave
  00031	c3		 ret	 0
_TranslateDialogDefault ENDP
_TEXT	ENDS
;	COMDAT _TlenVoiceInitVUMeters
_TEXT	SEGMENT
_i$ = -16
_v$ = -12
_y$ = -8
_TlenVoiceInitVUMeters PROC NEAR			; COMDAT

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 801  : 	int i, v, y, x, x0, col, col0;
; 802  : 	unsigned char *pBits;
; 803  : 	int ledWidth, ledHeight;
; 804  : 	ledWidth = 9;
; 805  : 	ledHeight = 6;
; 806  : 	vuMeterHeight = ledHeight;
; 807  : 	vuMeterWidth = (vuMeterLevels-1) * ledWidth;
; 808  : 	vuMeterWidth = (vuMeterWidth + 3) & (~3);

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _vuMeterLevels
  0000b	56		 push	 esi
  0000c	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR _vuMeterHeight, 6
  00016	8d 44 c0 fa	 lea	 eax, DWORD PTR [eax+eax*8-6]
  0001a	24 fc		 and	 al, -4			; fffffffcH
  0001c	a3 00 00 00 00	 mov	 DWORD PTR _vuMeterWidth, eax

; 809  : 	pBits = (unsigned char *)mir_alloc(3*vuMeterWidth*vuMeterHeight);

  00021	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00024	d1 e0		 shl	 eax, 1
  00026	50		 push	 eax
  00027	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  0002d	8b f0		 mov	 esi, eax

; 810  : 	memset(pBits, 0x80, 3*vuMeterWidth*vuMeterHeight);

  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR _vuMeterWidth
  00034	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _vuMeterHeight
  0003b	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0003e	50		 push	 eax
  0003f	68 80 00 00 00	 push	 128			; 00000080H
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 _memset

; 811  : 	for (i=0;i<vuMeterLevels;i++) {

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR _vuMeterLevels
  0004f	83 65 f0 00	 and	 DWORD PTR _i$[ebp], 0
  00053	83 c4 10	 add	 esp, 16			; 00000010H
  00056	85 c0		 test	 eax, eax
  00058	0f 8e 31 01 00
	00		 jle	 $L83974
  0005e	53		 push	 ebx
  0005f	57		 push	 edi
  00060	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR -28+[ebp], OFFSET FLAT:_vuMeterBitmaps
$L83972:

; 812  : 		for (v=0;v<vuMeterLevels-1;v++) {

  00067	83 65 f4 00	 and	 DWORD PTR _v$[ebp], 0
  0006b	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  0006e	85 c9		 test	 ecx, ecx
  00070	0f 8e e6 00 00
	00		 jle	 $L83977
  00076	83 65 fc 00	 and	 DWORD PTR -4+[ebp], 0
$L83975:

; 813  : 			if (v>=i) {

  0007a	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  0007d	39 4d f4	 cmp	 DWORD PTR _v$[ebp], ecx
  00080	7c 25		 jl	 SHORT $L83978

; 814  : 				if (v < 10) col0 = 0x104010;

  00082	83 7d fc 5a	 cmp	 DWORD PTR -4+[ebp], 90	; 0000005aH
  00086	7d 07		 jge	 SHORT $L83979
  00088	b9 10 40 10 00	 mov	 ecx, 1064976		; 00104010H

; 815  : 				else if (v<13) col0 = 0x404010;

  0008d	eb 3b		 jmp	 SHORT $L83986
$L83979:
  0008f	33 c9		 xor	 ecx, ecx
  00091	83 7d fc 75	 cmp	 DWORD PTR -4+[ebp], 117	; 00000075H
  00095	0f 9d c1	 setge	 cl
  00098	49		 dec	 ecx
  00099	81 e1 00 30 00
	00		 and	 ecx, 12288		; 00003000H
  0009f	81 c1 10 10 40
	00		 add	 ecx, 4198416		; 00401010H

; 816  : 				else 	col0 = 0x401010;
; 817  : 			} else {

  000a5	eb 23		 jmp	 SHORT $L83986
$L83978:

; 818  : 				if (v < 10) col0 = 0x00f000;

  000a7	83 7d fc 5a	 cmp	 DWORD PTR -4+[ebp], 90	; 0000005aH
  000ab	7d 07		 jge	 SHORT $L83984
  000ad	b9 00 f0 00 00	 mov	 ecx, 61440		; 0000f000H

; 819  : 				else if (v<13) col0 = 0xf0f000;

  000b2	eb 16		 jmp	 SHORT $L83986
$L83984:
  000b4	33 c9		 xor	 ecx, ecx
  000b6	83 7d fc 75	 cmp	 DWORD PTR -4+[ebp], 117	; 00000075H
  000ba	0f 9d c1	 setge	 cl
  000bd	49		 dec	 ecx
  000be	81 e1 00 f0 00
	00		 and	 ecx, 61440		; 0000f000H
  000c4	81 c1 00 00 f0
	00		 add	 ecx, 15728640		; 00f00000H
$L83986:

; 820  : 				else col0 = 0xf00000;
; 821  : 			}
; 822  : 			x0 = v * ledWidth;
; 823  : 			for (y=1;y<vuMeterHeight-1;y++) {

  000ca	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _vuMeterHeight
  000d0	6a 01		 push	 1
  000d2	5a		 pop	 edx
  000d3	4f		 dec	 edi
  000d4	3b fa		 cmp	 edi, edx
  000d6	89 55 f8	 mov	 DWORD PTR _y$[ebp], edx
  000d9	7e 6e		 jle	 SHORT $L83976

; 824  : 				col = col0;
; 825  : 				for (x=1;x<ledWidth;x++) {
; 826  : 					pBits[3*(x+x0+y*vuMeterWidth)] = col &0xFF;
; 827  : 					pBits[3*(x+x0+y*vuMeterWidth)+1] = (col>>8) &0xFF;

  000db	89 4d ec	 mov	 DWORD PTR -20+[ebp], ecx

; 828  : 					pBits[3*(x+x0+y*vuMeterWidth)+2] = (col>>16) &0xFF;

  000de	89 4d e8	 mov	 DWORD PTR -24+[ebp], ecx
  000e1	c1 7d ec 08	 sar	 DWORD PTR -20+[ebp], 8
  000e5	c1 7d e8 10	 sar	 DWORD PTR -24+[ebp], 16	; 00000010H
$L83988:
  000e9	6a 01		 push	 1
  000eb	5f		 pop	 edi
$L83991:
  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _vuMeterWidth
  000f1	8a 5d ec	 mov	 bl, BYTE PTR -20+[ebp]
  000f4	0f af 45 f8	 imul	 eax, DWORD PTR _y$[ebp]
  000f8	03 45 fc	 add	 eax, DWORD PTR -4+[ebp]
  000fb	03 c7		 add	 eax, edi
  000fd	8d 14 46	 lea	 edx, DWORD PTR [esi+eax*2]
  00100	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00103	a1 00 00 00 00	 mov	 eax, DWORD PTR _vuMeterWidth
  00108	0f af 45 f8	 imul	 eax, DWORD PTR _y$[ebp]
  0010c	03 45 fc	 add	 eax, DWORD PTR -4+[ebp]
  0010f	03 c7		 add	 eax, edi
  00111	8d 14 46	 lea	 edx, DWORD PTR [esi+eax*2]
  00114	88 5c 10 01	 mov	 BYTE PTR [eax+edx+1], bl
  00118	a1 00 00 00 00	 mov	 eax, DWORD PTR _vuMeterWidth
  0011d	0f af 45 f8	 imul	 eax, DWORD PTR _y$[ebp]
  00121	03 45 fc	 add	 eax, DWORD PTR -4+[ebp]
  00124	8a 5d e8	 mov	 bl, BYTE PTR -24+[ebp]
  00127	03 c7		 add	 eax, edi
  00129	47		 inc	 edi
  0012a	83 ff 09	 cmp	 edi, 9
  0012d	8d 14 46	 lea	 edx, DWORD PTR [esi+eax*2]
  00130	88 5c 10 02	 mov	 BYTE PTR [eax+edx+2], bl
  00134	7c b6		 jl	 SHORT $L83991
  00136	a1 00 00 00 00	 mov	 eax, DWORD PTR _vuMeterHeight
  0013b	ff 45 f8	 inc	 DWORD PTR _y$[ebp]
  0013e	48		 dec	 eax
  0013f	39 45 f8	 cmp	 DWORD PTR _y$[ebp], eax
  00142	7c a5		 jl	 SHORT $L83988

; 820  : 				else col0 = 0xf00000;
; 821  : 			}
; 822  : 			x0 = v * ledWidth;
; 823  : 			for (y=1;y<vuMeterHeight-1;y++) {

  00144	a1 00 00 00 00	 mov	 eax, DWORD PTR _vuMeterLevels
$L83976:

; 812  : 		for (v=0;v<vuMeterLevels-1;v++) {

  00149	ff 45 f4	 inc	 DWORD PTR _v$[ebp]
  0014c	83 45 fc 09	 add	 DWORD PTR -4+[ebp], 9
  00150	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00153	39 4d f4	 cmp	 DWORD PTR _v$[ebp], ecx
  00156	0f 8c 1e ff ff
	ff		 jl	 $L83975
$L83977:

; 829  : 				}
; 830  : 			}
; 831  : 		}
; 832  : 		vuMeterBitmaps[i] = TlenVoiceMakeBitmap(vuMeterWidth, vuMeterHeight, 24, pBits);

  0015c	56		 push	 esi
  0015d	6a 18		 push	 24			; 00000018H
  0015f	ff 35 00 00 00
	00		 push	 DWORD PTR _vuMeterHeight
  00165	ff 35 00 00 00
	00		 push	 DWORD PTR _vuMeterWidth
  0016b	e8 00 00 00 00	 call	 _TlenVoiceMakeBitmap
  00170	8b 4d e4	 mov	 ecx, DWORD PTR -28+[ebp]
  00173	83 45 e4 04	 add	 DWORD PTR -28+[ebp], 4
  00177	83 c4 10	 add	 esp, 16			; 00000010H
  0017a	ff 45 f0	 inc	 DWORD PTR _i$[ebp]
  0017d	89 01		 mov	 DWORD PTR [ecx], eax
  0017f	a1 00 00 00 00	 mov	 eax, DWORD PTR _vuMeterLevels
  00184	39 45 f0	 cmp	 DWORD PTR _i$[ebp], eax
  00187	0f 8c da fe ff
	ff		 jl	 $L83972
  0018d	5f		 pop	 edi
  0018e	5b		 pop	 ebx
$L83974:

; 833  : 	}
; 834  : 	mir_free(pBits);

  0018f	56		 push	 esi
  00190	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00196	59		 pop	 ecx
  00197	5e		 pop	 esi

; 835  : }

  00198	c9		 leave
  00199	c3		 ret	 0
_TlenVoiceInitVUMeters ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BA@FHJ@?$AAD?$AAI?$AAS?$AAP?$AAL?$AAA?$AAY?$AA?$AA@ ; `string'
EXTRN	__imp__CreateDCW@16:NEAR
EXTRN	__imp__CreateDIBitmap@24:NEAR
;	COMDAT ??_C@_1BA@FHJ@?$AAD?$AAI?$AAS?$AAP?$AAL?$AAA?$AAY?$AA?$AA@
; File E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\tlen_voice.c
_DATA	SEGMENT
??_C@_1BA@FHJ@?$AAD?$AAI?$AAS?$AAP?$AAL?$AAA?$AAY?$AA?$AA@ DB 'D', 00H, 'I'
	DB	00H, 'S', 00H, 'P', 00H, 'L', 00H, 'A', 00H, 'Y', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT _TlenVoiceMakeBitmap
_TEXT	SEGMENT
_w$ = 8
_h$ = 12
_bpp$ = 16
_ptr$ = 20
_bmih$ = -44
_TlenVoiceMakeBitmap PROC NEAR				; COMDAT

; 778  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 779  : 	BITMAPINFO	   bmih;
; 780  : 	HBITMAP 	   hbm;
; 781  : 	HDC 		   hdc;
; 782  : 	bmih.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
; 783  : 	bmih.bmiHeader.biWidth = w&0xFFFFFFFC;

  00006	8b 45 08	 mov	 eax, DWORD PTR _w$[ebp]
  00009	53		 push	 ebx
  0000a	24 fc		 and	 al, -4			; fffffffcH
  0000c	56		 push	 esi
  0000d	89 45 d8	 mov	 DWORD PTR _bmih$[ebp+4], eax

; 784  : 	bmih.bmiHeader.biHeight = h;//&0xFFFFFFFC;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _h$[ebp]

; 785  : 	bmih.bmiHeader.biPlanes = 1;			   // musi byc 1
; 786  : 	bmih.bmiHeader.biBitCount = bpp;
; 787  : 	bmih.bmiHeader.biCompression = BI_RGB;

  00013	33 f6		 xor	 esi, esi
  00015	57		 push	 edi

; 788  : 	bmih.bmiHeader.biSizeImage = 0;
; 789  : 	bmih.bmiHeader.biXPelsPerMeter = 0;
; 790  : 	bmih.bmiHeader.biYPelsPerMeter = 0;
; 791  : 	bmih.bmiHeader.biClrUsed = 0;
; 792  : 	bmih.bmiHeader.biClrImportant = 0;
; 793  : 	hdc = CreateDC(_T("DISPLAY"), NULL, NULL, NULL);

  00016	56		 push	 esi
  00017	89 45 dc	 mov	 DWORD PTR _bmih$[ebp+8], eax
  0001a	66 8b 45 10	 mov	 ax, WORD PTR _bpp$[ebp]
  0001e	56		 push	 esi
  0001f	56		 push	 esi
  00020	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BA@FHJ@?$AAD?$AAI?$AAS?$AAP?$AAL?$AAA?$AAY?$AA?$AA@ ; `string'
  00025	c7 45 d4 28 00
	00 00		 mov	 DWORD PTR _bmih$[ebp], 40 ; 00000028H
  0002c	66 c7 45 e0 01
	00		 mov	 WORD PTR _bmih$[ebp+12], 1
  00032	66 89 45 e2	 mov	 WORD PTR _bmih$[ebp+14], ax
  00036	89 75 e4	 mov	 DWORD PTR _bmih$[ebp+16], esi
  00039	89 75 e8	 mov	 DWORD PTR _bmih$[ebp+20], esi
  0003c	89 75 ec	 mov	 DWORD PTR _bmih$[ebp+24], esi
  0003f	89 75 f0	 mov	 DWORD PTR _bmih$[ebp+28], esi
  00042	89 75 f4	 mov	 DWORD PTR _bmih$[ebp+32], esi
  00045	89 75 f8	 mov	 DWORD PTR _bmih$[ebp+36], esi
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDCW@16
  0004e	8b f8		 mov	 edi, eax

; 794  : 	hbm = CreateDIBitmap(hdc, (PBITMAPINFOHEADER) &bmih, CBM_INIT, ptr, &bmih, DIB_RGB_COLORS);

  00050	8d 45 d4	 lea	 eax, DWORD PTR _bmih$[ebp]
  00053	56		 push	 esi
  00054	50		 push	 eax
  00055	ff 75 14	 push	 DWORD PTR _ptr$[ebp]
  00058	8d 45 d4	 lea	 eax, DWORD PTR _bmih$[ebp]
  0005b	6a 04		 push	 4
  0005d	50		 push	 eax
  0005e	57		 push	 edi
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDIBitmap@24

; 795  : 	ReleaseDC(NULL,hdc);

  00065	57		 push	 edi
  00066	56		 push	 esi
  00067	8b d8		 mov	 ebx, eax
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  0006f	5f		 pop	 edi

; 796  : 	return hbm;

  00070	8b c3		 mov	 eax, ebx
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx

; 797  : }

  00074	c9		 leave
  00075	c3		 ret	 0
_TlenVoiceMakeBitmap ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@IBOM@LoginServer?$AA@			; `string'
PUBLIC	??_C@_05FNBL@?$CFs?$EA?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BP@HHBC@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?85?8?5v?$DN?81?8?1?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BK@GEK@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?84?8?5?1?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BA@CKKI@VoiceChatPolicy?$AA@		; `string'
PUBLIC	_TlenVoiceAccept
EXTRN	_JabberListGetItemPtr:NEAR
EXTRN	_strcpy:NEAR
EXTRN	__imp___snprintf:NEAR
;	COMDAT ??_C@_0M@IBOM@LoginServer?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_database.h
_DATA	SEGMENT
??_C@_0M@IBOM@LoginServer?$AA@ DB 'LoginServer', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05FNBL@?$CFs?$EA?$CFs?$AA@
_DATA	SEGMENT
??_C@_05FNBL@?$CFs?$EA?$CFs?$AA@ DB '%s@%s', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@HHBC@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?85?8?5v?$DN?81?8?1?$DO?$AA@
_DATA	SEGMENT
??_C@_0BP@HHBC@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?85?8?5v?$DN?81?8?1?$DO?$AA@ DB '<'
	DB	'v t=''%s'' i=''%s'' e=''5'' v=''1''/>', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@GEK@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?84?8?5?1?$DO?$AA@
_DATA	SEGMENT
??_C@_0BK@GEK@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?84?8?5?1?$DO?$AA@ DB '<'
	DB	'v t=''%s'' i=''%s'' e=''4'' />', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@CKKI@VoiceChatPolicy?$AA@
_DATA	SEGMENT
??_C@_0BA@CKKI@VoiceChatPolicy?$AA@ DB 'VoiceChatPolicy', 00H ; `string'
_DATA	ENDS
;	COMDAT _TlenVoiceAccept
_TEXT	SEGMENT
_proto$ = 8
_id$ = 12
_from$ = 16
_ask$84194 = 8
_jid$84204 = -280
_dbv$84206 = -24
_jid$84217 = -280
_dbv$84219 = -24
_dbv$84673 = -24
_cgs$84674 = -12
_cgs$84682 = -12
_cgs$84692 = -12
_TlenVoiceAccept PROC NEAR				; COMDAT

; 1047 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 1048 : 	JABBER_LIST_ITEM * item;
; 1049 : 	if (!TlenVoiceIsInUse(proto)) {

  0000b	8b 75 08	 mov	 esi, DWORD PTR _proto$[ebp]
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _TlenVoiceIsInUse
  00014	85 c0		 test	 eax, eax
  00016	59		 pop	 ecx
  00017	0f 85 6f 02 00
	00		 jne	 $L84193

; 1050 : 		if ((item = JabberListAdd(proto, LIST_VOICE, id)) != NULL) {

  0001d	ff 75 0c	 push	 DWORD PTR _id$[ebp]
  00020	6a 05		 push	 5
  00022	56		 push	 esi
  00023	e8 00 00 00 00	 call	 _JabberListAdd
  00028	8b d8		 mov	 ebx, eax
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002d	85 db		 test	 ebx, ebx
  0002f	0f 84 57 02 00
	00		 je	 $L84193

; 1051 : 			int ask, ignore, voiceChatPolicy;
; 1052 : 			ask = TRUE;
; 1053 : 			ignore = FALSE;
; 1054 : 			voiceChatPolicy = DBGetContactSettingWord(NULL, proto->iface.m_szModuleName, "VoiceChatPolicy", 0);

  00035	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00038	57		 push	 edi
  00039	89 45 f4	 mov	 DWORD PTR _cgs$84674[ebp], eax
  0003c	8d 45 e8	 lea	 eax, DWORD PTR _dbv$84673[ebp]
  0003f	89 45 fc	 mov	 DWORD PTR _cgs$84674[ebp+8], eax
  00042	8d 45 f4	 lea	 eax, DWORD PTR _cgs$84674[ebp]
  00045	50		 push	 eax
  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0004b	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@ ; `string'
  00050	6a 00		 push	 0
  00052	57		 push	 edi
  00053	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _ask$84194[ebp], 1
  0005a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cgs$84674[ebp+4], OFFSET FLAT:??_C@_0BA@CKKI@VoiceChatPolicy?$AA@ ; `string'
  00061	ff 50 24	 call	 DWORD PTR [eax+36]
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
  00067	85 c0		 test	 eax, eax
  00069	0f 85 52 01 00
	00		 jne	 $L84699
  0006f	0f b7 45 ec	 movzx	 eax, WORD PTR _dbv$84673[ebp+4]

; 1055 : 			if (voiceChatPolicy == TLEN_MUC_ASK) {

  00073	85 c0		 test	 eax, eax

; 1056 : 				ignore = FALSE;
; 1057 : 				ask = TRUE;
; 1058 : 			} else if (voiceChatPolicy == TLEN_MUC_IGNORE_ALL) {

  00075	0f 84 46 01 00
	00		 je	 $L84699
  0007b	83 f8 04	 cmp	 eax, 4

; 1059 : 				ignore = TRUE;
; 1060 : 			} else if (voiceChatPolicy == TLEN_MUC_IGNORE_NIR) {

  0007e	0f 84 96 01 00
	00		 je	 $L84700
  00084	83 f8 03	 cmp	 eax, 3
  00087	0f 85 a2 00 00
	00		 jne	 $L84203

; 1061 : 				char jid[256];
; 1062 : 				JABBER_LIST_ITEM *item;
; 1063 : 				DBVARIANT dbv;
; 1064 : 				if (!DBGetContactSetting(NULL, proto->iface.m_szModuleName, "LoginServer", &dbv)) {

  0008d	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00090	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cgs$84682[ebp+4], OFFSET FLAT:??_C@_0M@IBOM@LoginServer?$AA@ ; `string'
  00097	89 45 f4	 mov	 DWORD PTR _cgs$84682[ebp], eax
  0009a	8d 45 e8	 lea	 eax, DWORD PTR _dbv$84206[ebp]
  0009d	89 45 fc	 mov	 DWORD PTR _cgs$84682[ebp+8], eax
  000a0	8d 45 f4	 lea	 eax, DWORD PTR _cgs$84682[ebp]
  000a3	50		 push	 eax
  000a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  000a9	6a 00		 push	 0
  000ab	57		 push	 edi
  000ac	ff 50 24	 call	 DWORD PTR [eax+36]
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b2	85 c0		 test	 eax, eax
  000b4	75 35		 jne	 SHORT $L84208

; 1065 : 					_snprintf(jid, sizeof(jid), "%s@%s", from, dbv.pszVal);

  000b6	ff 75 ec	 push	 DWORD PTR _dbv$84206[ebp+4]
  000b9	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _jid$84204[ebp]
  000bf	ff 75 10	 push	 DWORD PTR _from$[ebp]
  000c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05FNBL@?$CFs?$EA?$CFs?$AA@ ; `string'
  000c7	68 00 01 00 00	 push	 256			; 00000100H
  000cc	50		 push	 eax
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf

; 1066 : 					DBFreeVariant(&dbv);

  000d3	8d 45 e8	 lea	 eax, DWORD PTR _dbv$84206[ebp]
  000d6	50		 push	 eax
  000d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  000dc	6a 00		 push	 0
  000de	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@ ; `string'
  000e3	ff 50 24	 call	 DWORD PTR [eax+36]
  000e6	83 c4 20	 add	 esp, 32			; 00000020H

; 1067 : 				} else {

  000e9	eb 11		 jmp	 SHORT $L84209
$L84208:

; 1068 : 					strcpy(jid, from);

  000eb	ff 75 10	 push	 DWORD PTR _from$[ebp]
  000ee	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _jid$84204[ebp]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _strcpy
  000fa	59		 pop	 ecx
  000fb	59		 pop	 ecx
$L84209:

; 1069 : 				}
; 1070 : 				item = JabberListGetItemPtr(proto, LIST_ROSTER, jid);

  000fc	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _jid$84204[ebp]
  00102	50		 push	 eax
  00103	6a 00		 push	 0
  00105	56		 push	 esi
  00106	e8 00 00 00 00	 call	 _JabberListGetItemPtr
  0010b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1071 : 				ignore = FALSE;

  0010e	33 c9		 xor	 ecx, ecx

; 1072 : 				if (item == NULL) ignore = TRUE;

  00110	85 c0		 test	 eax, eax

; 1073 : 				else if (item->subscription==SUB_NONE || item->subscription==SUB_TO) ignore = TRUE;

  00112	74 0c		 je	 SHORT $L84214
  00114	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00117	85 c0		 test	 eax, eax
  00119	74 05		 je	 SHORT $L84214
  0011b	83 f8 01	 cmp	 eax, 1
  0011e	75 03		 jne	 SHORT $L84213
$L84214:
  00120	6a 01		 push	 1
  00122	59		 pop	 ecx
$L84213:

; 1074 : 				ask = TRUE;

  00123	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _ask$84194[ebp], 1

; 1075 : 			} else if (voiceChatPolicy == TLEN_MUC_ACCEPT_IR) {

  0012a	e9 e7 00 00 00	 jmp	 $L84229
$L84203:
  0012f	83 f8 01	 cmp	 eax, 1
  00132	0f 85 d3 00 00
	00		 jne	 $L84216

; 1076 : 				char jid[256];
; 1077 : 				JABBER_LIST_ITEM *item;
; 1078 : 				DBVARIANT dbv;
; 1079 : 				if (!DBGetContactSetting(NULL, proto->iface.m_szModuleName, "LoginServer", &dbv)) {

  00138	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0013b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cgs$84692[ebp+4], OFFSET FLAT:??_C@_0M@IBOM@LoginServer?$AA@ ; `string'
  00142	89 45 f4	 mov	 DWORD PTR _cgs$84692[ebp], eax
  00145	8d 45 e8	 lea	 eax, DWORD PTR _dbv$84219[ebp]
  00148	89 45 fc	 mov	 DWORD PTR _cgs$84692[ebp+8], eax
  0014b	8d 45 f4	 lea	 eax, DWORD PTR _cgs$84692[ebp]
  0014e	50		 push	 eax
  0014f	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00154	6a 00		 push	 0
  00156	57		 push	 edi
  00157	ff 50 24	 call	 DWORD PTR [eax+36]
  0015a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015d	85 c0		 test	 eax, eax
  0015f	75 35		 jne	 SHORT $L84221

; 1080 : 					_snprintf(jid, sizeof(jid), "%s@%s", from, dbv.pszVal);

  00161	ff 75 ec	 push	 DWORD PTR _dbv$84219[ebp+4]
  00164	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _jid$84217[ebp]
  0016a	ff 75 10	 push	 DWORD PTR _from$[ebp]
  0016d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05FNBL@?$CFs?$EA?$CFs?$AA@ ; `string'
  00172	68 00 01 00 00	 push	 256			; 00000100H
  00177	50		 push	 eax
  00178	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf

; 1081 : 					DBFreeVariant(&dbv);

  0017e	8d 45 e8	 lea	 eax, DWORD PTR _dbv$84219[ebp]
  00181	50		 push	 eax
  00182	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00187	6a 00		 push	 0
  00189	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@ ; `string'
  0018e	ff 50 24	 call	 DWORD PTR [eax+36]
  00191	83 c4 20	 add	 esp, 32			; 00000020H

; 1082 : 				} else {

  00194	eb 11		 jmp	 SHORT $L84222
$L84221:

; 1083 : 					strcpy(jid, from);

  00196	ff 75 10	 push	 DWORD PTR _from$[ebp]
  00199	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _jid$84217[ebp]
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 _strcpy
  001a5	59		 pop	 ecx
  001a6	59		 pop	 ecx
$L84222:

; 1084 : 				}
; 1085 : 				item = JabberListGetItemPtr(proto, LIST_ROSTER, jid);

  001a7	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _jid$84217[ebp]
  001ad	50		 push	 eax
  001ae	6a 00		 push	 0
  001b0	56		 push	 esi
  001b1	e8 00 00 00 00	 call	 _JabberListGetItemPtr

; 1086 : 				ask = FALSE;

  001b6	83 65 08 00	 and	 DWORD PTR _ask$84194[ebp], 0
  001ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1087 : 				if (item == NULL) ask = TRUE;

  001bd	85 c0		 test	 eax, eax
  001bf	75 3c		 jne	 SHORT $L84224
$L84699:
  001c1	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _ask$84194[ebp], 1
$L84230:

; 1100 : 				item->nick = mir_strdup(from);

  001c8	ff 75 10	 push	 DWORD PTR _from$[ebp]
  001cb	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20

; 1101 : 				if (ask) {

  001d1	33 ff		 xor	 edi, edi
  001d3	59		 pop	 ecx
  001d4	39 7d 08	 cmp	 DWORD PTR _ask$84194[ebp], edi
  001d7	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  001da	74 6b		 je	 SHORT $L84233

; 1102 :                     ACCEPTDIALOGDATA *data = (ACCEPTDIALOGDATA *)mir_alloc(sizeof(ACCEPTDIALOGDATA));

  001dc	6a 08		 push	 8
  001de	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4

; 1103 :                     data->proto = proto;
; 1104 :                     data->item = item;
; 1105 : 					JabberForkThread((void (__cdecl *)(void*))TlenVoiceAcceptDlgThread, 0, data);

  001e4	50		 push	 eax
  001e5	57		 push	 edi
  001e6	68 00 00 00 00	 push	 OFFSET FLAT:_TlenVoiceAcceptDlgThread
  001eb	89 30		 mov	 DWORD PTR [eax], esi
  001ed	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  001f0	e8 00 00 00 00	 call	 _JabberForkThread
  001f5	83 c4 10	 add	 esp, 16			; 00000010H

; 1106 : 				} else if (proto->jabberOnline) {

  001f8	e9 89 00 00 00	 jmp	 $L84240
$L84224:

; 1088 : 				else if (item->subscription==SUB_NONE || item->subscription==SUB_TO) ask = TRUE;

  001fd	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00200	85 c0		 test	 eax, eax
  00202	74 bd		 je	 SHORT $L84699
  00204	83 f8 01	 cmp	 eax, 1
  00207	75 bf		 jne	 SHORT $L84230

; 1089 : 				ignore = FALSE;
; 1090 : 			} else if (voiceChatPolicy == TLEN_MUC_ACCEPT_ALL) {

  00209	eb b6		 jmp	 SHORT $L84699
$L84216:
  0020b	83 f8 02	 cmp	 eax, 2
  0020e	75 b8		 jne	 SHORT $L84230

; 1091 : 				ask = FALSE;

  00210	83 65 08 00	 and	 DWORD PTR _ask$84194[ebp], 0

; 1092 : 				ignore = FALSE;

  00214	33 c9		 xor	 ecx, ecx
$L84229:

; 1093 : 			}
; 1094 : 			if (ignore) {

  00216	85 c9		 test	 ecx, ecx
  00218	74 ae		 je	 SHORT $L84230
$L84700:

; 1095 : 				if (proto->jabberOnline) {

  0021a	83 be 78 01 00
	00 00		 cmp	 DWORD PTR [esi+376], 0
  00221	74 14		 je	 SHORT $L84231

; 1096 : 					JabberSend(proto, "<v t='%s' i='%s' e='4' />", from, id);

  00223	ff 75 0c	 push	 DWORD PTR _id$[ebp]
  00226	ff 75 10	 push	 DWORD PTR _from$[ebp]
  00229	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@GEK@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?84?8?5?1?$DO?$AA@ ; `string'
  0022e	56		 push	 esi
  0022f	e8 00 00 00 00	 call	 _JabberSend
  00234	83 c4 10	 add	 esp, 16			; 00000010H
$L84231:

; 1097 : 				}
; 1098 : 				JabberListRemove(proto, LIST_VOICE, id);

  00237	ff 75 0c	 push	 DWORD PTR _id$[ebp]
  0023a	6a 05		 push	 5
  0023c	56		 push	 esi
  0023d	e8 00 00 00 00	 call	 _JabberListRemove
  00242	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1099 : 			} else {

  00245	eb 3f		 jmp	 SHORT $L84240
$L84233:

; 1106 : 				} else if (proto->jabberOnline) {

  00247	39 be 78 01 00
	00		 cmp	 DWORD PTR [esi+376], edi
  0024d	74 37		 je	 SHORT $L84240

; 1107 : 					item->ft = TlenFileCreateFT(proto, from);

  0024f	ff 75 10	 push	 DWORD PTR _from$[ebp]
  00252	56		 push	 esi
  00253	e8 00 00 00 00	 call	 _TlenFileCreateFT

; 1108 : 					item->ft->iqId = mir_strdup(id);

  00258	ff 75 0c	 push	 DWORD PTR _id$[ebp]
  0025b	89 43 58	 mov	 DWORD PTR [ebx+88], eax
  0025e	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  00264	8b 4b 58	 mov	 ecx, DWORD PTR [ebx+88]

; 1109 : 					TlenVoiceStart(NULL, 2);

  00267	6a 02		 push	 2
  00269	57		 push	 edi
  0026a	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0026d	e8 00 00 00 00	 call	 _TlenVoiceStart

; 1110 : 					JabberSend(proto, "<v t='%s' i='%s' e='5' v='1'/>", item->nick, item->jid);

  00272	ff 73 04	 push	 DWORD PTR [ebx+4]
  00275	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00278	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@HHBC@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?85?8?5v?$DN?81?8?1?$DO?$AA@ ; `string'
  0027d	56		 push	 esi
  0027e	e8 00 00 00 00	 call	 _JabberSend
  00283	83 c4 24	 add	 esp, 36			; 00000024H
$L84240:

; 1111 : 				}
; 1112 : 			}
; 1113 : 			return 1;

  00286	6a 01		 push	 1
  00288	58		 pop	 eax
  00289	5f		 pop	 edi
  0028a	eb 02		 jmp	 SHORT $L84189
$L84193:

; 1114 : 		}
; 1115 : 	}
; 1116 : 	return 0;

  0028c	33 c0		 xor	 eax, eax
$L84189:
  0028e	5e		 pop	 esi
  0028f	5b		 pop	 ebx

; 1117 : }

  00290	c9		 leave
  00291	c3		 ret	 0
_TlenVoiceAccept ENDP
_TEXT	ENDS
;	COMDAT _TlenVoiceAcceptDlgThread
_TEXT	SEGMENT
_ptr$ = 8
_TlenVoiceAcceptDlgThread PROC NEAR			; COMDAT

; 1028 : {

  00000	56		 push	 esi

; 1029 :     
; 1030 : 	ACCEPTDIALOGDATA *data = (ACCEPTDIALOGDATA *)ptr;
; 1031 : 	int result = DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_ACCEPT_VOICE), NULL, TlenVoiceAcceptDlgProc, (LPARAM) data);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _ptr$[esp]
  00005	56		 push	 esi
  00006	68 00 00 00 00	 push	 OFFSET FLAT:_TlenVoiceAcceptDlgProc@16
  0000b	6a 00		 push	 0
  0000d	68 a0 00 00 00	 push	 160			; 000000a0H
  00012	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20

; 1032 : 	if (result && data->proto->jabberOnline) {

  0001e	85 c0		 test	 eax, eax
  00020	74 55		 je	 SHORT $L84177
  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	83 b8 78 01 00
	00 00		 cmp	 DWORD PTR [eax+376], 0
  0002b	74 4a		 je	 SHORT $L84177

; 1033 : 		data->item->ft = TlenFileCreateFT(data->proto, data->item->nick);

  0002d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00030	ff 71 0c	 push	 DWORD PTR [ecx+12]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _TlenFileCreateFT
  00039	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003c	89 41 58	 mov	 DWORD PTR [ecx+88], eax

; 1034 : 		data->item->ft->iqId = mir_strdup(data->item->jid);

  0003f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00042	ff 70 04	 push	 DWORD PTR [eax+4]
  00045	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  0004b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 1035 : 		TlenVoiceStart(NULL, 2);

  0004e	6a 02		 push	 2
  00050	6a 00		 push	 0
  00052	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  00055	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00058	e8 00 00 00 00	 call	 _TlenVoiceStart

; 1036 : 		JabberSend(data->proto, "<v t='%s' i='%s' e='5' v='1'/>", data->item->nick, data->item->jid);

  0005d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00060	ff 70 04	 push	 DWORD PTR [eax+4]
  00063	ff 70 0c	 push	 DWORD PTR [eax+12]
  00066	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BP@HHBC@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?85?8?5v?$DN?81?8?1?$DO?$AA@ ; `string'
  0006b	ff 36		 push	 DWORD PTR [esi]
  0006d	e8 00 00 00 00	 call	 _JabberSend
  00072	83 c4 24	 add	 esp, 36			; 00000024H

; 1037 : 	} else {

  00075	eb 34		 jmp	 SHORT $L84180
$L84177:

; 1038 : 		if (data->proto->jabberOnline) {

  00077	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00079	83 b9 78 01 00
	00 00		 cmp	 DWORD PTR [ecx+376], 0
  00080	74 17		 je	 SHORT $L84181

; 1039 : 			JabberSend(data->proto, "<v t='%s' i='%s' e='4' />", data->item->nick, data->item->jid);

  00082	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00085	ff 70 04	 push	 DWORD PTR [eax+4]
  00088	ff 70 0c	 push	 DWORD PTR [eax+12]
  0008b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@GEK@?$DMv?5t?$DN?8?$CFs?8?5i?$DN?8?$CFs?8?5e?$DN?84?8?5?1?$DO?$AA@ ; `string'
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 _JabberSend
  00096	83 c4 10	 add	 esp, 16			; 00000010H
$L84181:

; 1040 : 		}
; 1041 : 		JabberListRemove(data->proto, LIST_VOICE, data->item->jid);

  00099	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009c	ff 70 04	 push	 DWORD PTR [eax+4]
  0009f	6a 05		 push	 5
  000a1	ff 36		 push	 DWORD PTR [esi]
  000a3	e8 00 00 00 00	 call	 _JabberListRemove
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
$L84180:

; 1042 : 	}
; 1043 :     mir_free(data);

  000ab	56		 push	 esi
  000ac	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  000b2	59		 pop	 ecx
  000b3	5e		 pop	 esi

; 1044 : }

  000b4	c3		 ret	 0
_TlenVoiceAcceptDlgThread ENDP
_TEXT	ENDS
;	COMDAT _TlenVoiceAcceptDlgProc@16
_TEXT	SEGMENT
_hwndDlg$ = 8
_msg$ = 12
_wParam$ = 16
_lParam$ = 20
_TlenVoiceAcceptDlgProc@16 PROC NEAR			; COMDAT

; 998  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 999  : 	ACCEPTDIALOGDATA * data;
; 1000 : 	char *str;
; 1001 : 	switch (msg) {

  00003	8b 45 0c	 mov	 eax, DWORD PTR _msg$[ebp]
  00006	83 e8 10	 sub	 eax, 16			; 00000010H
  00009	74 6c		 je	 SHORT $L84164
  0000b	2d 00 01 00 00	 sub	 eax, 256		; 00000100H
  00010	74 2b		 je	 SHORT $L84153
  00012	48		 dec	 eax
  00013	75 6d		 jne	 SHORT $L84150

; 1009 : 	case WM_COMMAND:
; 1010 : 		switch (LOWORD(wParam)) {

  00015	0f b7 45 10	 movzx	 eax, WORD PTR _wParam$[ebp]
  00019	48		 dec	 eax
  0001a	48		 dec	 eax
  0001b	74 10		 je	 SHORT $L84163
  0001d	83 e8 06	 sub	 eax, 6
  00020	74 0b		 je	 SHORT $L84163
  00022	2d 4b 04 00 00	 sub	 eax, 1099		; 0000044bH
  00027	75 59		 jne	 SHORT $L84150

; 1011 : 		case IDC_ACCEPT:
; 1012 : 			EndDialog(hwndDlg, 1);

  00029	6a 01		 push	 1

; 1013 : 			return TRUE;

  0002b	eb 02		 jmp	 SHORT $L84711
$L84163:

; 1014 : 		case IDCANCEL:
; 1015 : 		case IDCLOSE:
; 1016 : 			EndDialog(hwndDlg, 0);

  0002d	6a 00		 push	 0
$L84711:
  0002f	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8

; 1017 : 			return TRUE;

  00038	6a 01		 push	 1
  0003a	58		 pop	 eax
  0003b	eb 47		 jmp	 SHORT $L84146
$L84153:
  0003d	56		 push	 esi

; 1002 : 	case WM_INITDIALOG:
; 1003 : 		TranslateDialogDefault(hwndDlg);

  0003e	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  00041	e8 00 00 00 00	 call	 _TranslateDialogDefault

; 1004 : 		data = (ACCEPTDIALOGDATA *) lParam;
; 1005 : 		str = getDisplayName(data->proto, data->item->nick);

  00046	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00049	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004c	ff 71 0c	 push	 DWORD PTR [ecx+12]
  0004f	ff 30		 push	 DWORD PTR [eax]
  00051	e8 00 00 00 00	 call	 _getDisplayName
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	8b f0		 mov	 esi, eax

; 1006 : 		SetDlgItemTextA(hwndDlg, IDC_FROM, str);

  0005b	56		 push	 esi
  0005c	68 97 04 00 00	 push	 1175			; 00000497H
  00061	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemTextA@12

; 1007 : 		mir_free(str);

  0006a	56		 push	 esi
  0006b	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00071	59		 pop	 ecx

; 1008 : 		return FALSE;

  00072	33 c0		 xor	 eax, eax
  00074	5e		 pop	 esi
  00075	eb 0d		 jmp	 SHORT $L84146
$L84164:

; 1018 : 		}
; 1019 : 		break;
; 1020 : 	case WM_CLOSE:
; 1021 : 		EndDialog(hwndDlg, 0);

  00077	6a 00		 push	 0
  00079	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8
$L84150:

; 1022 : 		break;
; 1023 : 	}
; 1024 : 	return FALSE;

  00082	33 c0		 xor	 eax, eax
$L84146:

; 1025 : }

  00084	5d		 pop	 ebp
  00085	c2 10 00	 ret	 16			; 00000010H
_TlenVoiceAcceptDlgProc@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@DJCK@CList?1GetContactDisplayName?$AA@ ; `string'
EXTRN	_JabberHContactFromJID:NEAR
;	COMDAT ??_C@_0BM@DJCK@CList?1GetContactDisplayName?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_database.h
_DATA	SEGMENT
??_C@_0BM@DJCK@CList?1GetContactDisplayName?$AA@ DB 'CList/GetContactDisp'
	DB	'layName', 00H				; `string'
_DATA	ENDS
;	COMDAT _getDisplayName
_TEXT	SEGMENT
_proto$ = 8
_id$ = 12
_jid$ = -280
_dbv$ = -24
_cgs$84716 = -12
_getDisplayName PROC NEAR				; COMDAT

; 978  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	56		 push	 esi

; 979  : 	char jid[256];
; 980  : 	HANDLE hContact;
; 981  : 	DBVARIANT dbv;
; 982  : 	if (!DBGetContactSetting(NULL, proto->iface.m_szModuleName, "LoginServer", &dbv)) {

  0000a	8b 75 08	 mov	 esi, DWORD PTR _proto$[ebp]
  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cgs$84716[ebp+4], OFFSET FLAT:??_C@_0M@IBOM@LoginServer?$AA@ ; `string'
  00014	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00017	89 45 f4	 mov	 DWORD PTR _cgs$84716[ebp], eax
  0001a	8d 45 e8	 lea	 eax, DWORD PTR _dbv$[ebp]
  0001d	89 45 fc	 mov	 DWORD PTR _cgs$84716[ebp+8], eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR _cgs$84716[ebp]
  00023	50		 push	 eax
  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00029	6a 00		 push	 0
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@ ; `string'
  00030	ff 50 24	 call	 DWORD PTR [eax+36]
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	85 c0		 test	 eax, eax
  00038	75 60		 jne	 SHORT $L84129

; 983  : 		_snprintf(jid, sizeof(jid), "%s@%s", id, dbv.pszVal);

  0003a	ff 75 ec	 push	 DWORD PTR _dbv$[ebp+4]
  0003d	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _jid$[ebp]
  00043	ff 75 0c	 push	 DWORD PTR _id$[ebp]
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05FNBL@?$CFs?$EA?$CFs?$AA@ ; `string'
  0004b	68 00 01 00 00	 push	 256			; 00000100H
  00050	50		 push	 eax
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf

; 984  : 		DBFreeVariant(&dbv);

  00057	8d 45 e8	 lea	 eax, DWORD PTR _dbv$[ebp]
  0005a	50		 push	 eax
  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00060	6a 00		 push	 0
  00062	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@ ; `string'
  00067	ff 50 24	 call	 DWORD PTR [eax+36]

; 985  : 		if ((hContact=JabberHContactFromJID(proto, jid)) != NULL) {

  0006a	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _jid$[ebp]
  00070	50		 push	 eax
  00071	56		 push	 esi
  00072	e8 00 00 00 00	 call	 _JabberHContactFromJID
  00077	83 c4 28	 add	 esp, 40			; 00000028H
  0007a	85 c0		 test	 eax, eax
  0007c	74 1c		 je	 SHORT $L84129

; 986  : 			return mir_strdup((char *) CallService(MS_CLIST_GETCONTACTDISPLAYNAME, (WPARAM) hContact, 0));

  0007e	6a 00		 push	 0
  00080	50		 push	 eax
  00081	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00086	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@DJCK@CList?1GetContactDisplayName?$AA@ ; `string'
  0008b	ff 50 24	 call	 DWORD PTR [eax+36]
  0008e	50		 push	 eax
  0008f	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  00095	83 c4 10	 add	 esp, 16			; 00000010H
  00098	eb 0a		 jmp	 SHORT $L84120
$L84129:

; 987  : 		}
; 988  : 	}
; 989  : 	return mir_strdup(id);

  0009a	ff 75 0c	 push	 DWORD PTR _id$[ebp]
  0009d	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  000a3	59		 pop	 ecx
$L84120:
  000a4	5e		 pop	 esi

; 990  : }

  000a5	c9		 leave
  000a6	c3		 ret	 0
_getDisplayName ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BA@HMKN@?$AAD?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AA?$AA@ ; `string'
PUBLIC	_TlenVoiceBuildInDeviceList
EXTRN	__imp__SendMessageW@16:NEAR
;	COMDAT ??_C@_1BA@HMKN@?$AAD?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AA?$AA@
; File C:\MirandaDev\miranda_svn2\include\m_database.h
_DATA	SEGMENT
??_C@_1BA@HMKN@?$AAD?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AA?$AA@ DB 'D', 00H, 'e'
	DB	00H, 'f', 00H, 'a', 00H, 'u', 00H, 'l', 00H, 't', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT _TlenVoiceBuildInDeviceList
_TEXT	SEGMENT
_proto$ = 8
_hWnd$ = 12
_i$ = -4
_j$ = -8
_iNumDevs$ = -12
_wic$ = -116
_dbv$84726 = -36
_cgs$84727 = -24
_TlenVoiceBuildInDeviceList PROC NEAR			; COMDAT

; 1120 : {	int i, j, iNumDevs;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1121 : 	WAVEINCAPS     wic;
; 1122 : 	iNumDevs = waveInGetNumDevs();

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveInGetNumDevs@0
  0000f	89 45 f4	 mov	 DWORD PTR _iNumDevs$[ebp], eax

; 1123 : 	SendMessage(hWnd, CB_ADDSTRING, 0, (LPARAM)TranslateT("Default"));

  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BA@HMKN@?$AAD?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AA?$AA@ ; `string'
  0001c	68 00 10 00 00	 push	 4096			; 00001000H
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@MKNL@LangPack?1TranslateString?$AA@ ; `string'
  00026	ff 50 24	 call	 DWORD PTR [eax+36]
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageW@16
  00032	33 db		 xor	 ebx, ebx
  00034	bf 43 01 00 00	 mov	 edi, 323		; 00000143H
  00039	50		 push	 eax
  0003a	53		 push	 ebx
  0003b	57		 push	 edi
  0003c	ff 75 0c	 push	 DWORD PTR _hWnd$[ebp]
  0003f	ff d6		 call	 esi

; 1124 : 	for (i = j = 0; i < iNumDevs; i++) {

  00041	39 5d f4	 cmp	 DWORD PTR _iNumDevs$[ebp], ebx
  00044	89 5d f8	 mov	 DWORD PTR _j$[ebp], ebx
  00047	89 5d fc	 mov	 DWORD PTR _i$[ebp], ebx
  0004a	7e 31		 jle	 SHORT $L84257
$L84255:

; 1125 : 		if (!waveInGetDevCaps(i, &wic, sizeof(WAVEINCAPS))) {

  0004c	8d 45 8c	 lea	 eax, DWORD PTR _wic$[ebp]
  0004f	6a 50		 push	 80			; 00000050H
  00051	50		 push	 eax
  00052	ff 75 fc	 push	 DWORD PTR _i$[ebp]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveInGetDevCapsW@12
  0005b	85 c0		 test	 eax, eax
  0005d	75 13		 jne	 SHORT $L84256

; 1126 : 			if (wic.dwFormats != 0) {

  0005f	39 5d d4	 cmp	 DWORD PTR _wic$[ebp+72], ebx
  00062	74 0e		 je	 SHORT $L84256

; 1127 : 				SendMessage(hWnd, CB_ADDSTRING, 0, (LPARAM)wic.szPname);

  00064	8d 45 94	 lea	 eax, DWORD PTR _wic$[ebp+8]
  00067	50		 push	 eax
  00068	53		 push	 ebx
  00069	57		 push	 edi
  0006a	ff 75 0c	 push	 DWORD PTR _hWnd$[ebp]
  0006d	ff d6		 call	 esi

; 1128 : 				j++;

  0006f	ff 45 f8	 inc	 DWORD PTR _j$[ebp]
$L84256:
  00072	ff 45 fc	 inc	 DWORD PTR _i$[ebp]
  00075	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00078	3b 45 f4	 cmp	 eax, DWORD PTR _iNumDevs$[ebp]
  0007b	7c cf		 jl	 SHORT $L84255
$L84257:

; 1129 : 			}
; 1130 : 		}
; 1131 : 	}
; 1132 : 	i = DBGetContactSettingWord(NULL, proto->iface.m_szModuleName, "VoiceDeviceIn", 0);

  0007d	8b 45 08	 mov	 eax, DWORD PTR _proto$[ebp]
  00080	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _cgs$84727[ebp+4], OFFSET FLAT:??_C@_0O@EBHE@VoiceDeviceIn?$AA@ ; `string'
  00087	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0008a	89 45 e8	 mov	 DWORD PTR _cgs$84727[ebp], eax
  0008d	8d 45 dc	 lea	 eax, DWORD PTR _dbv$84726[ebp]
  00090	89 45 f0	 mov	 DWORD PTR _cgs$84727[ebp+8], eax
  00093	8d 45 e8	 lea	 eax, DWORD PTR _cgs$84727[ebp]
  00096	50		 push	 eax
  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0009c	53		 push	 ebx
  0009d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@ ; `string'
  000a2	ff 50 24	 call	 DWORD PTR [eax+36]
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a8	85 c0		 test	 eax, eax
  000aa	74 04		 je	 SHORT $L84728
  000ac	33 c0		 xor	 eax, eax
  000ae	eb 04		 jmp	 SHORT $L84725
$L84728:
  000b0	0f b7 45 e0	 movzx	 eax, WORD PTR _dbv$84726[ebp+4]
$L84725:

; 1133 : 	if (i>j) i = 0;

  000b4	3b 45 f8	 cmp	 eax, DWORD PTR _j$[ebp]
  000b7	7e 02		 jle	 SHORT $L84263
  000b9	33 c0		 xor	 eax, eax
$L84263:

; 1134 : 	SendMessage(hWnd, CB_SETCURSEL, i, 0);

  000bb	53		 push	 ebx
  000bc	50		 push	 eax
  000bd	68 4e 01 00 00	 push	 334			; 0000014eH
  000c2	ff 75 0c	 push	 DWORD PTR _hWnd$[ebp]
  000c5	ff d6		 call	 esi
  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi

; 1135 : 	return 0;

  000c9	33 c0		 xor	 eax, eax
  000cb	5b		 pop	 ebx

; 1136 : }

  000cc	c9		 leave
  000cd	c3		 ret	 0
_TlenVoiceBuildInDeviceList ENDP
_TEXT	ENDS
PUBLIC	_TlenVoiceBuildOutDeviceList
;	COMDAT _TlenVoiceBuildOutDeviceList
_TEXT	SEGMENT
_proto$ = 8
_hWnd$ = 12
_i$ = -4
_j$ = -8
_iNumDevs$ = -12
_woc$ = -120
_dbv$84738 = -36
_cgs$84739 = -24
_TlenVoiceBuildOutDeviceList PROC NEAR			; COMDAT

; 1139 : {	int i, j, iNumDevs;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1140 : 	WAVEOUTCAPS  woc;
; 1141 : 	iNumDevs = waveInGetNumDevs();

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveInGetNumDevs@0
  0000f	89 45 f4	 mov	 DWORD PTR _iNumDevs$[ebp], eax

; 1142 : 	SendMessage(hWnd, CB_ADDSTRING, 0, (LPARAM)TranslateT("Default"));

  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BA@HMKN@?$AAD?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AA?$AA@ ; `string'
  0001c	68 00 10 00 00	 push	 4096			; 00001000H
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@MKNL@LangPack?1TranslateString?$AA@ ; `string'
  00026	ff 50 24	 call	 DWORD PTR [eax+36]
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageW@16
  00032	33 db		 xor	 ebx, ebx
  00034	bf 43 01 00 00	 mov	 edi, 323		; 00000143H
  00039	50		 push	 eax
  0003a	53		 push	 ebx
  0003b	57		 push	 edi
  0003c	ff 75 0c	 push	 DWORD PTR _hWnd$[ebp]
  0003f	ff d6		 call	 esi

; 1143 : 	for (i = j = 0; i < iNumDevs; i++) {

  00041	39 5d f4	 cmp	 DWORD PTR _iNumDevs$[ebp], ebx
  00044	89 5d f8	 mov	 DWORD PTR _j$[ebp], ebx
  00047	89 5d fc	 mov	 DWORD PTR _i$[ebp], ebx
  0004a	7e 31		 jle	 SHORT $L84278
$L84276:

; 1144 : 		if (!waveOutGetDevCaps(i, &woc, sizeof(WAVEOUTCAPS))) {

  0004c	8d 45 88	 lea	 eax, DWORD PTR _woc$[ebp]
  0004f	6a 54		 push	 84			; 00000054H
  00051	50		 push	 eax
  00052	ff 75 fc	 push	 DWORD PTR _i$[ebp]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetDevCapsW@12
  0005b	85 c0		 test	 eax, eax
  0005d	75 13		 jne	 SHORT $L84277

; 1145 : 			if (woc.dwFormats != 0) {

  0005f	39 5d d0	 cmp	 DWORD PTR _woc$[ebp+72], ebx
  00062	74 0e		 je	 SHORT $L84277

; 1146 : 				SendMessage(hWnd, CB_ADDSTRING, 0, (LPARAM)woc.szPname);

  00064	8d 45 90	 lea	 eax, DWORD PTR _woc$[ebp+8]
  00067	50		 push	 eax
  00068	53		 push	 ebx
  00069	57		 push	 edi
  0006a	ff 75 0c	 push	 DWORD PTR _hWnd$[ebp]
  0006d	ff d6		 call	 esi

; 1147 : 				j++;

  0006f	ff 45 f8	 inc	 DWORD PTR _j$[ebp]
$L84277:
  00072	ff 45 fc	 inc	 DWORD PTR _i$[ebp]
  00075	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00078	3b 45 f4	 cmp	 eax, DWORD PTR _iNumDevs$[ebp]
  0007b	7c cf		 jl	 SHORT $L84276
$L84278:

; 1148 : 			}
; 1149 : 		}
; 1150 : 	}
; 1151 : 	i = DBGetContactSettingWord(NULL, proto->iface.m_szModuleName, "VoiceDeviceOut", 0);

  0007d	8b 45 08	 mov	 eax, DWORD PTR _proto$[ebp]
  00080	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _cgs$84739[ebp+4], OFFSET FLAT:??_C@_0P@OODI@VoiceDeviceOut?$AA@ ; `string'
  00087	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0008a	89 45 e8	 mov	 DWORD PTR _cgs$84739[ebp], eax
  0008d	8d 45 dc	 lea	 eax, DWORD PTR _dbv$84738[ebp]
  00090	89 45 f0	 mov	 DWORD PTR _cgs$84739[ebp+8], eax
  00093	8d 45 e8	 lea	 eax, DWORD PTR _cgs$84739[ebp]
  00096	50		 push	 eax
  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR _pluginLink
  0009c	53		 push	 ebx
  0009d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@ ; `string'
  000a2	ff 50 24	 call	 DWORD PTR [eax+36]
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a8	85 c0		 test	 eax, eax
  000aa	74 04		 je	 SHORT $L84740
  000ac	33 c0		 xor	 eax, eax
  000ae	eb 04		 jmp	 SHORT $L84737
$L84740:
  000b0	0f b7 45 e0	 movzx	 eax, WORD PTR _dbv$84738[ebp+4]
$L84737:

; 1152 : 	if (i>j) i = 0;

  000b4	3b 45 f8	 cmp	 eax, DWORD PTR _j$[ebp]
  000b7	7e 02		 jle	 SHORT $L84284
  000b9	33 c0		 xor	 eax, eax
$L84284:

; 1153 : 	SendMessage(hWnd, CB_SETCURSEL, i, 0);

  000bb	53		 push	 ebx
  000bc	50		 push	 eax
  000bd	68 4e 01 00 00	 push	 334			; 0000014eH
  000c2	ff 75 0c	 push	 DWORD PTR _hWnd$[ebp]
  000c5	ff d6		 call	 esi
  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi

; 1154 : 	return 0;

  000c9	33 c0		 xor	 eax, eax
  000cb	5b		 pop	 ebx

; 1155 : }

  000cc	c9		 leave
  000cd	c3		 ret	 0
_TlenVoiceBuildOutDeviceList ENDP
_TEXT	ENDS
END
