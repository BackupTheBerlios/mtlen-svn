	TITLE	E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\codec\gsm_preprocess.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _gsm_preprocessing
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _gsm_postprocessing
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_gsm_preprocessing
;	COMDAT _gsm_preprocessing
_TEXT	SEGMENT
_state$ = 8
_in$ = 12
_out$ = 16
_z1$ = -12
_mp$ = -4
_gsm_preprocessing PROC NEAR				; COMDAT

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 44   : 	int		z1 = state->z1;

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	c7 45 f8 a0 00
	00 00		 mov	 DWORD PTR -8+[ebp], 160	; 000000a0H
  00012	8b 98 70 06 00
	00		 mov	 ebx, DWORD PTR [eax+1648]

; 45   : 	int		z2 = state->z2;

  00018	8b b0 74 06 00
	00		 mov	 esi, DWORD PTR [eax+1652]

; 46   : 	int		mp = state->mp;

  0001e	8b 80 78 06 00
	00		 mov	 eax, DWORD PTR [eax+1656]
  00024	89 45 fc	 mov	 DWORD PTR _mp$[ebp], eax
  00027	eb 03		 jmp	 SHORT $L75802
$L75824:

; 44   : 	int		z1 = state->z1;

  00029	8b 5d f4	 mov	 ebx, DWORD PTR _z1$[ebp]
$L75802:

; 47   : 	int		so, s1;
; 48   : 	int		msp, lsp;
; 49   : 
; 50   : 	int		k = 160;
; 51   : 
; 52   : 	while (k--) {
; 53   :    /*  Downscaling of the input signal
; 54   :  *      in:  0.1.....................12
; 55   :  *        S.v.v.v.v.v.v.v.v.v.v.v.v.*.*.*
; 56   :  *      out:   0.1................... 12
; 57   :  *        S.S.v.v.v.v.v.v.v.v.v.v.v.v.0.0
; 58   :  */
; 59   : 		so = (*in >> 3) << 2;

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _in$[ebp]

; 60   : 		in++;

  0002f	83 45 0c 02	 add	 DWORD PTR _in$[ebp], 2
  00033	0f bf 10	 movsx	 edx, WORD PTR [eax]
  00036	d1 fa		 sar	 edx, 1
  00038	83 e2 fc	 and	 edx, -4			; fffffffcH

; 61   :    /*  4.2.2   Offset compensation
; 62   :     *
; 63   :     *  This part implements a high-pass filter and requires extended
; 64   :     *  arithmetic precision for the recursive part of this filter.
; 65   :     *  The input of this procedure is the array so[0...159] and the
; 66   :     *  output the array sof[ 0...159 ].
; 67   :     */
; 68   :       /*   Compute the non-recursive part
; 69   :        */
; 70   : 		s1 = (so - z1) << 15;
; 71   : 		z1 = so;
; 72   : 		msp = z2 >> 15;

  0003b	8b c6		 mov	 eax, esi
  0003d	8b ca		 mov	 ecx, edx
  0003f	89 55 f4	 mov	 DWORD PTR _z1$[ebp], edx
  00042	c1 f8 0f	 sar	 eax, 15			; 0000000fH
  00045	2b cb		 sub	 ecx, ebx

; 73   : 		lsp = z2 - (msp	<< 15);
; 74   : 		s1 += ((lsp * 32735) + 16384) >> 15;
; 75   : 		z2 = msp * 32735 + s1;

  00047	8b d8		 mov	 ebx, eax
  00049	c1 e3 0f	 shl	 ebx, 15			; 0000000fH
  0004c	69 c0 df 7f 00
	00		 imul	 eax, 32735		; 00007fdfH
  00052	2b f3		 sub	 esi, ebx

; 76   :    /*   4.2.3  Preemphasis
; 77   :     */
; 78   : 		msp = (-28180 * mp + 16384) >> 15;
; 79   : 		mp = (z2 + 16384) >> 15;
; 80   : 		*out++ = mp + msp;

  00054	8b 5d 10	 mov	 ebx, DWORD PTR _out$[ebp]
  00057	69 f6 df 7f 00
	00		 imul	 esi, 32735		; 00007fdfH
  0005d	81 c6 00 40 00
	00		 add	 esi, 16384		; 00004000H
  00063	83 45 10 02	 add	 DWORD PTR _out$[ebp], 2
  00067	c1 e1 0f	 shl	 ecx, 15			; 0000000fH
  0006a	c1 fe 0f	 sar	 esi, 15			; 0000000fH

; 81   : 	}
; 82   : 	state->z1   = z1;
; 83   : 	state->z2 	= z2;
; 84   : 	state->mp   = mp;

  0006d	03 ce		 add	 ecx, esi
  0006f	03 c1		 add	 eax, ecx
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _mp$[ebp]
  00074	69 c9 14 6e 00
	00		 imul	 ecx, 28180		; 00006e14H
  0007a	8b f0		 mov	 esi, eax
  0007c	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  00081	2b c1		 sub	 eax, ecx
  00083	8d 8e 00 40 00
	00		 lea	 ecx, DWORD PTR [esi+16384]
  00089	c1 f8 0f	 sar	 eax, 15			; 0000000fH
  0008c	c1 f9 0f	 sar	 ecx, 15			; 0000000fH
  0008f	03 c1		 add	 eax, ecx
  00091	ff 4d f8	 dec	 DWORD PTR -8+[ebp]
  00094	89 4d fc	 mov	 DWORD PTR _mp$[ebp], ecx
  00097	66 89 03	 mov	 WORD PTR [ebx], ax
  0009a	75 8d		 jne	 SHORT $L75824
  0009c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0009f	89 b0 74 06 00
	00		 mov	 DWORD PTR [eax+1652], esi
  000a5	5e		 pop	 esi
  000a6	89 90 70 06 00
	00		 mov	 DWORD PTR [eax+1648], edx
  000ac	89 88 78 06 00
	00		 mov	 DWORD PTR [eax+1656], ecx
  000b2	5b		 pop	 ebx

; 85   : /*
; 86   : 	printf("preprocessed: \n");
; 87   : 	for (k=0;k<160;k++) {
; 88   : 		printf("%7d ", out[k]);//((float)i_lpc[i])/32768.0f);
; 89   : 	}
; 90   : 	printf("\n");
; 91   : 	*/
; 92   : }

  000b3	c9		 leave
  000b4	c3		 ret	 0
_gsm_preprocessing ENDP
_TEXT	ENDS
PUBLIC	_gsm_postprocessing
;	COMDAT _gsm_postprocessing
_TEXT	SEGMENT
_state$ = 8
_in$ = 12
_out$ = 16
_gsm_postprocessing PROC NEAR				; COMDAT

; 96   : 	int k;
; 97   : 	int msr = state->msr;

  00000	8b 54 24 0c	 mov	 edx, DWORD PTR _out$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR _in$[esp-4]
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	8b 74 24 0c	 mov	 esi, DWORD PTR _state$[esp+4]
  0000e	57		 push	 edi
  0000f	bf a0 00 00 00	 mov	 edi, 160		; 000000a0H
  00014	8b 86 7c 06 00
	00		 mov	 eax, DWORD PTR [esi+1660]
$L75813:

; 98   : 	for (k = 160; k--; in++, out++) {
; 99   : 		msr = *in + ((msr * 28180 + 16384) >>15); 	   /* Deemphasis 	     */

  0001a	69 c0 14 6e 00
	00		 imul	 eax, 28180		; 00006e14H
  00020	0f bf 19	 movsx	 ebx, WORD PTR [ecx]
  00023	05 00 40 00 00	 add	 eax, 16384		; 00004000H
  00028	c1 f8 0f	 sar	 eax, 15			; 0000000fH
  0002b	03 c3		 add	 eax, ebx

; 100  : 		*out  = (msr + msr ) & 0xFFF8;  		   /* Truncation & Upscaling */

  0002d	8d 1c 00	 lea	 ebx, DWORD PTR [eax+eax]
  00030	83 e3 f8	 and	 ebx, -8			; fffffff8H
  00033	41		 inc	 ecx
  00034	66 89 1a	 mov	 WORD PTR [edx], bx
  00037	41		 inc	 ecx
  00038	42		 inc	 edx
  00039	42		 inc	 edx
  0003a	4f		 dec	 edi
  0003b	75 dd		 jne	 SHORT $L75813

; 101  : 	}
; 102  : 	state->msr = msr;

  0003d	89 86 7c 06 00
	00		 mov	 DWORD PTR [esi+1660], eax
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx

; 103  : }

  00046	c3		 ret	 0
_gsm_postprocessing ENDP
_TEXT	ENDS
END
