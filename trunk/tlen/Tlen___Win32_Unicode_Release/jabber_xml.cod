	TITLE	E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\jabber_xml.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BG@FJFA@Miranda?1System?1GetMMI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@DNA@Miranda?1System?1GetLI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@FHMP@Miranda?1System?1GetUTFI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@DCOH@Miranda?1Thread?1Fork?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@IENN@Miranda?1Thread?1ForkEx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FGIN@Miranda?1SysTerm?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@LIGC@Utils?1AddToWindowList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@PEAI@Utils?1RemoveFromWindowList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@GMNB@Utils?1FindWindowInList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@NOMI@Utils?1BroadcastToWindowList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@CFCA@Utils?1BroadcastToWindowListAsync@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@MDKL@Utils?1SaveWindowPos?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@GALP@Utils?1RestoreWindowPos?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@CHLF@Miranda?1System?1GetMD5I?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@FOPF@Miranda?1System?1GetSHA1I?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@OCFE@Netlib?1CloseHandle?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@EFDJ@Netlib?1Send?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@GFGB@Netlib?1Recv?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@CMGK@Netlib?1Log?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@GDOO@Netlib?1InitSecurityProvider?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@JINJ@Netlib?1DestroySecurityProvider?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@CBFG@Netlib?1NtlmCreateResponse?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@COCL@Proto?1EnumAccounts?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CCNI@Proto?1GetAccount?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@IFFL@Proto?1BroadcastAck?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@MGBG@DB?1Event?1GetText?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@HANO@DB?1Contact?1GetSetting?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@BEPM@DB?1Contact?1GetSettingStr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@OGAJ@DB?1Contact?1FreeVariant?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@FLKM@C?3?2MirandaDev?2miranda_svn2?2inclu@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@IGCO@DB?1Contact?1DeleteSetting?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@PLGC@DB?1Contact?1WriteSetting?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@GNEH@LangPack?1TranslateDialog?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@GFNK@Skin?1Icons?1Load?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@BLFF@Skin?1Icons?1LoadProto?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@CNOA@Skin?1Sounds?1AddNew?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@LENC@Skin?1Sounds?1Play?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@PNGM@PopUp?1AddPopUp?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@OBDC@PopUp?1AddPopUpEx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@CGKI@PopUp?1AddPopUpW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@HIHP@PopUp?1GetContact?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@CCHD@PopUp?1GetPluginData?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@HKEA@PopUp?1IsSecondLineShown?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@KGOE@PopUp?1Changetext?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LAPD@PopUp?1ChangetextW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@KOPP@PopUp?1Change?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@BGJ@PopUp?1ShowMessage?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@NFFE@PopUp?1ShowMessageW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@MAHO@PopUp?1AddPopupClass?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NGIK@?$DPxml?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _DBGetContactSettingByte_Helper
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBGetContactSettingWord_Helper
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBGetContactSettingDword_Helper
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBGetContactSettingString_Helper
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DBFreeVariant
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlInitState
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlDestroyState
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlSetCallback
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlParse
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlParseAttr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlProcessElem
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlGetAttrValue
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlGetChild
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlGetNthChild
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlGetChildWithGivenAttrValue
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlRemoveChild
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlFreeNode
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlCopyNode
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlCreateNode
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlAddAttr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlAddChild
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _JabberXmlAddText
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_JabberXmlInitState
;	COMDAT _JabberXmlInitState
_TEXT	SEGMENT
_xmlState$ = 8
_JabberXmlInitState PROC NEAR				; COMDAT

; 32   : 	if (xmlState == NULL) return;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _xmlState$[esp-4]
  00004	33 c9		 xor	 ecx, ecx
  00006	3b c1		 cmp	 eax, ecx
  00008	74 35		 je	 SHORT $L82820

; 33   : 	xmlState->root.name = NULL;

  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 34   : 	xmlState->root.depth = 0;

  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 35   : 	xmlState->root.numAttr = 0;

  0000f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 36   : 	xmlState->root.maxNumAttr = 0;

  00012	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 37   : 	xmlState->root.attr = NULL;

  00015	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 38   : 	xmlState->root.numChild = 0;

  00018	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 39   : 	xmlState->root.maxNumChild = 0;

  0001b	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 40   : 	xmlState->root.child = NULL;

  0001e	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 41   : 	xmlState->root.text = NULL;

  00021	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 42   : 	xmlState->root.state = NODE_OPEN;

  00024	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 43   : 	xmlState->callback1_open = NULL;

  00027	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 44   : 	xmlState->callback1_close = NULL;

  0002a	89 48 2c	 mov	 DWORD PTR [eax+44], ecx

; 45   : 	xmlState->callback2_open = NULL;

  0002d	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 46   : 	xmlState->callback2_close = NULL;

  00030	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 47   : 	xmlState->userdata1_open = NULL;

  00033	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 48   : 	xmlState->userdata1_close = NULL;

  00036	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 49   : 	xmlState->userdata2_open = NULL;

  00039	89 48 40	 mov	 DWORD PTR [eax+64], ecx

; 50   : 	xmlState->userdata2_close = NULL;

  0003c	89 48 44	 mov	 DWORD PTR [eax+68], ecx
$L82820:

; 51   : }

  0003f	c3		 ret	 0
_JabberXmlInitState ENDP
_TEXT	ENDS
PUBLIC	_JabberXmlDestroyState
PUBLIC	_JabberXmlFreeNode
EXTRN	_mmi:BYTE
;	COMDAT _JabberXmlDestroyState
_TEXT	SEGMENT
_xmlState$ = 8
_JabberXmlDestroyState PROC NEAR			; COMDAT

; 54   : {

  00000	56		 push	 esi

; 55   : 	int i;
; 56   : 	XmlNode *node;
; 57   : 
; 58   : 	if (xmlState == NULL) return;

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _xmlState$[esp]
  00005	85 f6		 test	 esi, esi
  00007	0f 84 9a 00 00
	00		 je	 $L82853
  0000d	57		 push	 edi

; 59   : 	// Note: cannot use JabberXmlFreeNode() to free xmlState->root
; 60   : 	// because it will do mir_free(xmlState->root) which is not freeable.
; 61   : 	node = &(xmlState->root);
; 62   : 	// Free all children first
; 63   : 	for (i=0; i<node->numChild; i++)

  0000e	33 ff		 xor	 edi, edi
  00010	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00013	7e 12		 jle	 SHORT $L82844
$L82842:

; 64   : 		JabberXmlFreeNode(node->child[i]);

  00015	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00018	ff 34 b8	 push	 DWORD PTR [eax+edi*4]
  0001b	e8 00 00 00 00	 call	 _JabberXmlFreeNode
  00020	47		 inc	 edi
  00021	59		 pop	 ecx
  00022	3b 7e 14	 cmp	 edi, DWORD PTR [esi+20]
  00025	7c ee		 jl	 SHORT $L82842
$L82844:

; 65   : 	if (node->child) mir_free(node->child);

  00027	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0002a	85 c0		 test	 eax, eax
  0002c	74 08		 je	 SHORT $L82845
  0002e	50		 push	 eax
  0002f	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00035	59		 pop	 ecx
$L82845:

; 66   : 	// Free all attributes
; 67   : 	for (i=0; i<node->numAttr; i++) {

  00036	33 ff		 xor	 edi, edi
  00038	39 7e 08	 cmp	 DWORD PTR [esi+8], edi
  0003b	7e 3c		 jle	 SHORT $L82848
$L82846:

; 68   : 		if (node->attr[i]->name) mir_free(node->attr[i]->name);

  0003d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00040	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	85 c0		 test	 eax, eax
  00047	74 08		 je	 SHORT $L82849
  00049	50		 push	 eax
  0004a	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00050	59		 pop	 ecx
$L82849:

; 69   : 		if (node->attr[i]->value) mir_free(node->attr[i]->value);

  00051	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00054	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	85 c0		 test	 eax, eax
  0005c	74 08		 je	 SHORT $L82850
  0005e	50		 push	 eax
  0005f	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00065	59		 pop	 ecx
$L82850:

; 70   : 		mir_free(node->attr[i]);

  00066	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00069	ff 34 b8	 push	 DWORD PTR [eax+edi*4]
  0006c	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00072	47		 inc	 edi
  00073	59		 pop	 ecx
  00074	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  00077	7c c4		 jl	 SHORT $L82846
$L82848:

; 71   : 	}
; 72   : 	if (node->attr) mir_free(node->attr);

  00079	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0007c	5f		 pop	 edi
  0007d	85 c0		 test	 eax, eax
  0007f	74 08		 je	 SHORT $L82851
  00081	50		 push	 eax
  00082	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00088	59		 pop	 ecx
$L82851:

; 73   : 	// Free string field
; 74   : 	if (node->text) mir_free(node->text);

  00089	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0008c	85 c0		 test	 eax, eax
  0008e	74 08		 je	 SHORT $L82852
  00090	50		 push	 eax
  00091	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00097	59		 pop	 ecx
$L82852:

; 75   : 	if (node->name) mir_free(node->name);

  00098	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0009b	85 f6		 test	 esi, esi
  0009d	74 08		 je	 SHORT $L82853
  0009f	56		 push	 esi
  000a0	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  000a6	59		 pop	 ecx
$L82853:
  000a7	5e		 pop	 esi

; 76   : }

  000a8	c3		 ret	 0
_JabberXmlDestroyState ENDP
_TEXT	ENDS
PUBLIC	_JabberXmlSetCallback
;	COMDAT _JabberXmlSetCallback
_TEXT	SEGMENT
_xmlState$ = 8
_depth$ = 12
_type$ = 16
_callback$ = 20
_userdata$ = 24
_JabberXmlSetCallback PROC NEAR				; COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 80   : 	if (depth==1 && type==ELEM_OPEN) {

  00003	6a 01		 push	 1
  00005	58		 pop	 eax
  00006	39 45 0c	 cmp	 DWORD PTR _depth$[ebp], eax
  00009	75 2d		 jne	 SHORT $L82867
  0000b	83 7d 10 00	 cmp	 DWORD PTR _type$[ebp], 0
  0000f	75 11		 jne	 SHORT $L83342

; 81   : 		xmlState->callback1_open = callback;

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _xmlState$[ebp]
  00014	8b 55 14	 mov	 edx, DWORD PTR _callback$[ebp]
  00017	89 51 28	 mov	 DWORD PTR [ecx+40], edx

; 82   : 		xmlState->userdata1_open = userdata;

  0001a	8b 55 18	 mov	 edx, DWORD PTR _userdata$[ebp]
  0001d	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 98   : 
; 99   : 	return TRUE;
; 100  : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
$L83342:

; 83   : 	}
; 84   : 	else if (depth==1 && type==ELEM_CLOSE) {

  00022	39 45 10	 cmp	 DWORD PTR _type$[ebp], eax
  00025	75 44		 jne	 SHORT $L82871

; 85   : 		xmlState->callback1_close = callback;

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _xmlState$[ebp]
  0002a	8b 55 14	 mov	 edx, DWORD PTR _callback$[ebp]
  0002d	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 86   : 		xmlState->userdata1_close = userdata;

  00030	8b 55 18	 mov	 edx, DWORD PTR _userdata$[ebp]
  00033	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 98   : 
; 99   : 	return TRUE;
; 100  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$L82867:

; 87   : 	}
; 88   : 	else if (depth==2 && type==ELEM_OPEN) {

  00038	83 7d 0c 02	 cmp	 DWORD PTR _depth$[ebp], 2
  0003c	75 2d		 jne	 SHORT $L82871
  0003e	83 7d 10 00	 cmp	 DWORD PTR _type$[ebp], 0
  00042	75 11		 jne	 SHORT $L83343

; 89   : 		xmlState->callback2_open = callback;

  00044	8b 4d 08	 mov	 ecx, DWORD PTR _xmlState$[ebp]
  00047	8b 55 14	 mov	 edx, DWORD PTR _callback$[ebp]
  0004a	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 90   : 		xmlState->userdata2_open = userdata;

  0004d	8b 55 18	 mov	 edx, DWORD PTR _userdata$[ebp]
  00050	89 51 40	 mov	 DWORD PTR [ecx+64], edx

; 98   : 
; 99   : 	return TRUE;
; 100  : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$L83343:

; 91   : 	}
; 92   : 	else if (depth==2 && type==ELEM_CLOSE) {

  00055	39 45 10	 cmp	 DWORD PTR _type$[ebp], eax
  00058	75 11		 jne	 SHORT $L82871

; 93   : 		xmlState->callback2_close = callback;

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _xmlState$[ebp]
  0005d	8b 55 14	 mov	 edx, DWORD PTR _callback$[ebp]
  00060	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 94   : 		xmlState->userdata2_close = userdata;

  00063	8b 55 18	 mov	 edx, DWORD PTR _userdata$[ebp]
  00066	89 51 44	 mov	 DWORD PTR [ecx+68], edx

; 98   : 
; 99   : 	return TRUE;
; 100  : }

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$L82871:

; 95   : 	}
; 96   : 	else
; 97   : 		return FALSE;

  0006b	33 c0		 xor	 eax, eax

; 98   : 
; 99   : 	return TRUE;
; 100  : }

  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
_JabberXmlSetCallback ENDP
_TEXT	ENDS
PUBLIC	_JabberXmlParse
EXTRN	__imp___pctype:DWORD
EXTRN	__imp___isctype:NEAR
EXTRN	__imp____mb_cur_max:DWORD
EXTRN	__imp__strncpy:NEAR
;	COMDAT _JabberXmlParse
_TEXT	SEGMENT
_xmlState$ = 8
_buffer$ = 12
_datalen$ = 16
_q$ = -8
_eob$ = -12
_str$ = -8
_num$ = 12
_tag$ = -64
_attr$ = -1088
_elemType$ = -4
_JabberXmlParse PROC NEAR				; COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 04 00
	00		 sub	 esp, 1088		; 00000440H

; 106  : 	char *p, *q, *r, *eob;
; 107  : 	char *str;
; 108  : 	int num;
; 109  : 	char tag[TAG_MAX_LEN];
; 110  : 	char attr[ATTR_MAX_LEN];
; 111  : 	XmlElemType elemType = 0;

  00009	83 65 fc 00	 and	 DWORD PTR _elemType$[ebp], 0
  0000d	53		 push	 ebx
  0000e	56		 push	 esi

; 112  : 
; 113  : 	eob = buffer + datalen;

  0000f	8b 75 10	 mov	 esi, DWORD PTR _datalen$[ebp]
  00012	57		 push	 edi
  00013	8b 7d 0c	 mov	 edi, DWORD PTR _buffer$[ebp]

; 114  : 	num = 0;

  00016	83 65 0c 00	 and	 DWORD PTR _num$[ebp], 0
  0001a	8d 1c 37	 lea	 ebx, DWORD PTR [edi+esi]
  0001d	89 5d f4	 mov	 DWORD PTR _eob$[ebp], ebx
$L83370:

; 115  : 	// Skip leading whitespaces
; 116  : 	for (p=buffer; p<eob && isspace(*p); p++,num++);

  00020	3b fb		 cmp	 edi, ebx
  00022	73 35		 jae	 SHORT $L83350
  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp____mb_cur_max
  00029	83 38 01	 cmp	 DWORD PTR [eax], 1
  0002c	7e 10		 jle	 SHORT $L83345
  0002e	0f be 07	 movsx	 eax, BYTE PTR [edi]
  00031	6a 08		 push	 8
  00033	50		 push	 eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___isctype
  0003a	59		 pop	 ecx
  0003b	59		 pop	 ecx
  0003c	eb 11		 jmp	 SHORT $L83346
$L83345:
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___pctype
  00044	0f be 07	 movsx	 eax, BYTE PTR [edi]
  00047	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00049	8a 04 41	 mov	 al, BYTE PTR [ecx+eax*2]
  0004c	83 e0 08	 and	 eax, 8
$L83346:
  0004f	85 c0		 test	 eax, eax
  00051	74 06		 je	 SHORT $L83350
  00053	47		 inc	 edi
  00054	ff 45 0c	 inc	 DWORD PTR _num$[ebp]
  00057	eb c7		 jmp	 SHORT $L83370
$L83350:

; 117  : 	while (num < datalen) {

  00059	39 75 0c	 cmp	 DWORD PTR _num$[ebp], esi
  0005c	0f 8d f7 01 00
	00		 jge	 $L82899
  00062	eb 03		 jmp	 SHORT $L82893
$L83365:
  00064	8b 5d f4	 mov	 ebx, DWORD PTR _eob$[ebp]
$L82893:

; 118  : 		if (*p == '<') {	// found starting bracket

  00067	80 3f 3c	 cmp	 BYTE PTR [edi], 60	; 0000003cH
  0006a	0f 85 85 01 00
	00		 jne	 $L82895

; 119  : 			for (q=p+1; q<eob && *q!='>'; q++);

  00070	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  00073	8b c1		 mov	 eax, ecx
  00075	3b c3		 cmp	 eax, ebx
  00077	89 45 f8	 mov	 DWORD PTR _q$[ebp], eax
  0007a	0f 83 d9 01 00
	00		 jae	 $L82899
$L82896:
  00080	80 38 3e	 cmp	 BYTE PTR [eax], 62	; 0000003eH
  00083	74 08		 je	 SHORT $L82898
  00085	40		 inc	 eax
  00086	3b c3		 cmp	 eax, ebx
  00088	89 45 f8	 mov	 DWORD PTR _q$[ebp], eax
  0008b	72 f3		 jb	 SHORT $L82896
$L82898:

; 120  : 			if (q < eob) {	// found closing bracket

  0008d	3b c3		 cmp	 eax, ebx
  0008f	0f 83 c4 01 00
	00		 jae	 $L82899

; 121  : 				for (r=p+1; *r!='>' && *r!=' ' && *r!='\t'; r++);

  00095	8b d9		 mov	 ebx, ecx
$L83371:
  00097	8a 03		 mov	 al, BYTE PTR [ebx]
  00099	3c 3e		 cmp	 al, 62			; 0000003eH
  0009b	74 0b		 je	 SHORT $L82902
  0009d	3c 20		 cmp	 al, 32			; 00000020H
  0009f	74 07		 je	 SHORT $L82902
  000a1	3c 09		 cmp	 al, 9
  000a3	74 03		 je	 SHORT $L82902
  000a5	43		 inc	 ebx
  000a6	eb ef		 jmp	 SHORT $L83371
$L82902:

; 122  : 				if (r-(p+1) > TAG_MAX_LEN) {

  000a8	8b f3		 mov	 esi, ebx
  000aa	2b f7		 sub	 esi, edi
  000ac	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  000af	83 f8 32	 cmp	 eax, 50			; 00000032H
  000b2	0f 8f db 00 00
	00		 jg	 $L82914

; 123  : //					JabberLog("TAG_MAX_LEN too small, ignore current tag");
; 124  : 				}
; 125  : 				else {
; 126  : 					if (*(p+1) == '/') {	// closing tag

  000b8	80 39 2f	 cmp	 BYTE PTR [ecx], 47	; 0000002fH
  000bb	75 23		 jne	 SHORT $L82905

; 127  : 						strncpy(tag, p+2, r-(p+2));

  000bd	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  000c0	50		 push	 eax
  000c1	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  000c4	50		 push	 eax
  000c5	8d 45 c0	 lea	 eax, DWORD PTR _tag$[ebp]
  000c8	50		 push	 eax
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 128  : 						tag[r-(p+2)] = '\0';

  000d2	80 64 35 be 00	 and	 BYTE PTR _tag$[ebp+esi-2], 0

; 129  : 						elemType = ELEM_CLOSE;

  000d7	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _elemType$[ebp], 1

; 130  : 					}
; 131  : 					else {

  000de	eb 41		 jmp	 SHORT $L82908
$L82905:

; 132  : 						if (*(r-1) == '/') {	// single open/close tag

  000e0	80 7b ff 2f	 cmp	 BYTE PTR [ebx-1], 47	; 0000002fH
  000e4	75 20		 jne	 SHORT $L82907

; 133  : 							strncpy(tag, p+1, r-(p+1)-1);

  000e6	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  000e9	50		 push	 eax
  000ea	8d 45 c0	 lea	 eax, DWORD PTR _tag$[ebp]
  000ed	51		 push	 ecx
  000ee	50		 push	 eax
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy
  000f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 134  : 							tag[r-(p+1)-1] = '\0';

  000f8	80 64 35 be 00	 and	 BYTE PTR _tag$[ebp+esi-2], 0

; 135  : 							elemType = ELEM_OPENCLOSE;

  000fd	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _elemType$[ebp], 2

; 136  : 						}
; 137  : 						else {

  00104	eb 1b		 jmp	 SHORT $L82908
$L82907:

; 138  : 							strncpy(tag, p+1, r-(p+1));

  00106	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00109	50		 push	 eax
  0010a	8d 45 c0	 lea	 eax, DWORD PTR _tag$[ebp]
  0010d	51		 push	 ecx
  0010e	50		 push	 eax
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy

; 139  : 							tag[r-(p+1)] = '\0';

  00115	80 64 35 bf 00	 and	 BYTE PTR _tag$[ebp+esi-1], 0
  0011a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 140  : 							elemType = ELEM_OPEN;

  0011d	83 65 fc 00	 and	 DWORD PTR _elemType$[ebp], 0
$L82908:

; 141  : 						}
; 142  : 					}
; 143  : 					for (;r<q && (*r==' ' || *r=='\t'); r++);

  00121	8b 75 f8	 mov	 esi, DWORD PTR _q$[ebp]
$L83372:
  00124	3b de		 cmp	 ebx, esi
  00126	73 0d		 jae	 SHORT $L82911
  00128	8a 03		 mov	 al, BYTE PTR [ebx]
  0012a	3c 20		 cmp	 al, 32			; 00000020H
  0012c	74 04		 je	 SHORT $L82910
  0012e	3c 09		 cmp	 al, 9
  00130	75 03		 jne	 SHORT $L82911
$L82910:
  00132	43		 inc	 ebx
  00133	eb ef		 jmp	 SHORT $L83372
$L82911:

; 144  : 					if (q-r > ATTR_MAX_LEN) {

  00135	2b f3		 sub	 esi, ebx
  00137	81 fe 00 04 00
	00		 cmp	 esi, 1024		; 00000400H
  0013d	7f 54		 jg	 SHORT $L82914

; 145  : //						JabberLog("ATTR_MAX_LEN too small, ignore current tag");
; 146  : 					}
; 147  : 					else {
; 148  : 						strncpy(attr, r, q-r);

  0013f	56		 push	 esi
  00140	8d 85 c0 fb ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  00146	53		 push	 ebx
  00147	50		 push	 eax
  00148	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy
  0014e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 149  : 						if ((q-r)>0 && attr[q-r-1]=='/') {

  00151	85 f6		 test	 esi, esi
  00153	7e 1d		 jle	 SHORT $L82915
  00155	80 bc 35 bf fb
	ff ff 2f	 cmp	 BYTE PTR _attr$[ebp+esi-1], 47 ; 0000002fH
  0015d	8d 84 35 bf fb
	ff ff		 lea	 eax, DWORD PTR _attr$[ebp+esi-1]
  00164	75 0c		 jne	 SHORT $L82915

; 150  : 							attr[q-r-1] = '\0';

  00166	80 20 00	 and	 BYTE PTR [eax], 0

; 151  : 							elemType = ELEM_OPENCLOSE;

  00169	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _elemType$[ebp], 2

; 152  : 						}
; 153  : 						else

  00170	eb 08		 jmp	 SHORT $L82916
$L82915:

; 154  : 							attr[q-r] = '\0';

  00172	80 a4 35 c0 fb
	ff ff 00	 and	 BYTE PTR _attr$[ebp+esi], 0
$L82916:

; 155  : 						JabberXmlProcessElem(xmlState, elemType, tag, attr);

  0017a	8d 85 c0 fb ff
	ff		 lea	 eax, DWORD PTR _attr$[ebp]
  00180	50		 push	 eax
  00181	8d 45 c0	 lea	 eax, DWORD PTR _tag$[ebp]
  00184	50		 push	 eax
  00185	ff 75 fc	 push	 DWORD PTR _elemType$[ebp]
  00188	ff 75 08	 push	 DWORD PTR _xmlState$[ebp]
  0018b	e8 00 00 00 00	 call	 _JabberXmlProcessElem
  00190	83 c4 10	 add	 esp, 16			; 00000010H
$L82914:

; 156  : 					}
; 157  : 				}
; 158  : 				num += (q-p+1);

  00193	8b 45 f8	 mov	 eax, DWORD PTR _q$[ebp]
  00196	8b 55 0c	 mov	 edx, DWORD PTR _num$[ebp]
  00199	8b c8		 mov	 ecx, eax
  0019b	2b cf		 sub	 ecx, edi

; 159  : 				p = q + 1;
; 160  : 				if (elemType==ELEM_CLOSE || elemType==ELEM_OPENCLOSE) {

  0019d	83 7d fc 01	 cmp	 DWORD PTR _elemType$[ebp], 1
  001a1	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  001a4	8d 4c 0a 01	 lea	 ecx, DWORD PTR [edx+ecx+1]
  001a8	89 4d 0c	 mov	 DWORD PTR _num$[ebp], ecx
  001ab	74 0a		 je	 SHORT $L83373
  001ad	83 7d fc 02	 cmp	 DWORD PTR _elemType$[ebp], 2
  001b1	0f 85 96 00 00
	00		 jne	 $L82930
$L83373:

; 161  : 					// Skip whitespaces after end tags
; 162  : 					for (; p<eob && isspace(*p); p++,num++);

  001b7	3b 7d f4	 cmp	 edi, DWORD PTR _eob$[ebp]
  001ba	0f 83 8d 00 00
	00		 jae	 $L82930
  001c0	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp____mb_cur_max
  001c5	83 38 01	 cmp	 DWORD PTR [eax], 1
  001c8	7e 10		 jle	 SHORT $L83347
  001ca	0f be 07	 movsx	 eax, BYTE PTR [edi]
  001cd	6a 08		 push	 8
  001cf	50		 push	 eax
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___isctype
  001d6	59		 pop	 ecx
  001d7	59		 pop	 ecx
  001d8	eb 11		 jmp	 SHORT $L83348
$L83347:
  001da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___pctype
  001e0	0f be 07	 movsx	 eax, BYTE PTR [edi]
  001e3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001e5	8a 04 41	 mov	 al, BYTE PTR [ecx+eax*2]
  001e8	83 e0 08	 and	 eax, 8
$L83348:
  001eb	85 c0		 test	 eax, eax
  001ed	74 5e		 je	 SHORT $L82930
  001ef	47		 inc	 edi
  001f0	ff 45 0c	 inc	 DWORD PTR _num$[ebp]

; 163  : 				}
; 164  : 			}
; 165  : 			else
; 166  : 				break;
; 167  : 		}
; 168  : 		else {	// found inner text

  001f3	eb c2		 jmp	 SHORT $L83373
$L82895:

; 169  : 			for (q=p+1; q<eob && *q!='<'; q++);

  001f5	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  001f8	3b f3		 cmp	 esi, ebx
  001fa	73 5d		 jae	 SHORT $L82899
$L82924:
  001fc	80 3e 3c	 cmp	 BYTE PTR [esi], 60	; 0000003cH
  001ff	74 05		 je	 SHORT $L82926
  00201	46		 inc	 esi
  00202	3b f3		 cmp	 esi, ebx
  00204	72 f6		 jb	 SHORT $L82924
$L82926:

; 170  : 			if (q < eob) {	// found starting bracket of the next element

  00206	3b f3		 cmp	 esi, ebx
  00208	73 4f		 jae	 SHORT $L82899

; 171  : 				str = (char *) mir_alloc(q-p+1);

  0020a	8b de		 mov	 ebx, esi
  0020c	2b df		 sub	 ebx, edi
  0020e	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00211	50		 push	 eax
  00212	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4

; 172  : 				strncpy(str, p, q-p);

  00218	53		 push	 ebx
  00219	57		 push	 edi
  0021a	50		 push	 eax
  0021b	89 45 f8	 mov	 DWORD PTR _str$[ebp], eax
  0021e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy

; 173  : 				str[q-p] = '\0';

  00224	8b 45 f8	 mov	 eax, DWORD PTR _str$[ebp]

; 174  : 				JabberXmlProcessElem(xmlState, ELEM_TEXT, str, NULL);

  00227	6a 00		 push	 0
  00229	ff 75 f8	 push	 DWORD PTR _str$[ebp]
  0022c	2b c7		 sub	 eax, edi
  0022e	80 24 30 00	 and	 BYTE PTR [eax+esi], 0
  00232	6a 03		 push	 3
  00234	ff 75 08	 push	 DWORD PTR _xmlState$[ebp]
  00237	e8 00 00 00 00	 call	 _JabberXmlProcessElem

; 175  : 				mir_free(str);

  0023c	ff 75 f8	 push	 DWORD PTR _str$[ebp]
  0023f	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00245	83 c4 24	 add	 esp, 36			; 00000024H

; 176  : 				num += (q-p);

  00248	01 5d 0c	 add	 DWORD PTR _num$[ebp], ebx

; 177  : 				p = q;

  0024b	8b fe		 mov	 edi, esi
$L82930:
  0024d	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00250	3b 45 10	 cmp	 eax, DWORD PTR _datalen$[ebp]
  00253	0f 8c 0b fe ff
	ff		 jl	 $L83365
$L82899:

; 178  : 			}
; 179  : 			else
; 180  : 				break;
; 181  : 		}
; 182  : 	}
; 183  : 
; 184  : 	return num;

  00259	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  0025c	5f		 pop	 edi
  0025d	5e		 pop	 esi
  0025e	5b		 pop	 ebx

; 185  : }

  0025f	c9		 leave
  00260	c3		 ret	 0
_JabberXmlParse ENDP
_TEXT	ENDS
PUBLIC	??_C@_04NGIK@?$DPxml?$AA@			; `string'
EXTRN	_strcmp:NEAR
;	COMDAT ??_C@_04NGIK@?$DPxml?$AA@
; File E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\jabber_xml.c
_DATA	SEGMENT
??_C@_04NGIK@?$DPxml?$AA@ DB '?xml', 00H		; `string'
_DATA	ENDS
;	COMDAT _JabberXmlProcessElem
_TEXT	SEGMENT
_xmlState$ = 8
_elemType$ = 12
_elemText$ = 16
_elemAttr$ = 20
_parentNode$ = 8
_text$ = -4
_attr$ = 16
_JabberXmlProcessElem PROC NEAR				; COMDAT

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 274  : 	XmlNode *node, *parentNode, *n;
; 275  : 	//BOOL activateCallback = FALSE;
; 276  : 	char *text, *attr;
; 277  : 
; 278  : 	if (elemText == NULL) return FALSE;

  00007	33 ff		 xor	 edi, edi
  00009	39 7d 10	 cmp	 DWORD PTR _elemText$[ebp], edi
  0000c	0f 84 9f 00 00
	00		 je	 $L83054

; 279  : 
; 280  : 	if (elemType==ELEM_OPEN && !strcmp(elemText, "?xml")) {

  00012	39 7d 0c	 cmp	 DWORD PTR _elemType$[ebp], edi
  00015	75 17		 jne	 SHORT $L83006
  00017	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04NGIK@?$DPxml?$AA@ ; `string'
  0001c	ff 75 10	 push	 DWORD PTR _elemText$[ebp]
  0001f	e8 00 00 00 00	 call	 _strcmp
  00024	59		 pop	 ecx
  00025	85 c0		 test	 eax, eax
  00027	59		 pop	 ecx

; 281  : //		JabberLog("XML: skip <?xml> tag");
; 282  : 		return TRUE;

  00028	0f 84 58 02 00
	00		 je	 $L83058
$L83006:

; 283  : 	}
; 284  : 
; 285  : 	// Find active node
; 286  : 	node = &(xmlState->root);

  0002e	8b 5d 08	 mov	 ebx, DWORD PTR _xmlState$[ebp]

; 287  : 	parentNode = NULL;

  00031	89 7d 08	 mov	 DWORD PTR _parentNode$[ebp], edi
  00034	8b f3		 mov	 esi, ebx

; 288  : 	while (node->numChild>0 && node->child[node->numChild-1]->state==NODE_OPEN) {

  00036	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
$L83380:
  00039	3b c7		 cmp	 eax, edi
  0003b	7e 16		 jle	 SHORT $L83011
  0003d	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00040	8b 44 81 fc	 mov	 eax, DWORD PTR [ecx+eax*4-4]
  00044	39 78 24	 cmp	 DWORD PTR [eax+36], edi
  00047	75 0a		 jne	 SHORT $L83011

; 289  : 		parentNode = node;

  00049	89 75 08	 mov	 DWORD PTR _parentNode$[ebp], esi

; 290  : 		node = node->child[node->numChild-1];

  0004c	8b f0		 mov	 esi, eax
  0004e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00051	eb e6		 jmp	 SHORT $L83380
$L83011:

; 291  : 	}
; 292  : 
; 293  : 	if (node->state != NODE_OPEN) return FALSE;

  00053	39 7e 24	 cmp	 DWORD PTR [esi+36], edi
  00056	75 59		 jne	 SHORT $L83054

; 294  : 
; 295  : 	text = mir_strdup(elemText);

  00058	ff 75 10	 push	 DWORD PTR _elemText$[ebp]
  0005b	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20

; 296  : 
; 297  : 	if (elemAttr)

  00061	83 7d 14 00	 cmp	 DWORD PTR _elemAttr$[ebp], 0
  00065	8b f8		 mov	 edi, eax
  00067	59		 pop	 ecx
  00068	89 7d fc	 mov	 DWORD PTR _text$[ebp], edi
  0006b	74 0f		 je	 SHORT $L83013

; 298  : 		attr = mir_strdup(elemAttr);

  0006d	ff 75 14	 push	 DWORD PTR _elemAttr$[ebp]
  00070	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  00076	59		 pop	 ecx
  00077	89 45 10	 mov	 DWORD PTR _attr$[ebp], eax

; 299  : 	else

  0007a	eb 04		 jmp	 SHORT $L83014
$L83013:

; 300  : 		attr = NULL;

  0007c	83 65 10 00	 and	 DWORD PTR _attr$[ebp], 0
$L83014:

; 301  : 
; 302  : 	switch (elemType) {

  00080	8b 45 0c	 mov	 eax, DWORD PTR _elemType$[ebp]
  00083	83 e8 00	 sub	 eax, 0
  00086	0f 84 53 01 00
	00		 je	 $L83020
  0008c	48		 dec	 eax
  0008d	0f 84 e3 00 00
	00		 je	 $L83046
  00093	48		 dec	 eax
  00094	74 2a		 je	 SHORT $L83033
  00096	48		 dec	 eax
  00097	74 1f		 je	 SHORT $L83055
$L83048:

; 372  : 	default:
; 373  : 		mir_free(text);

  00099	57		 push	 edi
  0009a	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12

; 374  : 		if (attr) mir_free(attr);

  000a0	83 7d 10 00	 cmp	 DWORD PTR _attr$[ebp], 0
  000a4	59		 pop	 ecx
  000a5	74 0a		 je	 SHORT $L83054
  000a7	ff 75 10	 push	 DWORD PTR _attr$[ebp]
  000aa	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  000b0	59		 pop	 ecx
$L83054:

; 375  : 		return FALSE;

  000b1	33 c0		 xor	 eax, eax
  000b3	e9 d1 01 00 00	 jmp	 $L82998
$L83055:

; 369  : 	case ELEM_TEXT:
; 370  : 		node->text = text;

  000b8	89 7e 20	 mov	 DWORD PTR [esi+32], edi

; 371  : 		break;

  000bb	e9 b6 01 00 00	 jmp	 $L83032
$L83033:

; 323  : 		break;
; 324  : 	case ELEM_OPENCLOSE:
; 325  : 		if (node->numChild >= node->maxNumChild) {

  000c0	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000c3	3b 46 18	 cmp	 eax, DWORD PTR [esi+24]
  000c6	7c 18		 jl	 SHORT $L83034

; 326  : 			node->maxNumChild = node->numChild + 20;

  000c8	83 c0 14	 add	 eax, 20			; 00000014H
  000cb	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 327  : 			node->child = (XmlNode **) mir_realloc(node->child, node->maxNumChild*sizeof(XmlNode *));

  000ce	c1 e0 02	 shl	 eax, 2
  000d1	50		 push	 eax
  000d2	ff 76 1c	 push	 DWORD PTR [esi+28]
  000d5	ff 15 08 00 00
	00		 call	 DWORD PTR _mmi+8
  000db	59		 pop	 ecx
  000dc	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  000df	59		 pop	 ecx
$L83034:

; 328  : 		}
; 329  : 		n = node->child[node->numChild] = (XmlNode *) mir_alloc(sizeof(XmlNode));

  000e0	6a 28		 push	 40			; 00000028H
  000e2	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  000e8	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  000eb	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]

; 330  : 		node->numChild++;
; 331  : 		n->name = text;
; 332  : 		n->depth = node->depth + 1;
; 333  : 		n->state = NODE_CLOSE;
; 334  : 		n->numChild = n->maxNumAttr = 0;
; 335  : 		n->child = NULL;
; 336  : 		n->numAttr = n->maxNumAttr = 0;
; 337  : 		n->attr = NULL;
; 338  : 		JabberXmlParseAttr(n, attr);

  000ee	ff 75 10	 push	 DWORD PTR _attr$[ebp]
  000f1	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  000f4	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000f7	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  000fa	8b 3c 81	 mov	 edi, DWORD PTR [ecx+eax*4]
  000fd	40		 inc	 eax
  000fe	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00101	8b 45 fc	 mov	 eax, DWORD PTR _text$[ebp]
  00104	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00107	8b 06		 mov	 eax, DWORD PTR [esi]
  00109	40		 inc	 eax
  0010a	57		 push	 edi
  0010b	89 07		 mov	 DWORD PTR [edi], eax
  0010d	33 c0		 xor	 eax, eax
  0010f	c7 47 24 01 00
	00 00		 mov	 DWORD PTR [edi+36], 1
  00116	89 47 14	 mov	 DWORD PTR [edi+20], eax
  00119	89 47 1c	 mov	 DWORD PTR [edi+28], eax
  0011c	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  0011f	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00122	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00125	e8 00 00 00 00	 call	 _JabberXmlParseAttr

; 339  : 		n->text = NULL;

  0012a	83 67 20 00	 and	 DWORD PTR [edi+32], 0
  0012e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 340  : 		if (n->depth==1 && xmlState->callback1_close!=NULL) {

  00131	83 3f 01	 cmp	 DWORD PTR [edi], 1
  00134	75 17		 jne	 SHORT $L83043
  00136	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  00139	85 c0		 test	 eax, eax
  0013b	74 10		 je	 SHORT $L83043

; 341  : 			(*(xmlState->callback1_close))(n, xmlState->userdata1_close);

  0013d	ff 73 3c	 push	 DWORD PTR [ebx+60]
  00140	57		 push	 edi
  00141	ff d0		 call	 eax

; 342  : 			JabberXmlRemoveChild(node, n);

  00143	57		 push	 edi
  00144	56		 push	 esi
  00145	e8 00 00 00 00	 call	 _JabberXmlRemoveChild
  0014a	83 c4 10	 add	 esp, 16			; 00000010H
$L83043:

; 343  : 		}
; 344  : 		if (n->depth==2 && xmlState->callback2_close!=NULL) {

  0014d	83 3f 02	 cmp	 DWORD PTR [edi], 2
  00150	0f 85 20 01 00
	00		 jne	 $L83032
  00156	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00159	85 c0		 test	 eax, eax
  0015b	0f 84 15 01 00
	00		 je	 $L83032

; 345  : 			(*xmlState->callback2_close)(n, xmlState->userdata2_close);

  00161	ff 73 44	 push	 DWORD PTR [ebx+68]
  00164	57		 push	 edi
  00165	ff d0		 call	 eax

; 346  : 			JabberXmlRemoveChild(node, n);

  00167	57		 push	 edi
  00168	56		 push	 esi
  00169	e8 00 00 00 00	 call	 _JabberXmlRemoveChild
  0016e	83 c4 10	 add	 esp, 16			; 00000010H

; 347  : 		}
; 348  : 		break;

  00171	e9 00 01 00 00	 jmp	 $L83032
$L83046:

; 349  : 	case ELEM_CLOSE:
; 350  : 		if (node->name!=NULL && !strcmp(node->name, text)) {

  00176	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00179	85 c0		 test	 eax, eax
  0017b	0f 84 18 ff ff
	ff		 je	 $L83048
  00181	57		 push	 edi
  00182	50		 push	 eax
  00183	e8 00 00 00 00	 call	 _strcmp
  00188	59		 pop	 ecx
  00189	85 c0		 test	 eax, eax
  0018b	59		 pop	 ecx
  0018c	0f 85 07 ff ff
	ff		 jne	 $L83048

; 351  : 			node->state = NODE_CLOSE;

  00192	6a 01		 push	 1
  00194	58		 pop	 eax

; 352  : 			if (node->depth==1 && xmlState->callback1_close!=NULL) {

  00195	39 06		 cmp	 DWORD PTR [esi], eax
  00197	89 46 24	 mov	 DWORD PTR [esi+36], eax
  0019a	75 19		 jne	 SHORT $L83050
  0019c	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  0019f	85 c0		 test	 eax, eax
  001a1	74 12		 je	 SHORT $L83050

; 353  : 				(*(xmlState->callback1_close))(node, xmlState->userdata1_close);

  001a3	ff 73 3c	 push	 DWORD PTR [ebx+60]
  001a6	56		 push	 esi
  001a7	ff d0		 call	 eax

; 354  : 				JabberXmlRemoveChild(parentNode, node);

  001a9	56		 push	 esi
  001aa	ff 75 08	 push	 DWORD PTR _parentNode$[ebp]
  001ad	e8 00 00 00 00	 call	 _JabberXmlRemoveChild
  001b2	83 c4 10	 add	 esp, 16			; 00000010H
$L83050:

; 355  : 			}
; 356  : 			if (node->depth==2 && xmlState->callback2_close!=NULL) {

  001b5	83 3e 02	 cmp	 DWORD PTR [esi], 2
  001b8	75 19		 jne	 SHORT $L83052
  001ba	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  001bd	85 c0		 test	 eax, eax
  001bf	74 12		 je	 SHORT $L83052

; 357  : 				(*xmlState->callback2_close)(node, xmlState->userdata2_close);

  001c1	ff 73 44	 push	 DWORD PTR [ebx+68]
  001c4	56		 push	 esi
  001c5	ff d0		 call	 eax

; 358  : 				JabberXmlRemoveChild(parentNode, node);

  001c7	56		 push	 esi
  001c8	ff 75 08	 push	 DWORD PTR _parentNode$[ebp]
  001cb	e8 00 00 00 00	 call	 _JabberXmlRemoveChild
  001d0	83 c4 10	 add	 esp, 16			; 00000010H
$L83052:

; 359  : 			}
; 360  : 			mir_free(text);

  001d3	57		 push	 edi
  001d4	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12

; 361  : 		}
; 362  : 		else {
; 363  : //			JabberLog("XML: Closing </%s> without opening tag", text);
; 364  : 			mir_free(text);
; 365  : 			if (attr) mir_free(attr);
; 366  : 			return FALSE;
; 367  : 		}
; 368  : 		break;

  001da	e9 96 00 00 00	 jmp	 $L83381
$L83020:

; 303  : 	case ELEM_OPEN:
; 304  : 		if (node->numChild >= node->maxNumChild) {

  001df	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001e2	3b 46 18	 cmp	 eax, DWORD PTR [esi+24]
  001e5	7c 18		 jl	 SHORT $L83021

; 305  : 			node->maxNumChild = node->numChild + 20;

  001e7	83 c0 14	 add	 eax, 20			; 00000014H
  001ea	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 306  : 			node->child = (XmlNode **) mir_realloc(node->child, node->maxNumChild*sizeof(XmlNode *));

  001ed	c1 e0 02	 shl	 eax, 2
  001f0	50		 push	 eax
  001f1	ff 76 1c	 push	 DWORD PTR [esi+28]
  001f4	ff 15 08 00 00
	00		 call	 DWORD PTR _mmi+8
  001fa	59		 pop	 ecx
  001fb	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  001fe	59		 pop	 ecx
$L83021:

; 307  : 		}
; 308  : 		n = node->child[node->numChild] = (XmlNode *) mir_alloc(sizeof(XmlNode));

  001ff	6a 28		 push	 40			; 00000028H
  00201	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  00207	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0020a	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]

; 309  : 		node->numChild++;
; 310  : 		n->name = text;
; 311  : 		n->depth = node->depth + 1;
; 312  : 		n->state = NODE_OPEN;
; 313  : 		n->numChild = n->maxNumChild = 0;
; 314  : 		n->child = NULL;
; 315  : 		n->numAttr = n->maxNumAttr = 0;
; 316  : 		n->attr = NULL;
; 317  : 		JabberXmlParseAttr(n, attr);

  0020d	ff 75 10	 push	 DWORD PTR _attr$[ebp]
  00210	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  00213	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00216	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00219	8b 3c 81	 mov	 edi, DWORD PTR [ecx+eax*4]
  0021c	40		 inc	 eax
  0021d	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00220	8b 45 fc	 mov	 eax, DWORD PTR _text$[ebp]
  00223	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00226	8b 06		 mov	 eax, DWORD PTR [esi]
  00228	40		 inc	 eax
  00229	33 f6		 xor	 esi, esi
  0022b	57		 push	 edi
  0022c	89 07		 mov	 DWORD PTR [edi], eax
  0022e	89 77 24	 mov	 DWORD PTR [edi+36], esi
  00231	89 77 18	 mov	 DWORD PTR [edi+24], esi
  00234	89 77 14	 mov	 DWORD PTR [edi+20], esi
  00237	89 77 1c	 mov	 DWORD PTR [edi+28], esi
  0023a	89 77 0c	 mov	 DWORD PTR [edi+12], esi
  0023d	89 77 08	 mov	 DWORD PTR [edi+8], esi
  00240	89 77 10	 mov	 DWORD PTR [edi+16], esi
  00243	e8 00 00 00 00	 call	 _JabberXmlParseAttr
  00248	83 c4 0c	 add	 esp, 12			; 0000000cH

; 318  : 		n->text = NULL;
; 319  : 		if (n->depth==1 && xmlState->callback1_open!=NULL)

  0024b	83 3f 01	 cmp	 DWORD PTR [edi], 1
  0024e	89 77 20	 mov	 DWORD PTR [edi+32], esi
  00251	75 0f		 jne	 SHORT $L83030
  00253	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  00256	3b c6		 cmp	 eax, esi
  00258	74 08		 je	 SHORT $L83030

; 320  : 			(*(xmlState->callback1_open))(n, xmlState->userdata1_open);

  0025a	ff 73 38	 push	 DWORD PTR [ebx+56]
  0025d	57		 push	 edi
  0025e	ff d0		 call	 eax
  00260	59		 pop	 ecx
  00261	59		 pop	 ecx
$L83030:

; 321  : 		if (n->depth==2 && xmlState->callback2_open!=NULL)

  00262	83 3f 02	 cmp	 DWORD PTR [edi], 2
  00265	75 0f		 jne	 SHORT $L83032
  00267	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  0026a	85 c0		 test	 eax, eax
  0026c	74 08		 je	 SHORT $L83032

; 322  : 			(*xmlState->callback2_open)(n, xmlState->userdata2_open);

  0026e	ff 73 40	 push	 DWORD PTR [ebx+64]
  00271	57		 push	 edi
  00272	ff d0		 call	 eax
  00274	59		 pop	 ecx
$L83381:
  00275	59		 pop	 ecx
$L83032:

; 376  : 	}
; 377  : 
; 378  : 	if (attr) mir_free(attr);

  00276	83 7d 10 00	 cmp	 DWORD PTR _attr$[ebp], 0
  0027a	74 0a		 je	 SHORT $L83058
  0027c	ff 75 10	 push	 DWORD PTR _attr$[ebp]
  0027f	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00285	59		 pop	 ecx
$L83058:

; 379  : 
; 380  : 	return TRUE;

  00286	6a 01		 push	 1
  00288	58		 pop	 eax
$L82998:
  00289	5f		 pop	 edi
  0028a	5e		 pop	 esi
  0028b	5b		 pop	 ebx

; 381  : }

  0028c	c9		 leave
  0028d	c3		 ret	 0
_JabberXmlProcessElem ENDP
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
EXTRN	_strlen:NEAR
;	COMDAT ??_C@_00A@?$AA@
; File E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\jabber_xml.c
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT _JabberXmlParseAttr
_TEXT	SEGMENT
_node$ = 8
_text$ = 12
_kstart$ = 12
_vstart$ = -4
_JabberXmlParseAttr PROC NEAR				; COMDAT

; 188  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 189  : 	char *kstart, *vstart;
; 190  : 	int klen, vlen;
; 191  : 	char *p;
; 192  : 	XmlAttr *a;
; 193  : 
; 194  : 	if (node==NULL || text==NULL || strlen(text)<=0)

  00002	8b 5c 24 0c	 mov	 ebx, DWORD PTR _node$[esp+4]
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	85 db		 test	 ebx, ebx
  0000a	57		 push	 edi
  0000b	0f 84 ca 01 00
	00		 je	 $L82946
  00011	8b 6c 24 1c	 mov	 ebp, DWORD PTR _text$[esp+16]
  00015	85 ed		 test	 ebp, ebp
  00017	0f 84 be 01 00
	00		 je	 $L82946
  0001d	55		 push	 ebp
  0001e	e8 00 00 00 00	 call	 _strlen
  00023	85 c0		 test	 eax, eax
  00025	59		 pop	 ecx
  00026	0f 86 af 01 00
	00		 jbe	 $L82946
$L83399:

; 195  : 		return;
; 196  : 
; 197  : 	for (p=text;;) {
; 198  : 
; 199  : 		// Skip leading whitespaces
; 200  : 		for (;*p!='\0' && (*p==' ' || *p=='\t'); p++);

  0002c	8a 45 00	 mov	 al, BYTE PTR [ebp]
  0002f	84 c0		 test	 al, al
  00031	74 0b		 je	 SHORT $L82952
  00033	3c 20		 cmp	 al, 32			; 00000020H
  00035	74 04		 je	 SHORT $L82951
  00037	3c 09		 cmp	 al, 9
  00039	75 03		 jne	 SHORT $L82952
$L82951:
  0003b	45		 inc	 ebp
  0003c	eb ee		 jmp	 SHORT $L83399
$L82952:

; 201  : 		if (*p == '\0')

  0003e	8a 45 00	 mov	 al, BYTE PTR [ebp]
  00041	84 c0		 test	 al, al
  00043	0f 84 92 01 00
	00		 je	 $L82946

; 202  : 			break;
; 203  : 
; 204  : 		// Fetch key
; 205  : 		kstart = p;

  00049	89 6c 24 1c	 mov	 DWORD PTR _kstart$[esp+16], ebp
$L82955:

; 206  : 		for (;*p!='\0' && *p!='=' && *p!=' ' && *p!='\t'; p++);

  0004d	3c 3d		 cmp	 al, 61			; 0000003dH
  0004f	74 10		 je	 SHORT $L82957
  00051	3c 20		 cmp	 al, 32			; 00000020H
  00053	74 0c		 je	 SHORT $L82957
  00055	3c 09		 cmp	 al, 9
  00057	74 08		 je	 SHORT $L82957
  00059	8a 45 01	 mov	 al, BYTE PTR [ebp+1]
  0005c	45		 inc	 ebp
  0005d	84 c0		 test	 al, al
  0005f	75 ec		 jne	 SHORT $L82955
$L82957:

; 207  : 		klen = p-kstart;
; 208  : 
; 209  : 		if (node->numAttr >= node->maxNumAttr) {

  00061	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00064	8b fd		 mov	 edi, ebp
  00066	2b 7c 24 1c	 sub	 edi, DWORD PTR _kstart$[esp+16]
  0006a	3b 43 0c	 cmp	 eax, DWORD PTR [ebx+12]
  0006d	7c 18		 jl	 SHORT $L82958

; 210  : 			node->maxNumAttr = node->numAttr + 20;

  0006f	83 c0 14	 add	 eax, 20			; 00000014H
  00072	89 43 0c	 mov	 DWORD PTR [ebx+12], eax

; 211  : 			node->attr = (XmlAttr **) mir_realloc(node->attr, node->maxNumAttr*sizeof(XmlAttr *));

  00075	c1 e0 02	 shl	 eax, 2
  00078	50		 push	 eax
  00079	ff 73 10	 push	 DWORD PTR [ebx+16]
  0007c	ff 15 08 00 00
	00		 call	 DWORD PTR _mmi+8
  00082	59		 pop	 ecx
  00083	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  00086	59		 pop	 ecx
$L82958:

; 212  : 		}
; 213  : 		a = node->attr[node->numAttr] = (XmlAttr *) mir_alloc(sizeof(XmlAttr));

  00087	6a 08		 push	 8
  00089	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  0008f	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  00092	59		 pop	 ecx
  00093	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00096	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  00099	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0009c	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  0009f	8b 34 81	 mov	 esi, DWORD PTR [ecx+eax*4]

; 214  : 		node->numAttr++;

  000a2	40		 inc	 eax
  000a3	89 43 08	 mov	 DWORD PTR [ebx+8], eax
$L83400:

; 215  : 
; 216  : 		// Skip possible whitespaces between key and '='
; 217  : 		for (;*p!='\0' && (*p==' ' || *p=='\t'); p++);

  000a6	8a 45 00	 mov	 al, BYTE PTR [ebp]
  000a9	84 c0		 test	 al, al
  000ab	74 0b		 je	 SHORT $L82965
  000ad	3c 20		 cmp	 al, 32			; 00000020H
  000af	74 04		 je	 SHORT $L82964
  000b1	3c 09		 cmp	 al, 9
  000b3	75 03		 jne	 SHORT $L82965
$L82964:
  000b5	45		 inc	 ebp
  000b6	eb ee		 jmp	 SHORT $L83400
$L82965:

; 218  : 
; 219  : 		if (*p == '\0') {

  000b8	8a 45 00	 mov	 al, BYTE PTR [ebp]
  000bb	84 c0		 test	 al, al
  000bd	0f 84 e9 00 00
	00		 je	 $L83391

; 220  : 			a->name = (char *) mir_alloc(klen+1);
; 221  : 			strncpy(a->name, kstart, klen);
; 222  : 			a->name[klen] = '\0';
; 223  : 			a->value = mir_strdup("");
; 224  : 			break;
; 225  : 		}
; 226  : 
; 227  : 		if (*p != '=') {

  000c3	3c 3d		 cmp	 al, 61			; 0000003dH
  000c5	74 34		 je	 SHORT $L83401

; 228  : 			a->name = (char *) mir_alloc(klen+1);

  000c7	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000ca	50		 push	 eax
  000cb	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4

; 229  : 			strncpy(a->name, kstart, klen);

  000d1	57		 push	 edi
  000d2	89 06		 mov	 DWORD PTR [esi], eax
  000d4	ff 74 24 24	 push	 DWORD PTR _kstart$[esp+24]
  000d8	50		 push	 eax
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy

; 230  : 			a->name[klen] = '\0';

  000df	8b 06		 mov	 eax, DWORD PTR [esi]

; 231  : 			a->value = mir_strdup("");

  000e1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
  000e6	80 24 38 00	 and	 BYTE PTR [eax+edi], 0
  000ea	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  000f0	83 c4 14	 add	 esp, 20			; 00000014H
  000f3	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 232  : 			continue;

  000f6	e9 31 ff ff ff	 jmp	 $L83399
$L83401:

; 233  : 		}
; 234  : 
; 235  : 		// Found '='
; 236  : 		p++;
; 237  : 
; 238  : 		// Skip possible whitespaces between '=' and value
; 239  : 		for (;*p!='\0' && (*p==' ' || *p=='\t'); p++);

  000fb	8a 45 01	 mov	 al, BYTE PTR [ebp+1]
  000fe	45		 inc	 ebp
  000ff	84 c0		 test	 al, al
  00101	74 08		 je	 SHORT $L82974
  00103	3c 20		 cmp	 al, 32			; 00000020H
  00105	74 f4		 je	 SHORT $L83401
  00107	3c 09		 cmp	 al, 9
  00109	74 f0		 je	 SHORT $L83401
$L82974:

; 240  : 
; 241  : 		if (*p == '\0') {

  0010b	8a 45 00	 mov	 al, BYTE PTR [ebp]
  0010e	84 c0		 test	 al, al
  00110	0f 84 96 00 00
	00		 je	 $L83391

; 246  : 			break;
; 247  : 		}
; 248  : 
; 249  : 		// Fetch value
; 250  : 		if (*p=='\'' || *p=='"') {

  00116	3c 27		 cmp	 al, 39			; 00000027H
  00118	74 20		 je	 SHORT $L82979
  0011a	3c 22		 cmp	 al, 34			; 00000022H
  0011c	74 1c		 je	 SHORT $L82979

; 256  : 		}
; 257  : 		else {
; 258  : 			vstart = p;

  0011e	89 6c 24 10	 mov	 DWORD PTR _vstart$[esp+20], ebp
$L82985:

; 259  : 			for (;*p!='\0' && *p!=' ' && *p!='\t'; p++);

  00122	3c 20		 cmp	 al, 32			; 00000020H
  00124	74 0c		 je	 SHORT $L82987
  00126	3c 09		 cmp	 al, 9
  00128	74 08		 je	 SHORT $L82987
  0012a	8a 45 01	 mov	 al, BYTE PTR [ebp+1]
  0012d	45		 inc	 ebp
  0012e	84 c0		 test	 al, al
  00130	75 f0		 jne	 SHORT $L82985
$L82987:

; 260  : 			vlen = p-vstart;

  00132	8b dd		 mov	 ebx, ebp
  00134	2b 5c 24 10	 sub	 ebx, DWORD PTR _vstart$[esp+20]
  00138	eb 28		 jmp	 SHORT $L82983
$L82979:

; 251  : 			p++;
; 252  : 			vstart = p;
; 253  : 			for (;*p!='\0' && *p!=*(vstart-1); p++);

  0013a	8a 45 01	 mov	 al, BYTE PTR [ebp+1]
  0013d	45		 inc	 ebp
  0013e	84 c0		 test	 al, al
  00140	89 6c 24 10	 mov	 DWORD PTR _vstart$[esp+20], ebp
  00144	74 0f		 je	 SHORT $L82982
  00146	8a 4d ff	 mov	 cl, BYTE PTR [ebp-1]
$L82980:
  00149	3a c1		 cmp	 al, cl
  0014b	74 08		 je	 SHORT $L82982
  0014d	8a 45 01	 mov	 al, BYTE PTR [ebp+1]
  00150	45		 inc	 ebp
  00151	84 c0		 test	 al, al
  00153	75 f4		 jne	 SHORT $L82980
$L82982:

; 254  : 			vlen = p-vstart;

  00155	8b dd		 mov	 ebx, ebp
  00157	2b 5c 24 10	 sub	 ebx, DWORD PTR _vstart$[esp+20]

; 255  : 			if (*p != '\0') p++;

  0015b	80 7d 00 00	 cmp	 BYTE PTR [ebp], 0
  0015f	74 01		 je	 SHORT $L82983
  00161	45		 inc	 ebp
$L82983:

; 261  : 		}
; 262  : 
; 263  : 		a->name = (char *) mir_alloc(klen+1);

  00162	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00165	50		 push	 eax
  00166	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4

; 264  : 		strncpy(a->name, kstart, klen);

  0016c	57		 push	 edi
  0016d	89 06		 mov	 DWORD PTR [esi], eax
  0016f	ff 74 24 24	 push	 DWORD PTR _kstart$[esp+24]
  00173	50		 push	 eax
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy

; 265  : 		a->name[klen] = '\0';

  0017a	8b 06		 mov	 eax, DWORD PTR [esi]
  0017c	80 24 38 00	 and	 BYTE PTR [eax+edi], 0

; 266  : 		a->value = (char *) mir_alloc(vlen+1);

  00180	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00183	50		 push	 eax
  00184	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4

; 267  : 		strncpy(a->value, vstart, vlen);

  0018a	53		 push	 ebx
  0018b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0018e	ff 74 24 28	 push	 DWORD PTR _vstart$[esp+44]
  00192	50		 push	 eax
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy

; 268  : 		a->value[vlen] = '\0';

  00199	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0019c	83 c4 20	 add	 esp, 32			; 00000020H
  0019f	80 24 18 00	 and	 BYTE PTR [eax+ebx], 0

; 269  : 	}

  001a3	8b 5c 24 18	 mov	 ebx, DWORD PTR _node$[esp+16]
  001a7	e9 80 fe ff ff	 jmp	 $L83399
$L83391:

; 242  : 			a->name = (char *) mir_alloc(klen+1);

  001ac	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  001af	50		 push	 eax
  001b0	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4

; 243  : 			strncpy(a->name, kstart, klen);

  001b6	57		 push	 edi
  001b7	89 06		 mov	 DWORD PTR [esi], eax
  001b9	ff 74 24 24	 push	 DWORD PTR _kstart$[esp+24]
  001bd	50		 push	 eax
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy

; 244  : 			a->name[klen] = '\0';

  001c4	8b 06		 mov	 eax, DWORD PTR [esi]

; 245  : 			a->value = mir_strdup("");

  001c6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00A@?$AA@ ; `string'
  001cb	80 24 38 00	 and	 BYTE PTR [eax+edi], 0
  001cf	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  001d5	83 c4 14	 add	 esp, 20			; 00000014H
  001d8	89 46 04	 mov	 DWORD PTR [esi+4], eax
$L82946:
  001db	5f		 pop	 edi
  001dc	5e		 pop	 esi
  001dd	5d		 pop	 ebp
  001de	5b		 pop	 ebx

; 270  : }

  001df	59		 pop	 ecx
  001e0	c3		 ret	 0
_JabberXmlParseAttr ENDP
_TEXT	ENDS
PUBLIC	_JabberXmlGetAttrValue
;	COMDAT _JabberXmlGetAttrValue
_TEXT	SEGMENT
_node$ = 8
_key$ = 12
_JabberXmlGetAttrValue PROC NEAR			; COMDAT

; 384  : {

  00000	56		 push	 esi

; 385  : 	int i;
; 386  : 
; 387  : 	if (node==NULL || node->numAttr<=0 || key==NULL || strlen(key)<=0)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _node$[esp]
  00005	85 f6		 test	 esi, esi
  00007	57		 push	 edi
  00008	74 44		 je	 SHORT $L83072
  0000a	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  0000e	7e 3e		 jle	 SHORT $L83072
  00010	83 7c 24 10 00	 cmp	 DWORD PTR _key$[esp+4], 0
  00015	74 37		 je	 SHORT $L83072
  00017	ff 74 24 10	 push	 DWORD PTR _key$[esp+4]
  0001b	e8 00 00 00 00	 call	 _strlen
  00020	85 c0		 test	 eax, eax
  00022	59		 pop	 ecx
  00023	76 29		 jbe	 SHORT $L83072

; 389  : 	for (i=0; i<node->numAttr; i++) {

  00025	33 ff		 xor	 edi, edi
  00027	39 7e 08	 cmp	 DWORD PTR [esi+8], edi
  0002a	7e 22		 jle	 SHORT $L83072
$L83070:

; 390  : 		if (node->attr[i]->name && !strcmp(key, node->attr[i]->name))

  0002c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002f	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	85 c0		 test	 eax, eax
  00036	74 10		 je	 SHORT $L83071
  00038	50		 push	 eax
  00039	ff 74 24 14	 push	 DWORD PTR _key$[esp+8]
  0003d	e8 00 00 00 00	 call	 _strcmp
  00042	59		 pop	 ecx
  00043	85 c0		 test	 eax, eax
  00045	59		 pop	 ecx
  00046	74 0b		 je	 SHORT $L83406
$L83071:

; 389  : 	for (i=0; i<node->numAttr; i++) {

  00048	47		 inc	 edi
  00049	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004c	7c de		 jl	 SHORT $L83070
$L83072:

; 388  : 		return NULL;

  0004e	33 c0		 xor	 eax, eax
$L83063:
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 391  : 			return node->attr[i]->value;
; 392  : 	}
; 393  : 	return NULL;
; 394  : }

  00052	c3		 ret	 0
$L83406:
  00053	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00056	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00059	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005c	eb f2		 jmp	 SHORT $L83063
_JabberXmlGetAttrValue ENDP
_TEXT	ENDS
PUBLIC	_JabberXmlGetChild
PUBLIC	_JabberXmlGetNthChild
;	COMDAT _JabberXmlGetChild
_TEXT	SEGMENT
_node$ = 8
_tag$ = 12
_JabberXmlGetChild PROC NEAR				; COMDAT

; 398  : 	return JabberXmlGetNthChild(node, tag, 1);

  00000	6a 01		 push	 1
  00002	ff 74 24 0c	 push	 DWORD PTR _tag$[esp]
  00006	ff 74 24 0c	 push	 DWORD PTR _node$[esp+4]
  0000a	e8 00 00 00 00	 call	 _JabberXmlGetNthChild
  0000f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 399  : }

  00012	c3		 ret	 0
_JabberXmlGetChild ENDP
_TEXT	ENDS
;	COMDAT _JabberXmlGetNthChild
_TEXT	SEGMENT
_node$ = 8
_tag$ = 12
_nth$ = 16
_JabberXmlGetNthChild PROC NEAR				; COMDAT

; 402  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 403  : 	int i, num;
; 404  : 
; 405  : 	if (node==NULL || node->numChild<=0 || tag==NULL || strlen(tag)<=0 || nth<1)

  00005	8b 75 08	 mov	 esi, DWORD PTR _node$[ebp]
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 4c		 je	 SHORT $L83096
  0000f	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00012	7e 47		 jle	 SHORT $L83096
  00014	39 7d 0c	 cmp	 DWORD PTR _tag$[ebp], edi
  00017	74 42		 je	 SHORT $L83096
  00019	ff 75 0c	 push	 DWORD PTR _tag$[ebp]
  0001c	e8 00 00 00 00	 call	 _strlen
  00021	85 c0		 test	 eax, eax
  00023	59		 pop	 ecx
  00024	76 35		 jbe	 SHORT $L83096
  00026	6a 01		 push	 1
  00028	5b		 pop	 ebx
  00029	39 5d 10	 cmp	 DWORD PTR _nth$[ebp], ebx
  0002c	7c 2d		 jl	 SHORT $L83096

; 407  : 	num = 1;
; 408  : 	for (i=0; i<node->numChild; i++) {

  0002e	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00031	7e 28		 jle	 SHORT $L83096
$L83094:

; 409  : 		if (node->child[i]->name && !strcmp(tag, node->child[i]->name)) {

  00033	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00036	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00039	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003c	85 c0		 test	 eax, eax
  0003e	74 15		 je	 SHORT $L83095
  00040	50		 push	 eax
  00041	ff 75 0c	 push	 DWORD PTR _tag$[ebp]
  00044	e8 00 00 00 00	 call	 _strcmp
  00049	59		 pop	 ecx
  0004a	85 c0		 test	 eax, eax
  0004c	59		 pop	 ecx
  0004d	75 06		 jne	 SHORT $L83095

; 410  : 			if (num == nth) {

  0004f	3b 5d 10	 cmp	 ebx, DWORD PTR _nth$[ebp]
  00052	74 0e		 je	 SHORT $L83413

; 412  : 			}
; 413  : 			num++;

  00054	43		 inc	 ebx
$L83095:

; 407  : 	num = 1;
; 408  : 	for (i=0; i<node->numChild; i++) {

  00055	47		 inc	 edi
  00056	3b 7e 14	 cmp	 edi, DWORD PTR [esi+20]
  00059	7c d8		 jl	 SHORT $L83094
$L83096:

; 406  : 		return NULL;

  0005b	33 c0		 xor	 eax, eax
$L83086:
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 414  : 		}
; 415  : 	}
; 416  : 	return NULL;
; 417  : }

  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
$L83413:

; 411  : 				return node->child[i];

  00062	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00065	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00068	eb f3		 jmp	 SHORT $L83086
_JabberXmlGetNthChild ENDP
_TEXT	ENDS
PUBLIC	_JabberXmlGetChildWithGivenAttrValue
;	COMDAT _JabberXmlGetChildWithGivenAttrValue
_TEXT	SEGMENT
_node$ = 8
_tag$ = 12
_attrKey$ = 16
_attrValue$ = 20
_JabberXmlGetChildWithGivenAttrValue PROC NEAR		; COMDAT

; 420  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 421  : 	int i;
; 422  : 	char *str;
; 423  : 
; 424  : 	if (node==NULL || node->numChild<=0 || tag==NULL || strlen(tag)<=0 || attrKey==NULL || strlen(attrKey)<=0 || attrValue==NULL || strlen(attrValue)<=0)

  00005	8b 75 08	 mov	 esi, DWORD PTR _node$[ebp]
  00008	33 db		 xor	 ebx, ebx
  0000a	3b f3		 cmp	 esi, ebx
  0000c	57		 push	 edi
  0000d	0f 84 8b 00 00
	00		 je	 $L83120
  00013	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00016	0f 8e 82 00 00
	00		 jle	 $L83120
  0001c	39 5d 0c	 cmp	 DWORD PTR _tag$[ebp], ebx
  0001f	74 7d		 je	 SHORT $L83120
  00021	ff 75 0c	 push	 DWORD PTR _tag$[ebp]
  00024	e8 00 00 00 00	 call	 _strlen
  00029	85 c0		 test	 eax, eax
  0002b	59		 pop	 ecx
  0002c	76 70		 jbe	 SHORT $L83120
  0002e	39 5d 10	 cmp	 DWORD PTR _attrKey$[ebp], ebx
  00031	74 6b		 je	 SHORT $L83120
  00033	ff 75 10	 push	 DWORD PTR _attrKey$[ebp]
  00036	e8 00 00 00 00	 call	 _strlen
  0003b	85 c0		 test	 eax, eax
  0003d	59		 pop	 ecx
  0003e	76 5e		 jbe	 SHORT $L83120
  00040	39 5d 14	 cmp	 DWORD PTR _attrValue$[ebp], ebx
  00043	74 59		 je	 SHORT $L83120
  00045	ff 75 14	 push	 DWORD PTR _attrValue$[ebp]
  00048	e8 00 00 00 00	 call	 _strlen
  0004d	85 c0		 test	 eax, eax
  0004f	59		 pop	 ecx
  00050	76 4c		 jbe	 SHORT $L83120

; 426  : 	for (i=0; i<node->numChild; i++) {

  00052	33 ff		 xor	 edi, edi
  00054	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00057	7e 45		 jle	 SHORT $L83120
$L83118:

; 427  : 		if (node->child[i]->name && !strcmp(tag, node->child[i]->name)) {

  00059	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0005c	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  0005f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00062	3b c3		 cmp	 eax, ebx
  00064	74 32		 je	 SHORT $L83119
  00066	50		 push	 eax
  00067	ff 75 0c	 push	 DWORD PTR _tag$[ebp]
  0006a	e8 00 00 00 00	 call	 _strcmp
  0006f	59		 pop	 ecx
  00070	85 c0		 test	 eax, eax
  00072	59		 pop	 ecx
  00073	75 23		 jne	 SHORT $L83119

; 428  : 			if ((str=JabberXmlGetAttrValue(node->child[i], attrKey)) != NULL)

  00075	ff 75 10	 push	 DWORD PTR _attrKey$[ebp]
  00078	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0007b	ff 34 b8	 push	 DWORD PTR [eax+edi*4]
  0007e	e8 00 00 00 00	 call	 _JabberXmlGetAttrValue
  00083	59		 pop	 ecx
  00084	3b c3		 cmp	 eax, ebx
  00086	59		 pop	 ecx
  00087	74 0f		 je	 SHORT $L83119

; 429  : 				if (!strcmp(str, attrValue))

  00089	ff 75 14	 push	 DWORD PTR _attrValue$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _strcmp
  00092	59		 pop	 ecx
  00093	85 c0		 test	 eax, eax
  00095	59		 pop	 ecx
  00096	74 0d		 je	 SHORT $L83419
$L83119:

; 426  : 	for (i=0; i<node->numChild; i++) {

  00098	47		 inc	 edi
  00099	3b 7e 14	 cmp	 edi, DWORD PTR [esi+20]
  0009c	7c bb		 jl	 SHORT $L83118
$L83120:

; 425  : 		return NULL;

  0009e	33 c0		 xor	 eax, eax
$L83108:
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx

; 431  : 		}
; 432  : 	}
; 433  : 	return NULL;
; 434  : }

  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
$L83419:

; 430  : 					return node->child[i];

  000a5	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  000a8	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  000ab	eb f3		 jmp	 SHORT $L83108
_JabberXmlGetChildWithGivenAttrValue ENDP
_TEXT	ENDS
;	COMDAT _JabberXmlRemoveChild
_TEXT	SEGMENT
_node$ = 8
_child$ = 12
_JabberXmlRemoveChild PROC NEAR				; COMDAT

; 438  : 	int i;
; 439  : 
; 440  : 	if (node==NULL || child==NULL || node->numChild<=0) return;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _node$[esp-4]
  00004	56		 push	 esi
  00005	85 c0		 test	 eax, eax
  00007	57		 push	 edi
  00008	74 49		 je	 SHORT $L83135
  0000a	8b 7c 24 10	 mov	 edi, DWORD PTR _child$[esp+4]
  0000e	85 ff		 test	 edi, edi
  00010	74 41		 je	 SHORT $L83135
  00012	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00015	85 d2		 test	 edx, edx
  00017	7e 3a		 jle	 SHORT $L83135

; 441  : 	for (i=0; i<node->numChild; i++) {

  00019	33 c9		 xor	 ecx, ecx
  0001b	85 d2		 test	 edx, edx
  0001d	7e 0f		 jle	 SHORT $L83424
  0001f	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
$L83136:

; 442  : 		if (node->child[i] == child)

  00022	39 3e		 cmp	 DWORD PTR [esi], edi
  00024	74 08		 je	 SHORT $L83424
  00026	41		 inc	 ecx
  00027	83 c6 04	 add	 esi, 4
  0002a	3b ca		 cmp	 ecx, edx
  0002c	7c f4		 jl	 SHORT $L83136
$L83424:

; 443  : 			break;
; 444  : 	}
; 445  : 	if (i < node->numChild) {

  0002e	3b ca		 cmp	 ecx, edx
  00030	7d 21		 jge	 SHORT $L83135

; 446  : 		for (++i; i<node->numChild; i++)

  00032	41		 inc	 ecx
  00033	3b ca		 cmp	 ecx, edx
  00035	7d 12		 jge	 SHORT $L83143
$L83141:
  00037	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]

; 447  : 			node->child[i-1] = node->child[i];

  0003a	8b 34 8a	 mov	 esi, DWORD PTR [edx+ecx*4]
  0003d	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00040	41		 inc	 ecx
  00041	89 72 fc	 mov	 DWORD PTR [edx-4], esi
  00044	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00047	7c ee		 jl	 SHORT $L83141
$L83143:

; 448  : 		node->numChild--;

  00049	ff 48 14	 dec	 DWORD PTR [eax+20]

; 449  : 		JabberXmlFreeNode(child);

  0004c	57		 push	 edi
  0004d	e8 00 00 00 00	 call	 _JabberXmlFreeNode
  00052	59		 pop	 ecx
$L83135:
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 450  : 	}
; 451  : }

  00055	c3		 ret	 0
_JabberXmlRemoveChild ENDP
_TEXT	ENDS
;	COMDAT _JabberXmlFreeNode
_TEXT	SEGMENT
_node$ = 8
_JabberXmlFreeNode PROC NEAR				; COMDAT

; 454  : {

  00000	56		 push	 esi

; 455  : 	int i;
; 456  : 
; 457  : 	if (node == NULL) return;

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _node$[esp]
  00005	85 f6		 test	 esi, esi
  00007	0f 84 a2 00 00
	00		 je	 $L83146
  0000d	57		 push	 edi

; 458  : 	// Free all children first
; 459  : 	for (i=0; i<node->numChild; i++)

  0000e	33 ff		 xor	 edi, edi
  00010	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00013	7e 12		 jle	 SHORT $L83152
$L83150:

; 460  : 		JabberXmlFreeNode(node->child[i]);

  00015	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00018	ff 34 b8	 push	 DWORD PTR [eax+edi*4]
  0001b	e8 00 00 00 00	 call	 _JabberXmlFreeNode
  00020	47		 inc	 edi
  00021	59		 pop	 ecx
  00022	3b 7e 14	 cmp	 edi, DWORD PTR [esi+20]
  00025	7c ee		 jl	 SHORT $L83150
$L83152:

; 461  : 	if (node->child) mir_free(node->child);

  00027	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0002a	85 c0		 test	 eax, eax
  0002c	74 08		 je	 SHORT $L83153
  0002e	50		 push	 eax
  0002f	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00035	59		 pop	 ecx
$L83153:

; 462  : 	// Free all attributes
; 463  : 	for (i=0; i<node->numAttr; i++) {

  00036	33 ff		 xor	 edi, edi
  00038	39 7e 08	 cmp	 DWORD PTR [esi+8], edi
  0003b	7e 3c		 jle	 SHORT $L83156
$L83154:

; 464  : 		if (node->attr[i]->name) mir_free(node->attr[i]->name);

  0003d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00040	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	85 c0		 test	 eax, eax
  00047	74 08		 je	 SHORT $L83157
  00049	50		 push	 eax
  0004a	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00050	59		 pop	 ecx
$L83157:

; 465  : 		if (node->attr[i]->value) mir_free(node->attr[i]->value);

  00051	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00054	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00057	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005a	85 c0		 test	 eax, eax
  0005c	74 08		 je	 SHORT $L83158
  0005e	50		 push	 eax
  0005f	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00065	59		 pop	 ecx
$L83158:

; 466  : 		mir_free(node->attr[i]);

  00066	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00069	ff 34 b8	 push	 DWORD PTR [eax+edi*4]
  0006c	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00072	47		 inc	 edi
  00073	59		 pop	 ecx
  00074	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  00077	7c c4		 jl	 SHORT $L83154
$L83156:

; 467  : 	}
; 468  : 	if (node->attr) mir_free(node->attr);

  00079	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0007c	5f		 pop	 edi
  0007d	85 c0		 test	 eax, eax
  0007f	74 08		 je	 SHORT $L83159
  00081	50		 push	 eax
  00082	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00088	59		 pop	 ecx
$L83159:

; 469  : 	// Free string field
; 470  : 	if (node->text) mir_free(node->text);

  00089	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0008c	85 c0		 test	 eax, eax
  0008e	74 08		 je	 SHORT $L83160
  00090	50		 push	 eax
  00091	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  00097	59		 pop	 ecx
$L83160:

; 471  : 	if (node->name) mir_free(node->name);

  00098	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009b	85 c0		 test	 eax, eax
  0009d	74 08		 je	 SHORT $L83161
  0009f	50		 push	 eax
  000a0	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  000a6	59		 pop	 ecx
$L83161:

; 472  : 	// Free the node itself
; 473  : 	mir_free(node);

  000a7	56		 push	 esi
  000a8	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  000ae	59		 pop	 ecx
$L83146:
  000af	5e		 pop	 esi

; 474  : }

  000b0	c3		 ret	 0
_JabberXmlFreeNode ENDP
_TEXT	ENDS
PUBLIC	_JabberXmlCopyNode
;	COMDAT _JabberXmlCopyNode
_TEXT	SEGMENT
_node$ = 8
_i$ = 8
_JabberXmlCopyNode PROC NEAR				; COMDAT

; 477  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 478  : 	XmlNode *n;
; 479  : 	int i;
; 480  : 
; 481  : 	if (node == NULL) return NULL;

  00005	8b 75 08	 mov	 esi, DWORD PTR _node$[ebp]
  00008	33 db		 xor	 ebx, ebx
  0000a	3b f3		 cmp	 esi, ebx
  0000c	75 07		 jne	 SHORT $L83168
  0000e	33 c0		 xor	 eax, eax
  00010	e9 2f 01 00 00	 jmp	 $L83164
$L83168:
  00015	57		 push	 edi

; 482  : 	n = (XmlNode *) mir_alloc(sizeof(XmlNode));

  00016	6a 28		 push	 40			; 00000028H
  00018	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  0001e	8b f8		 mov	 edi, eax

; 483  : 	// Copy attributes
; 484  : 	if (node->numAttr > 0) {

  00020	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00023	3b c3		 cmp	 eax, ebx
  00025	59		 pop	 ecx
  00026	0f 8e 8b 00 00
	00		 jle	 $L83172

; 485  : 		n->attr = (XmlAttr **) mir_alloc(node->numAttr*sizeof(XmlAttr *));

  0002c	c1 e0 02	 shl	 eax, 2
  0002f	50		 push	 eax
  00030	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 486  : 		for (i=0; i<node->numAttr; i++) {

  00039	39 5e 08	 cmp	 DWORD PTR [esi+8], ebx
  0003c	59		 pop	 ecx
  0003d	89 5d 08	 mov	 DWORD PTR _i$[ebp], ebx
  00040	7e 78		 jle	 SHORT $L83186
$L83175:
  00042	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]

; 487  : 			n->attr[i] = (XmlAttr *) mir_alloc(sizeof(XmlAttr));

  00045	6a 08		 push	 8
  00047	8b d8		 mov	 ebx, eax
  00049	c1 e3 02	 shl	 ebx, 2
  0004c	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  00052	59		 pop	 ecx
  00053	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00056	89 04 19	 mov	 DWORD PTR [ecx+ebx], eax

; 488  : 			if (node->attr[i]->name) n->attr[i]->name = mir_strdup(node->attr[i]->name);

  00059	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005c	8b 04 03	 mov	 eax, DWORD PTR [ebx+eax]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	85 c0		 test	 eax, eax
  00063	74 12		 je	 SHORT $L83180
  00065	50		 push	 eax
  00066	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  0006c	59		 pop	 ecx
  0006d	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00070	8b 0c 19	 mov	 ecx, DWORD PTR [ecx+ebx]
  00073	89 01		 mov	 DWORD PTR [ecx], eax

; 489  : 			else n->attr[i]->name = NULL;

  00075	eb 09		 jmp	 SHORT $L83181
$L83180:
  00077	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0007a	8b 04 18	 mov	 eax, DWORD PTR [eax+ebx]
  0007d	83 20 00	 and	 DWORD PTR [eax], 0
$L83181:

; 490  : 			if (node->attr[i]->value) n->attr[i]->value = mir_strdup(node->attr[i]->value);

  00080	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00083	8b 04 03	 mov	 eax, DWORD PTR [ebx+eax]
  00086	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00089	85 c0		 test	 eax, eax
  0008b	74 13		 je	 SHORT $L83183
  0008d	50		 push	 eax
  0008e	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  00094	59		 pop	 ecx
  00095	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00098	8b 0c 19	 mov	 ecx, DWORD PTR [ecx+ebx]
  0009b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 491  : 			else n->attr[i]->value = NULL;

  0009e	eb 0a		 jmp	 SHORT $L83176
$L83183:
  000a0	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  000a3	8b 04 18	 mov	 eax, DWORD PTR [eax+ebx]
  000a6	83 60 04 00	 and	 DWORD PTR [eax+4], 0
$L83176:
  000aa	ff 45 08	 inc	 DWORD PTR _i$[ebp]
  000ad	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  000b0	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  000b3	7c 8d		 jl	 SHORT $L83175

; 492  : 		}
; 493  : 	}
; 494  : 	else

  000b5	eb 03		 jmp	 SHORT $L83186
$L83172:

; 495  : 		n->attr = NULL;

  000b7	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
$L83186:

; 496  : 	// Recursively copy children
; 497  : 	if (node->numChild > 0) {

  000ba	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000bd	33 db		 xor	 ebx, ebx
  000bf	3b c3		 cmp	 eax, ebx
  000c1	7e 2d		 jle	 SHORT $L83188

; 498  : 		n->child = (XmlNode **) mir_alloc(node->numChild*sizeof(XmlNode *));

  000c3	c1 e0 02	 shl	 eax, 2
  000c6	50		 push	 eax
  000c7	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  000cd	89 47 1c	 mov	 DWORD PTR [edi+28], eax

; 499  : 		for (i=0; i<node->numChild; i++)

  000d0	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  000d3	59		 pop	 ecx
  000d4	7e 1d		 jle	 SHORT $L83194
$L83191:

; 500  : 			n->child[i] = JabberXmlCopyNode(node->child[i]);

  000d6	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  000d9	ff 34 98	 push	 DWORD PTR [eax+ebx*4]
  000dc	e8 00 00 00 00	 call	 _JabberXmlCopyNode
  000e1	59		 pop	 ecx
  000e2	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  000e5	89 04 99	 mov	 DWORD PTR [ecx+ebx*4], eax
  000e8	43		 inc	 ebx
  000e9	3b 5e 14	 cmp	 ebx, DWORD PTR [esi+20]
  000ec	7c e8		 jl	 SHORT $L83191

; 501  : 	}
; 502  : 	else

  000ee	eb 03		 jmp	 SHORT $L83194
$L83188:

; 503  : 		n->child = NULL;

  000f0	89 5f 1c	 mov	 DWORD PTR [edi+28], ebx
$L83194:

; 504  : 	// Copy other fields
; 505  : 	n->numAttr = node->numAttr;

  000f3	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000f6	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 506  : 	n->maxNumAttr = node->numAttr;

  000f9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000fc	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 507  : 	n->numChild = node->numChild;

  000ff	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00102	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 508  : 	n->maxNumChild = node->numChild;

  00105	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00108	89 47 18	 mov	 DWORD PTR [edi+24], eax

; 509  : 	n->depth = node->depth;

  0010b	8b 06		 mov	 eax, DWORD PTR [esi]
  0010d	89 07		 mov	 DWORD PTR [edi], eax

; 510  : 	n->state = node->state;

  0010f	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00112	89 47 24	 mov	 DWORD PTR [edi+36], eax

; 511  : 	n->name = (node->name)?mir_strdup(node->name):NULL;

  00115	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00118	85 c0		 test	 eax, eax
  0011a	74 0a		 je	 SHORT $L83435
  0011c	50		 push	 eax
  0011d	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  00123	59		 pop	 ecx
  00124	eb 02		 jmp	 SHORT $L83436
$L83435:
  00126	33 c0		 xor	 eax, eax
$L83436:
  00128	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 512  : 	n->text = (node->text)?mir_strdup(node->text):NULL;

  0012b	8b 76 20	 mov	 esi, DWORD PTR [esi+32]
  0012e	85 f6		 test	 esi, esi
  00130	74 0a		 je	 SHORT $L83437
  00132	56		 push	 esi
  00133	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  00139	59		 pop	 ecx
  0013a	eb 02		 jmp	 SHORT $L83438
$L83437:
  0013c	33 c0		 xor	 eax, eax
$L83438:
  0013e	89 47 20	 mov	 DWORD PTR [edi+32], eax

; 513  : 
; 514  : 	return n;

  00141	8b c7		 mov	 eax, edi
  00143	5f		 pop	 edi
$L83164:
  00144	5e		 pop	 esi
  00145	5b		 pop	 ebx

; 515  : }

  00146	5d		 pop	 ebp
  00147	c3		 ret	 0
_JabberXmlCopyNode ENDP
_TEXT	ENDS
PUBLIC	_JabberXmlCreateNode
EXTRN	_memset:NEAR
;	COMDAT _JabberXmlCreateNode
_TEXT	SEGMENT
_name$ = 8
_JabberXmlCreateNode PROC NEAR				; COMDAT

; 519  : 	XmlNode *n;
; 520  : 
; 521  : 	if (name == NULL)

  00000	83 7c 24 04 00	 cmp	 DWORD PTR _name$[esp-4], 0
  00005	75 03		 jne	 SHORT $L83203

; 522  : 		return NULL;

  00007	33 c0		 xor	 eax, eax

; 528  : }

  00009	c3		 ret	 0
$L83203:
  0000a	56		 push	 esi

; 523  : 
; 524  : 	n = (XmlNode *) mir_alloc(sizeof(XmlNode));

  0000b	6a 28		 push	 40			; 00000028H
  0000d	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  00013	8b f0		 mov	 esi, eax

; 525  : 	memset(n, 0, sizeof(XmlNode));

  00015	6a 28		 push	 40			; 00000028H
  00017	6a 00		 push	 0
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 _memset

; 526  : 	n->name = mir_strdup(name);

  0001f	ff 74 24 18	 push	 DWORD PTR _name$[esp+16]
  00023	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  00029	83 c4 14	 add	 esp, 20			; 00000014H
  0002c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 527  : 	return n;

  0002f	8b c6		 mov	 eax, esi
  00031	5e		 pop	 esi

; 528  : }

  00032	c3		 ret	 0
_JabberXmlCreateNode ENDP
_TEXT	ENDS
PUBLIC	_JabberXmlAddAttr
;	COMDAT _JabberXmlAddAttr
_TEXT	SEGMENT
_n$ = 8
_name$ = 12
_value$ = 16
_JabberXmlAddAttr PROC NEAR				; COMDAT

; 531  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 532  : 	int i;
; 533  : 
; 534  : 	if (n==NULL || name==NULL || value==NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 5e		 je	 SHORT $L83220
  0000b	83 7d 0c 00	 cmp	 DWORD PTR _name$[ebp], 0
  0000f	74 58		 je	 SHORT $L83220
  00011	83 7d 10 00	 cmp	 DWORD PTR _value$[ebp], 0
  00015	74 52		 je	 SHORT $L83220
  00017	57		 push	 edi

; 535  : 		return;
; 536  : 
; 537  : 	i = n->numAttr;

  00018	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 538  : 	(n->numAttr)++;

  0001b	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0001e	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 539  : 	n->attr = (XmlAttr **) mir_realloc(n->attr, sizeof(XmlAttr *) * n->numAttr);

  00021	c1 e0 02	 shl	 eax, 2
  00024	50		 push	 eax
  00025	ff 76 10	 push	 DWORD PTR [esi+16]
  00028	ff 15 08 00 00
	00		 call	 DWORD PTR _mmi+8

; 540  : 	n->attr[i] = (XmlAttr *) mir_alloc(sizeof(XmlAttr));

  0002e	6a 08		 push	 8
  00030	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00033	c1 e7 02	 shl	 edi, 2
  00036	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  0003c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]

; 541  : 	n->attr[i]->name = mir_strdup(name);

  0003f	ff 75 0c	 push	 DWORD PTR _name$[ebp]
  00042	89 04 0f	 mov	 DWORD PTR [edi+ecx], eax
  00045	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  0004b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]

; 542  : 	n->attr[i]->value = mir_strdup(value);

  0004e	ff 75 10	 push	 DWORD PTR _value$[ebp]
  00051	8b 0c 0f	 mov	 ecx, DWORD PTR [edi+ecx]
  00054	89 01		 mov	 DWORD PTR [ecx], eax
  00056	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  0005c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0005f	83 c4 14	 add	 esp, 20			; 00000014H
  00062	8b 0c 0f	 mov	 ecx, DWORD PTR [edi+ecx]
  00065	5f		 pop	 edi
  00066	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L83220:
  00069	5e		 pop	 esi

; 543  : }

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_JabberXmlAddAttr ENDP
_TEXT	ENDS
PUBLIC	_JabberXmlAddChild
;	COMDAT _JabberXmlAddChild
_TEXT	SEGMENT
_n$ = 8
_name$ = 12
_JabberXmlAddChild PROC NEAR				; COMDAT

; 546  : {

  00000	56		 push	 esi

; 547  : 	int i;
; 548  : 
; 549  : 	if (n==NULL || name==NULL)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _n$[esp]
  00005	85 f6		 test	 esi, esi
  00007	74 60		 je	 SHORT $L83234
  00009	83 7c 24 0c 00	 cmp	 DWORD PTR _name$[esp], 0
  0000e	74 59		 je	 SHORT $L83234
  00010	57		 push	 edi

; 551  : 
; 552  : 	i = n->numChild;

  00011	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]

; 553  : 	n->numChild++;

  00014	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00017	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 554  : 	n->child = (XmlNode **) mir_realloc(n->child, sizeof(XmlNode *) * n->numChild);

  0001a	c1 e0 02	 shl	 eax, 2
  0001d	50		 push	 eax
  0001e	ff 76 1c	 push	 DWORD PTR [esi+28]
  00021	ff 15 08 00 00
	00		 call	 DWORD PTR _mmi+8

; 555  : 	n->child[i] = (XmlNode *) mir_alloc(sizeof(XmlNode));

  00027	6a 28		 push	 40			; 00000028H
  00029	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  0002c	c1 e7 02	 shl	 edi, 2
  0002f	ff 15 04 00 00
	00		 call	 DWORD PTR _mmi+4
  00035	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]

; 556  : 	memset(n->child[i], 0, sizeof(XmlNode));

  00038	6a 28		 push	 40			; 00000028H
  0003a	6a 00		 push	 0
  0003c	89 04 39	 mov	 DWORD PTR [ecx+edi], eax
  0003f	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00042	ff 34 38	 push	 DWORD PTR [eax+edi]
  00045	e8 00 00 00 00	 call	 _memset

; 557  : 	n->child[i]->name = mir_strdup(name);

  0004a	ff 74 24 28	 push	 DWORD PTR _name$[esp+28]
  0004e	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  00054	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00057	83 c4 1c	 add	 esp, 28			; 0000001cH
  0005a	8b 0c 39	 mov	 ecx, DWORD PTR [ecx+edi]
  0005d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 558  : 	return n->child[i];

  00060	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00063	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi

; 559  : }

  00068	c3		 ret	 0
$L83234:

; 550  : 		return NULL;

  00069	33 c0		 xor	 eax, eax
  0006b	5e		 pop	 esi

; 559  : }

  0006c	c3		 ret	 0
_JabberXmlAddChild ENDP
_TEXT	ENDS
PUBLIC	_JabberXmlAddText
;	COMDAT _JabberXmlAddText
_TEXT	SEGMENT
_n$ = 8
_text$ = 12
_JabberXmlAddText PROC NEAR				; COMDAT

; 562  : {

  00000	56		 push	 esi

; 563  : 	if (n!=NULL && text!=NULL) {

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _n$[esp]
  00005	85 f6		 test	 esi, esi
  00007	74 24		 je	 SHORT $L83248
  00009	83 7c 24 0c 00	 cmp	 DWORD PTR _text$[esp], 0
  0000e	74 1d		 je	 SHORT $L83248

; 564  : 		if (n->text) mir_free(n->text);

  00010	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00013	85 c0		 test	 eax, eax
  00015	74 08		 je	 SHORT $L83249
  00017	50		 push	 eax
  00018	ff 15 0c 00 00
	00		 call	 DWORD PTR _mmi+12
  0001e	59		 pop	 ecx
$L83249:

; 565  : 		n->text = mir_strdup(text);

  0001f	ff 74 24 0c	 push	 DWORD PTR _text$[esp]
  00023	ff 15 14 00 00
	00		 call	 DWORD PTR _mmi+20
  00029	59		 pop	 ecx
  0002a	89 46 20	 mov	 DWORD PTR [esi+32], eax
$L83248:
  0002d	5e		 pop	 esi

; 566  : 	}
; 567  : }

  0002e	c3		 ret	 0
_JabberXmlAddText ENDP
_TEXT	ENDS
END
