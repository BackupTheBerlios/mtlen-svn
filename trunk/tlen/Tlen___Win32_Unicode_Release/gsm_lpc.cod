	TITLE	E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\codec\gsm_lpc.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _autocorrelation
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _schur
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _rToLAR
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _quantizeLARs
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _lpcAnalysis
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_lpcAnalysis
PUBLIC	__real@4@400e8000000000000000
EXTRN	__ftol:NEAR
EXTRN	__fltused:NEAR
;	COMDAT __real@4@400e8000000000000000
; File E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\codec\gsm_lpc.c
CONST	SEGMENT
__real@4@400e8000000000000000 DD 047000000r	; 32768
CONST	ENDS
;	COMDAT _lpcAnalysis
_TEXT	SEGMENT
_state$ = 8
_in$ = 12
_samples$ = -708
_ac$ = -68
_ref$ = -32
_lpcAnalysis PROC NEAR					; COMDAT

; 185  : {	float error;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 02 00
	00		 sub	 esp, 708		; 000002c4H

; 186  : 	float samples[160];
; 187  : 	float ac[9];
; 188  : 	float ref[8];
; 189  : 	int i;
; 190  : 	int * qLARs = state->qLARs;

  00009	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0000c	53		 push	 ebx
  0000d	ba a0 00 00 00	 mov	 edx, 160		; 000000a0H
  00012	56		 push	 esi
  00013	8d 58 44	 lea	 ebx, DWORD PTR [eax+68]
  00016	8b 45 0c	 mov	 eax, DWORD PTR _in$[ebp]
  00019	57		 push	 edi
  0001a	8d 8d 3c fd ff
	ff		 lea	 ecx, DWORD PTR _samples$[ebp]
  00020	8b f2		 mov	 esi, edx
$L75985:

; 191  : 	for (i = 0; i < 160; i++) {
; 192  : 		samples[i] = in[i];

  00022	0f bf 38	 movsx	 edi, WORD PTR [eax]
  00025	89 7d 08	 mov	 DWORD PTR 8+[ebp], edi
  00028	40		 inc	 eax
  00029	db 45 08	 fild	 DWORD PTR 8+[ebp]
  0002c	40		 inc	 eax
  0002d	d9 19		 fstp	 DWORD PTR [ecx]
  0002f	83 c1 04	 add	 ecx, 4
  00032	4e		 dec	 esi
  00033	75 ed		 jne	 SHORT $L75985

; 193  : 	}
; 194  : 	autocorrelation(160, samples, 9, ac);

  00035	8d 45 bc	 lea	 eax, DWORD PTR _ac$[ebp]
  00038	50		 push	 eax
  00039	8d 85 3c fd ff
	ff		 lea	 eax, DWORD PTR _samples$[ebp]
  0003f	6a 09		 push	 9
  00041	50		 push	 eax
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 _autocorrelation

; 195  : 	error=schur(ac, ref);

  00048	8d 45 e0	 lea	 eax, DWORD PTR _ref$[ebp]
  0004b	50		 push	 eax
  0004c	8d 45 bc	 lea	 eax, DWORD PTR _ac$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _schur

; 196  : 	/*
; 197  : 	printf("reff:  ");
; 198  : 	for (i=0;i<8;i++) {
; 199  : 		printf("%5.5f  ", ref[i]);//((float)i_lpc[i])/32768.0f);
; 200  : 	}
; 201  : 	printf("\n");
; 202  : 	*/
; 203  : 	for (i = 0; i < 8; i++) {

  00055	8d 7d e0	 lea	 edi, DWORD PTR _ref$[ebp]
  00058	83 c4 18	 add	 esp, 24			; 00000018H
  0005b	dd d8		 fstp	 ST(0)
  0005d	8b f3		 mov	 esi, ebx
  0005f	2b fb		 sub	 edi, ebx
  00061	c7 45 08 08 00
	00 00		 mov	 DWORD PTR 8+[ebp], 8
$L75988:

; 204  : 		qLARs[i] = (int) (32768 * ref[i]);

  00068	d9 04 37	 fld	 DWORD PTR [edi+esi]
  0006b	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@4@400e8000000000000000
  00071	e8 00 00 00 00	 call	 __ftol
  00076	89 06		 mov	 DWORD PTR [esi], eax
  00078	83 c6 04	 add	 esi, 4
  0007b	ff 4d 08	 dec	 DWORD PTR 8+[ebp]
  0007e	75 e8		 jne	 SHORT $L75988

; 205  : 	}
; 206  : 	rToLAR(qLARs);

  00080	53		 push	 ebx
  00081	e8 00 00 00 00	 call	 _rToLAR

; 207  : 	quantizeLARs(qLARs, qLARs);

  00086	53		 push	 ebx
  00087	53		 push	 ebx
  00088	e8 00 00 00 00	 call	 _quantizeLARs
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx

; 208  : }

  00093	c9		 leave
  00094	c3		 ret	 0
_lpcAnalysis ENDP
_TEXT	ENDS
PUBLIC	__real@4@00000000000000000000
EXTRN	_fabs:NEAR
;	COMDAT __real@4@00000000000000000000
; File E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\codec\gsm_lpc.c
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT _autocorrelation
_TEXT	SEGMENT
_n$ = 8
_x$ = 12
_lag$ = 16
_ac$ = 20
_autocorrelation PROC NEAR				; COMDAT

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 49   :     float d;
; 50   :     int i, j;
; 51   :     for (j = 0; j < lag; j++) {

  00005	33 f6		 xor	 esi, esi
  00007	33 db		 xor	 ebx, ebx
  00009	39 75 10	 cmp	 DWORD PTR _lag$[ebp], esi
  0000c	7e 33		 jle	 SHORT $L75907
  0000e	57		 push	 edi
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR _x$[ebp]
$L75905:

; 52   :         for (i = j, d = 0; i < n; i++) d += x[i] * x[i-j];

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00015	3b d9		 cmp	 ebx, ecx
  00017	d9 ee		 fldz
  00019	7d 16		 jge	 SHORT $L75910
  0001b	8b d6		 mov	 edx, esi
  0001d	2b cb		 sub	 ecx, ebx
$L75908:
  0001f	8b c2		 mov	 eax, edx
  00021	2b c6		 sub	 eax, esi
  00023	d9 04 38	 fld	 DWORD PTR [eax+edi]
  00026	d8 0c 3a	 fmul	 DWORD PTR [edx+edi]
  00029	83 c2 04	 add	 edx, 4
  0002c	49		 dec	 ecx
  0002d	de c1		 faddp	 ST(1), ST(0)
  0002f	75 ee		 jne	 SHORT $L75908
$L75910:

; 53   :         ac[j] = d;

  00031	8b 45 14	 mov	 eax, DWORD PTR _ac$[ebp]
  00034	43		 inc	 ebx
  00035	d9 1c 06	 fstp	 DWORD PTR [esi+eax]
  00038	83 c6 04	 add	 esi, 4
  0003b	3b 5d 10	 cmp	 ebx, DWORD PTR _lag$[ebp]
  0003e	7c d2		 jl	 SHORT $L75905
  00040	5f		 pop	 edi
$L75907:

; 54   :     }
; 55   : 	d = (float)fabs(ac[0]);

  00041	8b 75 14	 mov	 esi, DWORD PTR _ac$[ebp]
  00044	51		 push	 ecx
  00045	51		 push	 ecx
  00046	d9 06		 fld	 DWORD PTR [esi]
  00048	dd 1c 24	 fstp	 QWORD PTR [esp]
  0004b	e8 00 00 00 00	 call	 _fabs

; 56   : 	if (d != 0) {

  00050	d8 15 00 00 00
	00		 fcom	 DWORD PTR __real@4@00000000000000000000
  00056	59		 pop	 ecx
  00057	59		 pop	 ecx
  00058	df e0		 fnstsw	 ax
  0005a	9e		 sahf
  0005b	74 15		 je	 SHORT $L76018

; 57   : 		for (j = 0; j < lag; j++) ac[j] /= d;

  0005d	8b 4d 10	 mov	 ecx, DWORD PTR _lag$[ebp]
  00060	85 c9		 test	 ecx, ecx
  00062	7e 0e		 jle	 SHORT $L76018
  00064	8b c6		 mov	 eax, esi
$L75913:
  00066	d9 00		 fld	 DWORD PTR [eax]
  00068	d8 f1		 fdiv	 ST(0), ST(1)
  0006a	d9 18		 fstp	 DWORD PTR [eax]
  0006c	83 c0 04	 add	 eax, 4
  0006f	49		 dec	 ecx
  00070	75 f4		 jne	 SHORT $L75913
$L76018:
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	dd d8		 fstp	 ST(0)

; 58   : 	}
; 59   : }

  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_autocorrelation ENDP
_TEXT	ENDS
PUBLIC	__real@8@00000000000000000000
;	COMDAT __real@8@00000000000000000000
; File E:\Documents and Settings\piotr\Moje dokumenty\NetBeansProjects\tlen8\codec\gsm_lpc.c
CONST	SEGMENT
__real@8@00000000000000000000 DQ 00000000000000000r ; 0
CONST	ENDS
;	COMDAT _schur
_TEXT	SEGMENT
_ac$ = 8
_ref$ = 12
_r$ = 8
_G$ = -64
_schur	PROC NEAR					; COMDAT

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 109  :     int i, m;
; 110  :     float error=ac[0], r, G[2][P_MAX];

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _ac$[ebp]
  00009	57		 push	 edi
  0000a	d9 01		 fld	 DWORD PTR [ecx]

; 111  : 
; 112  :     if (ac[0] == 0.0) {

  0000c	d9 01		 fld	 DWORD PTR [ecx]
  0000e	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  00014	df e0		 fnstsw	 ax
  00016	9e		 sahf
  00017	75 14		 jne	 SHORT $L75927

; 113  :         for (i = 0; i < P_MAX; i++) ref[i] = 0;

  00019	8b 7d 0c	 mov	 edi, DWORD PTR _ref$[ebp]
  0001c	6a 08		 push	 8
  0001e	dd d8		 fstp	 ST(0)

; 114  :         return 0;

  00020	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@4@00000000000000000000
  00026	59		 pop	 ecx
  00027	33 c0		 xor	 eax, eax
  00029	f3 ab		 rep stosd
  0002b	eb 7f		 jmp	 SHORT $L75936
$L75927:

; 115  :     }
; 116  : 
; 117  :     /* Initialize the rows of the generator matrix G to ac[1...p]. */
; 118  :     for (i = 0; i < P_MAX; i++) G[0][i] = G[1][i] = ac[i + 1];

  0002d	6a 08		 push	 8
  0002f	8d 45 c0	 lea	 eax, DWORD PTR _G$[ebp]
  00032	5a		 pop	 edx
  00033	83 c1 04	 add	 ecx, 4
  00036	6a 04		 push	 4
  00038	5f		 pop	 edi
$L75931:
  00039	d9 01		 fld	 DWORD PTR [ecx]
  0003b	03 cf		 add	 ecx, edi
  0003d	d9 50 20	 fst	 DWORD PTR [eax+32]
  00040	d9 18		 fstp	 DWORD PTR [eax]
  00042	03 c7		 add	 eax, edi
  00044	4a		 dec	 edx
  00045	75 f2		 jne	 SHORT $L75931

; 119  : 
; 120  :     for (i = 0;;) {
; 121  :         /* Calculate this iteration's reflection coefficient and error. */
; 122  :         ref[i] = r = -G[1][0] / error;

  00047	d9 45 e0	 fld	 DWORD PTR _G$[ebp+32]
  0004a	d8 f1		 fdiv	 ST(0), ST(1)
  0004c	8b 45 0c	 mov	 eax, DWORD PTR _ref$[ebp]
  0004f	56		 push	 esi
  00050	6a 07		 push	 7
  00052	5a		 pop	 edx
  00053	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]

; 126  : 
; 127  :         /* Update the generator matrix. Unlike Levinson-Durbin's summing of
; 128  :          * reflection coefficients, this loop could be executed in parallel
; 129  :          * by p processors in constant time.
; 130  :          */
; 131  :         for (m = 0; m < P_MAX - i; m++) {

  00056	85 d2		 test	 edx, edx
  00058	d9 e0		 fchs
  0005a	d9 55 08	 fst	 DWORD PTR _r$[ebp]
  0005d	d9 c0		 fld	 ST(0)
  0005f	d9 18		 fstp	 DWORD PTR [eax]
  00061	d9 45 e0	 fld	 DWORD PTR _G$[ebp+32]
  00064	d8 c9		 fmul	 ST(0), ST(1)
  00066	d8 c2		 fadd	 ST(0), ST(2)
  00068	dd da		 fstp	 ST(2)
  0006a	dd d8		 fstp	 ST(0)
  0006c	d9 45 08	 fld	 DWORD PTR _r$[ebp]
  0006f	7e 1d		 jle	 SHORT $L76033
$L76035:
  00071	8d 45 c0	 lea	 eax, DWORD PTR _G$[ebp]
  00074	8b f2		 mov	 esi, edx
$L75938:

; 132  :             G[1][m] = G[1][m + 1] + r * G[0][m];

  00076	d9 c0		 fld	 ST(0)
  00078	d8 08		 fmul	 DWORD PTR [eax]
  0007a	d8 40 24	 fadd	 DWORD PTR [eax+36]
  0007d	d9 58 20	 fstp	 DWORD PTR [eax+32]

; 133  :             G[0][m] = G[1][m + 1] * r + G[0][m];

  00080	d9 c0		 fld	 ST(0)
  00082	d8 48 24	 fmul	 DWORD PTR [eax+36]
  00085	d8 00		 fadd	 DWORD PTR [eax]
  00087	d9 18		 fstp	 DWORD PTR [eax]
  00089	03 c7		 add	 eax, edi
  0008b	4e		 dec	 esi
  0008c	75 e8		 jne	 SHORT $L75938
$L76033:

; 119  : 
; 120  :     for (i = 0;;) {
; 121  :         /* Calculate this iteration's reflection coefficient and error. */
; 122  :         ref[i] = r = -G[1][0] / error;

  0008e	dd d8		 fstp	 ST(0)
  00090	d9 45 e0	 fld	 DWORD PTR _G$[ebp+32]
  00093	d8 f1		 fdiv	 ST(0), ST(1)

; 123  :         error += G[1][0] * r;
; 124  : 
; 125  :         if (++i >= P_MAX) return error;

  00095	4a		 dec	 edx
  00096	d9 e0		 fchs
  00098	d9 11		 fst	 DWORD PTR [ecx]
  0009a	d9 45 e0	 fld	 DWORD PTR _G$[ebp+32]
  0009d	d8 c9		 fmul	 ST(0), ST(1)
  0009f	03 cf		 add	 ecx, edi
  000a1	85 d2		 test	 edx, edx
  000a3	d8 c2		 fadd	 ST(0), ST(2)
  000a5	dd da		 fstp	 ST(2)
  000a7	7f c8		 jg	 SHORT $L76035
  000a9	dd d8		 fstp	 ST(0)
  000ab	5e		 pop	 esi
$L75936:
  000ac	5f		 pop	 edi

; 134  :         }
; 135  :     }
; 136  : }

  000ad	c9		 leave
  000ae	c3		 ret	 0
_schur	ENDP
_TEXT	ENDS
EXTRN	_abs:NEAR
;	COMDAT _rToLAR
_TEXT	SEGMENT
_r$ = 8
_rToLAR	PROC NEAR					; COMDAT

; 148  : {

  00000	56		 push	 esi

; 149  :    int   temp;
; 150  :    int   i;
; 151  : 
; 152  :    /* Computation of the LAR[0..7] from the r[0..7]
; 153  :     */
; 154  :    for (i = 0; i < 8; i++) {

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _r$[esp]
  00005	57		 push	 edi
  00006	6a 08		 push	 8
  00008	5f		 pop	 edi
$L75947:

; 155  :       temp = abs(r[i]); //GSM_ABS(temp);

  00009	ff 36		 push	 DWORD PTR [esi]
  0000b	e8 00 00 00 00	 call	 _abs

; 156  :       if (temp < 22118) {

  00010	3d 66 56 00 00	 cmp	 eax, 22118		; 00005666H
  00015	59		 pop	 ecx
  00016	7d 04		 jge	 SHORT $L75950

; 157  :          temp >>= 1;

  00018	d1 f8		 sar	 eax, 1

; 158  :       } else if (temp < 31130) {

  0001a	eb 15		 jmp	 SHORT $L75953
$L75950:
  0001c	3d 9a 79 00 00	 cmp	 eax, 31130		; 0000799aH
  00021	7d 07		 jge	 SHORT $L75952

; 159  : 		 temp -= 11059;

  00023	2d 33 2b 00 00	 sub	 eax, 11059		; 00002b33H

; 160  :       } else {

  00028	eb 07		 jmp	 SHORT $L75953
$L75952:

; 161  :          temp -= 26112;
; 162  :          temp <<= 2;

  0002a	8d 04 85 00 68
	fe ff		 lea	 eax, DWORD PTR [eax*4-104448]
$L75953:

; 163  :       }
; 164  :       r[i] = r[i] < 0 ? -temp : temp;

  00031	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00034	7d 02		 jge	 SHORT $L76038
  00036	f7 d8		 neg	 eax
$L76038:
  00038	89 06		 mov	 DWORD PTR [esi], eax
  0003a	83 c6 04	 add	 esi, 4
  0003d	4f		 dec	 edi
  0003e	75 c9		 jne	 SHORT $L75947
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 165  :    }
; 166  : }

  00042	c3		 ret	 0
_rToLAR	ENDP
_TEXT	ENDS
;	COMDAT _quantizeLARs
_TEXT	SEGMENT
_LARs$ = 8
_qLARs$ = 12
_qA$ = -32
_qB$ = -64
_qMin$ = -96
_qMax$ = -128
_quantizeLARs PROC NEAR					; COMDAT

; 169  : {	int qA[]={20480, 20480, 20480, 20480, 13964, 15360, 8534, 9036};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	b8 00 50 00 00	 mov	 eax, 20480		; 00005000H

; 170  : 	int qB[]={0, 0, 2048, -2560, 94, -1792, -341, -1144};
; 171  : 	int qMin[]={-32, -32, -16, -16, -8, -8, -4, -4};

  00010	6a e0		 push	 -32			; ffffffe0H
  00012	89 45 e0	 mov	 DWORD PTR _qA$[ebp], eax
  00015	89 45 e4	 mov	 DWORD PTR _qA$[ebp+4], eax
  00018	89 45 e8	 mov	 DWORD PTR _qA$[ebp+8], eax
  0001b	89 45 ec	 mov	 DWORD PTR _qA$[ebp+12], eax
  0001e	58		 pop	 eax

; 172  : 	int qMax[]={31, 31, 15, 15, 7, 7, 3, 3};
; 173  : 	int i;
; 174  : 	for (i = 0; i < 8; i++) {

  0001f	8b 55 08	 mov	 edx, DWORD PTR _LARs$[ebp]
  00022	6a f0		 push	 -16			; fffffff0H
  00024	89 45 a0	 mov	 DWORD PTR _qMin$[ebp], eax
  00027	89 45 a4	 mov	 DWORD PTR _qMin$[ebp+4], eax
  0002a	58		 pop	 eax
  0002b	6a f8		 push	 -8			; fffffff8H
  0002d	89 45 a8	 mov	 DWORD PTR _qMin$[ebp+8], eax
  00030	89 45 ac	 mov	 DWORD PTR _qMin$[ebp+12], eax
  00033	58		 pop	 eax
  00034	6a fc		 push	 -4			; fffffffcH
  00036	89 45 b0	 mov	 DWORD PTR _qMin$[ebp+16], eax
  00039	89 45 b4	 mov	 DWORD PTR _qMin$[ebp+20], eax
  0003c	58		 pop	 eax
  0003d	6a 1f		 push	 31			; 0000001fH
  0003f	89 45 b8	 mov	 DWORD PTR _qMin$[ebp+24], eax
  00042	89 45 bc	 mov	 DWORD PTR _qMin$[ebp+28], eax
  00045	58		 pop	 eax
  00046	6a 0f		 push	 15			; 0000000fH
  00048	89 45 80	 mov	 DWORD PTR _qMax$[ebp], eax
  0004b	89 45 84	 mov	 DWORD PTR _qMax$[ebp+4], eax
  0004e	58		 pop	 eax
  0004f	6a 07		 push	 7
  00051	89 45 88	 mov	 DWORD PTR _qMax$[ebp+8], eax
  00054	89 45 8c	 mov	 DWORD PTR _qMax$[ebp+12], eax
  00057	58		 pop	 eax
  00058	83 65 c0 00	 and	 DWORD PTR _qB$[ebp], 0
  0005c	83 65 c4 00	 and	 DWORD PTR _qB$[ebp+4], 0
  00060	6a 03		 push	 3
  00062	89 45 90	 mov	 DWORD PTR _qMax$[ebp+16], eax
  00065	89 45 94	 mov	 DWORD PTR _qMax$[ebp+20], eax
  00068	58		 pop	 eax
  00069	89 45 98	 mov	 DWORD PTR _qMax$[ebp+24], eax
  0006c	89 45 9c	 mov	 DWORD PTR _qMax$[ebp+28], eax
  0006f	8d 45 e0	 lea	 eax, DWORD PTR _qA$[ebp]
  00072	c7 45 f0 8c 36
	00 00		 mov	 DWORD PTR _qA$[ebp+16], 13964 ; 0000368cH
  00079	2b d0		 sub	 edx, eax
  0007b	c7 45 f4 00 3c
	00 00		 mov	 DWORD PTR _qA$[ebp+20], 15360 ; 00003c00H
  00082	c7 45 f8 56 21
	00 00		 mov	 DWORD PTR _qA$[ebp+24], 8534 ; 00002156H
  00089	c7 45 fc 4c 23
	00 00		 mov	 DWORD PTR _qA$[ebp+28], 9036 ; 0000234cH
  00090	c7 45 c8 00 08
	00 00		 mov	 DWORD PTR _qB$[ebp+8], 2048 ; 00000800H
  00097	c7 45 cc 00 f6
	ff ff		 mov	 DWORD PTR _qB$[ebp+12], -2560 ; fffff600H
  0009e	c7 45 d0 5e 00
	00 00		 mov	 DWORD PTR _qB$[ebp+16], 94 ; 0000005eH
  000a5	c7 45 d4 00 f9
	ff ff		 mov	 DWORD PTR _qB$[ebp+20], -1792 ; fffff900H
  000ac	c7 45 d8 ab fe
	ff ff		 mov	 DWORD PTR _qB$[ebp+24], -341 ; fffffeabH
  000b3	c7 45 dc 88 fb
	ff ff		 mov	 DWORD PTR _qB$[ebp+28], -1144 ; fffffb88H
  000ba	33 c0		 xor	 eax, eax
$L75965:

; 175  : 		int temp;
; 176  : 		temp = (((LARs[i] * qA[i]) >> 15) + qB[i] + 256) >> 9;

  000bc	8d 4c 05 e0	 lea	 ecx, DWORD PTR _qA$[ebp+eax]

; 177  : 		if (temp < qMin[i]) temp = 0;

  000c0	8b 7c 05 a0	 mov	 edi, DWORD PTR _qMin$[ebp+eax]
  000c4	8b 34 0a	 mov	 esi, DWORD PTR [edx+ecx]
  000c7	0f af 31	 imul	 esi, DWORD PTR [ecx]
  000ca	8b 4c 05 c0	 mov	 ecx, DWORD PTR _qB$[ebp+eax]
  000ce	c1 fe 0f	 sar	 esi, 15			; 0000000fH
  000d1	8d 8c 0e 00 01
	00 00		 lea	 ecx, DWORD PTR [esi+ecx+256]
  000d8	c1 f9 09	 sar	 ecx, 9
  000db	3b cf		 cmp	 ecx, edi
  000dd	7d 04		 jge	 SHORT $L75969
  000df	33 c9		 xor	 ecx, ecx

; 178  : 		else if (temp > qMax[i]) temp = qMax[i] - qMin[i];

  000e1	eb 10		 jmp	 SHORT $L75972
$L75969:
  000e3	8b 74 05 80	 mov	 esi, DWORD PTR _qMax$[ebp+eax]
  000e7	3b ce		 cmp	 ecx, esi
  000e9	7e 06		 jle	 SHORT $L75971
  000eb	2b f7		 sub	 esi, edi
  000ed	8b ce		 mov	 ecx, esi

; 179  : 		else temp = temp - qMin[i];

  000ef	eb 02		 jmp	 SHORT $L75972
$L75971:
  000f1	2b cf		 sub	 ecx, edi
$L75972:

; 180  : 		qLARs[i] = temp;

  000f3	8b 75 0c	 mov	 esi, DWORD PTR _qLARs$[ebp]
  000f6	89 0c 30	 mov	 DWORD PTR [eax+esi], ecx
  000f9	83 c0 04	 add	 eax, 4
  000fc	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ff	7c bb		 jl	 SHORT $L75965
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi

; 181  : 	}
; 182  : }

  00103	c9		 leave
  00104	c3		 ret	 0
_quantizeLARs ENDP
_TEXT	ENDS
END
